<!-- Chunk 1399: bytes 5128918-5130328, type=class -->
class ModelUpdate(BaseModel):
    field1: Optional[str] = None
    field2: Optional[int] = None
    field3: Optional[bool] = None

# PATCH endpoint
@app.patch("/items/{item_id}")
async def update_item(item_id: int, item_update: ModelUpdate):
    # Get existing item
    existing_item = get_item(item_id)
    if not existing_item:
        raise HTTPException(404, "Item not found")

    # Extract provided fields
    update_data = item_update.model_dump(exclude_unset=True)

    # Handle empty update
    if not update_data:
        return existing_item

    # Apply partial updates
    updated_item = existing_item.model_copy(update=update_data)

    # Save and return
    return save_item(updated_item)
```

---

**That's it! Three simple steps to implement PATCH endpoints in FastAPI.**


============================================================
END FILE: skills/python/fastapi-production/examples/02-partial-updates/QUICK_REFERENCE.md
============================================================

============================================================
FILE: skills/python/fastapi-production/examples/02-partial-updates/interactive_demo.py
============================================================

"""
Interactive demonstration of PATCH endpoint behavior
Shows exactly how partial updates work step by step
"""


from pydantic import BaseModel, EmailStr


# Simplified models for demonstration
