<!-- Chunk 1414: bytes 5146877-5164017, type=function -->
def test_update_user_with_model_copy():
    """
    Demonstrate how model_copy(update=...) works for partial updates.

    This is the other key mechanism for PATCH endpoints.
    """
    print("\n" + "="*70)
    print("MODEL_COPY DEMONSTRATION")
    print("="*70)

    from patch_endpoint_example import User

    original_user = User(id=1, name="John Doe", email="john@example.com", age=30)

    print("\nOriginal user:")
    print(f"  {original_user.model_dump()}")

    # Simulate partial update - only name and age
    update_data = {"name": "John Updated", "age": 35}

    print("\nUpdate data (only name and age):")
    print(f"  {update_data}")

    # Use model_copy with update parameter
    updated_user = original_user.model_copy(update=update_data)

    print("\nUpdated user using model_copy(update=...):")
    print(f"  {updated_user.model_dump()}")

    print("\nNotice:")
    print(f"  - name changed: {original_user.name} -> {updated_user.name}")
    print(f"  - age changed: {original_user.age} -> {updated_user.age}")
    print(f"  - email unchanged: {updated_user.email}")

    print("\n" + "="*70)


if __name__ == "__main__":
    print("\n" + "="*70)
    print("FASTAPI PATCH ENDPOINT - DEMONSTRATION & TESTS")
    print("="*70)

    # Run model demonstrations first
    test_model_dump_exclude_unset()
    test_update_user_with_model_copy()

    print("\n" + "="*70)
    print("RUNNING TESTS")
    print("="*70 + "\n")

    # Run tests
    test_partial_update_name_only()
    test_partial_update_age_only()
    test_partial_update_multiple_fields()
    test_empty_update()
    test_full_update()

    print("\n" + "="*70)
    print("ALL TESTS PASSED!")
    print("="*70)

    print("""
SUMMARY:
--------
The PATCH endpoint works correctly by:

1. Using Optional fields in the Pydantic model (UserUpdate)
2. Using exclude_unset=True to get only provided fields
3. Using model_copy(update=...) to apply partial updates
4. Returning the user unchanged if no fields are provided

This allows clients to update only the fields they need to change,
without having to send the entire object.
    """)


============================================================
END FILE: skills/python/fastapi-production/examples/02-partial-updates/test_patch_endpoint.py
============================================================

============================================================
FILE: skills/python/fastapi-production/examples/02-partial-updates/visual_guide.py
============================================================

"""
Visual Guide: How PATCH Endpoint Handles Partial Updates

This file shows the step-by-step flow of how partial updates work.
"""

print("""
╔══════════════════════════════════════════════════════════════════════════════╗
║                   FASTAPI PATCH ENDPOINT - VISUAL GUIDE                      ║
╚══════════════════════════════════════════════════════════════════════════════╝

SCENARIO: Client wants to update only the user's name
───────────────────────────────────────────────────────────────────────────────

1. CLIENT REQUEST
   PATCH /users/1
   Content-Type: application/json

   {
     "name": "John Updated"
   }


2. FASTAPI RECEIVES REQUEST
   ┌─────────────────────────────────────────────────────────┐
   │ UserUpdate(name="John Updated", email=None, age=None)  │
   └─────────────────────────────────────────────────────────┘
   ↓
   Pydantic parses JSON and creates model with:
   - name = "John Updated"  ← explicitly set
   - email = None           ← not provided, defaults to None
   - age = None             ← not provided, defaults to None


3. EXTRACT PROVIDED FIELDS
   user_update.model_dump(exclude_unset=True)
   ↓
   ┌────────────────────────────┐
   │ {"name": "John Updated"}   │
   └────────────────────────────┘

   Key point: exclude_unset=True ONLY includes fields that were
   explicitly set in the request, not fields with None values!


4. GET EXISTING USER
   ┌──────────────────────────────────────────────────────────────┐
   │ User(id=1, name="John Doe", email="john@example.com", age=30)│
   └──────────────────────────────────────────────────────────────┘


5. APPLY PARTIAL UPDATE
   existing_user.model_copy(update={"name": "John Updated"})
   ↓
   ┌───────────────────────────────────────────────────────────────┐
   │ User(id=1,                                                    │
   │      name="John Updated",      ← UPDATED                      │
   │      email="john@example.com", ← UNCHANGED                    │
   │      age=30)                   ← UNCHANGED                    │
   └───────────────────────────────────────────────────────────────┘

   model_copy(update=...) creates a new instance:
   - Updates ONLY fields in the update dict
   - Preserves existing values for other fields
   - Does NOT modify the original object


6. RETURN UPDATED USER
   HTTP 200 OK
   Content-Type: application/json

   {
     "id": 1,
     "name": "John Updated",        ← Changed
     "email": "john@example.com",   ← Unchanged
     "age": 30                      ← Unchanged
   }


╔══════════════════════════════════════════════════════════════════════════════╗
║                         DIFFERENT SCENARIOS                                  ║
╚══════════════════════════════════════════════════════════════════════════════╝

SCENARIO A: Update multiple fields
───────────────────────────────────

Request:
  {"name": "Jane", "age": 25}

exclude_unset=True → {"name": "Jane", "age": 25}

Result:
  name: UPDATED
  email: UNCHANGED
  age: UPDATED


SCENARIO B: Update single field
────────────────────────────────

Request:
  {"age": 35}

exclude_unset=True → {"age": 35}

Result:
  name: UNCHANGED
  email: UNCHANGED
  age: UPDATED


SCENARIO C: Empty request
──────────────────────────

Request:
  {}

exclude_unset=True → {}

Result:
  ALL FIELDS UNCHANGED (early return)


╔══════════════════════════════════════════════════════════════════════════════╗
║                      KEY IMPLEMENTATION DETAILS                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

1. PYDANTIC MODEL DESIGN
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

   class UserUpdate(BaseModel):
       name: Optional[str] = None     # ← Optional allows field to be omitted
       email: Optional[EmailStr] = None
       age: Optional[int] = None

   All fields are Optional with default None:
   ✓ Clients can provide any subset of fields
   ✗ If fields were required, couldn't do partial updates


2. EXTRACTING PROVIDED FIELDS
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

   RIGHT: update_data = user_update.model_dump(exclude_unset=True)
          → Returns ONLY fields that were explicitly set

   WRONG: update_data = user_update.model_dump()
          → Returns ALL fields, with None for unprovided fields
          → Would overwrite existing data with None!


3. APPLYING UPDATES
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

   RIGHT: updated_user = existing_user.model_copy(update=update_data)
          → Creates NEW instance with updates applied
          → Preserves original object (immutable)
          → Only updates fields in update_data

   WRONG: for field, value in update_data.items():
              setattr(existing_user, field, value)
          → Mutates original object
          → Less idiomatic for Pydantic


4. HANDLING EMPTY UPDATES
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

   if not update_data:
       return existing_user

   ✓ Avoids unnecessary database write
   ✓ Returns quickly without processing
   ✓ Clear intent: no changes needed


╔══════════════════════════════════════════════════════════════════════════════╗
║                          PUT vs PATCH                                        ║
╚══════════════════════════════════════════════════════════════════════════════╝

PUT - Complete replacement
──────────────────────────
PUT /users/1
{
  "name": "John",
  "email": "john@example.com",  ← Must include ALL fields
  "age": 30                      ← Even if not changing
}
↓
Replaces ENTIRE resource


PATCH - Partial update
──────────────────────
PATCH /users/1
{
  "name": "John"    ← Only include CHANGED fields
}
↓
Updates ONLY provided fields


╔══════════════════════════════════════════════════════════════════════════════╗
║                        SUMMARY                                               ║
╚══════════════════════════════════════════════════════════════════════════════╝

To implement a PATCH endpoint that only updates provided fields:

1. Create update model with ALL Optional fields
2. Use model_dump(exclude_unset=True) to get provided fields
3. Use model_copy(update=...) to apply updates
4. Handle empty updates with early return
5. Return the updated user

This approach:
✓ Is idiomatic FastAPI/Pydantic
✓ Handles all edge cases
✓ Is type-safe
✓ Provides automatic API documentation
✓ Is easy to test and maintain

╔══════════════════════════════════════════════════════════════════════════════╗
""")


============================================================
END FILE: skills/python/fastapi-production/examples/02-partial-updates/visual_guide.py
============================================================

============================================================
FILE: skills/python/fastapi-production/examples/README.md
============================================================

# FastAPI Production Examples

This directory contains production-ready examples demonstrating the patterns from the FastAPI Production Patterns skill.

## Structure

```
examples/
├── README.md                  # This file
├── 01-database-lifecycle/     # Database lifecycle management
├── 02-partial-updates/        # Pydantic partial updates (PATCH)
├── 03-async-conversion/       # Sync to async conversion
├── 04-dependency-injection/   # Dependency injection patterns
├── 05-async-testing/          # Async testing patterns
├── 06-file-uploads/           # File upload handling
├── 07-background-tasks/       # Background task patterns
└── 08-python-to-api/          # Converting Python utilities to APIs
```

## Quick Start

Each example is self-contained and can be run independently:

```bash
# Navigate to example directory
cd examples/02-partial-updates

# Install dependencies (from skill root)
cd ../.. && uv sync

# Run the example
uv run python 02-partial-updates/patch_endpoint_example.py
```

## Examples Overview

### 01. Database Lifecycle Management
Demonstrates proper database engine lifecycle with lifespan context manager, connection pooling, and shutdown handling.

**Key patterns:**
- Engine creation in lifespan (not at import)
- Connection pool configuration (`pool_size`, `max_overflow`, `pool_recycle`)
- Proper shutdown with `engine.dispose()`

### 02. Partial Updates (PATCH) ✅
Shows how to implement PATCH endpoints that only update provided fields using `exclude_unset=True`.

**Key patterns:**
- `Optional` fields in Pydantic models
- `model_dump(exclude_unset=True)`
- Preventing `None` overwrites

**Location:** `02-partial-updates/`
**Run:** `uv run python 02-partial-updates/patch_endpoint_example.py`

### 03. Async Conversion
Converts synchronous code to async, replacing blocking libraries with async equivalents.

**Key patterns:**
- `requests` → `httpx.AsyncClient`
- Sync SQLAlchemy → Async SQLAlchemy
- Proper async/await usage

### 04. Dependency Injection
Demonstrates FastAPI's dependency injection for shared resources, caching, and testing.

**Key patterns:**
- Basic dependencies with `Depends()`
- Cached dependencies with `lru_cache`
- Dependency overrides for testing

### 05. Async Testing
Shows how to properly test async endpoints using `httpx.AsyncClient` and async fixtures.

**Key patterns:**
- `AsyncClient` instead of `TestClient`
- Async fixtures with proper cleanup
- Database isolation between tests

### 06. File Uploads
Demonstrates streaming file uploads without loading entire files into memory.

**Key patterns:**
- Streaming file processing
- File validation (type, size)
- Async file I/O with `aiofiles`

### 07. Background Tasks
Shows handling of long-running operations using FastAPI `BackgroundTasks` and Celery.

**Key patterns:**
- Fire-and-forget tasks
- Task status tracking
- Celery integration for production

### 08. Python to API Conversion
Demonstrates converting existing Python utilities to FastAPI endpoints.

**Key patterns:**
- Adding Pydantic validation
- Making functions async
- Replacing exceptions with `HTTPException`

## Testing Examples

```bash
# Test partial updates example
cd examples/02-partial-updates
uv run python test_patch_endpoint.py

# Run with pytest (when available)
uv run pytest
```

## Common Requirements

All examples share common requirements:

```bash
fastapi>=0.100.0
uvicorn[standard]>=0.23.0
sqlalchemy[asyncio]>=2.0.0
asyncpg>=0.29.0
pydantic>=2.0.0
httpx>=0.25.0
pytest>=7.4.0
pytest-asyncio>=0.21.0
```

## See Also

- [SKILL.md](../SKILL.md) - Main skill documentation
- [capabilities/](../capabilities/) - Detailed capability documentation
- [resources/](../resources/) - Additional resources and reference materials


============================================================
END FILE: skills/python/fastapi-production/examples/README.md
============================================================

============================================================
FILE: skills/python/fastapi-production/integration.md
============================================================

### Composition Patterns

- **Database Integration**: Connect `async_db_conn.py` with SQLAlchemy or Tortoise-ORM. Use the Dependency Injection pattern to yield a session/connection, ensuring it is closed after the request.
- **Authentication**: Integrate `auth_flow.py` with external Identity Providers or local JWT logic. Use `Security` dependencies to enforce scopes.
- **DevOps/Deployment**:
    - Use `fastapi run` for simple production deployments or `uvicorn`/`hypercorn` as the ASGI server.
    - For production with multiple workers, use gunicorn with uvicorn workers: `gunicorn main:app -w 4 -k uvicorn.workers.UvicornWorker`
    - Dockerize by using a multi-stage build starting from `python:3.11-slim`.
    - Set `root_path` when deploying behind a reverse proxy (Nginx/Traefik).
    - **Optional: FastAPI Cloud** - Use `fastapi login` and `fastapi deploy` for one-command deployment to FastAPI Cloud.
- **Testing**: Use `httpx.AsyncClient` alongside `pytest-asyncio` to test endpoints without running a real server.

============================================================
END FILE: skills/python/fastapi-production/integration.md
============================================================

============================================================
FILE: skills/python/fastapi-production/metadata.json
============================================================

{
  "skill_id": "technical/programming/web-frameworks/python/fastapi",
  "name": "fastapi-production-patterns",
  "description": "Use when building FastAPI apps with async database operations, complex dependency injection, partial update endpoints, async testing, or converting Python utilities to API endpoints",
  "version": "1.0.0",
  "type": "technical",
  "weight": "medium",
  "load_priority": "task_specific",
  "dependencies": [],
  "capabilities": [
    "database-lifecycle-management",
    "pydantic-partial-updates",
    "async-conversion",
    "dependency-injection",
    "async-testing",
    "file-upload-handling",
    "background-tasks",
    "python-to-api-conversion",
    "fastapi-cli"
  ],
  "category": "Web Development",
  "tags": [
    "python",
    "fastapi",
    "rest-api",
    "asyncio",
    "pydantic",
    "sqlalchemy",
    "production",
    "async"
  ],
  "created_at": "2026-01-07T02:34:11.401895+00:00",
  "last_modified": "2026-01-09T16:45:00.000000+00:00",
  "evolution": {
    "version": "1.0.0",
    "parent_id": null,
    "evolution_path": "initial_release",
    "change_log": "Initial packaging of FastAPI skill set with production patterns following TDD methodology.",
    "validation_score": 1.0,
    "integrity_hash": "a1b2c3d4e5f6g7h8"
  }
}


============================================================
END FILE: skills/python/fastapi-production/metadata.json
============================================================

============================================================
FILE: skills/python/fastapi-production/resources/quick-reference.md
============================================================

# FastAPI Production Patterns - Quick Reference

## Database Lifecycle

```python
from contextlib import asynccontextmanager

@asynccontextmanager
async def lifespan(app: FastAPI):
    engine = create_async_engine(
        DATABASE_URL,
        pool_size=10,
        max_overflow=20,
        pool_recycle=3600,
    )
    app.state.db_engine = engine
    yield
    await engine.dispose()

app = FastAPI(lifespan=lifespan)
```

## Partial Updates (PATCH)

```python
