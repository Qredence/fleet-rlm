<!-- Chunk 718: bytes 2172706-2180939, type=size -->
 that clearly illustrate the catastrophic impact of blocking the event loop.",
    "Strong core principle statement ('One thread, one loop') that simplifies mental modeling for the developer.",
    "Up-to-date code examples utilizing Python 3.11+ structured concurrency (TaskGroup) and modern libraries like httpx.",
    "Clear production-ready patterns for resource cleanup (try...finally) and defensive programming (timeouts).",
    "Actionable debugging section highlighting the use of PYTHONASYNCIODEBUG and specific testing tools like pytest-asyncio."
  ],
  "weaknesses": [
    "Lacks guidance on concurrency limiting (e.g., using asyncio.Semaphore), which is critical for the 'High-Concurrency I/O' use case mentioned.",
    "The TaskGroup example doesn't demonstrate how to handle ExceptionGroups, which is the standard error type when using structured concurrency.",
    "Does not cover the performance implications of 'over-awaiting' or the overhead of creating too many small tasks.",
    "The Database Scalability section mentions specific drivers but lacks a pattern example for connection pooling in an async context."
  ],
  "recommendations": [
    "Add a pattern for asyncio.Semaphore in the 'High-Concurrency I/O' section to show how to prevent resource exhaustion of downstream APIs.",
    "Include a brief example of catching ExceptionGroup when using TaskGroup to improve error handling robustness.",
    "Add a 'Production Pattern' for creating an Async Context Manager using __aenter__ and __aexit__ to complement the resource cleanup section.",
    "Reference the importance of using uvloop for production Linux deployments to further emphasize the performance optimization aspect."
  ],
  "audience_alignment": 0.95,
  "rationale": "The skill content is exceptionally well-structured for an intermediate audience, focusing on the mental shift required for cooperative multitasking rather than just syntax. It introduces modern Python 3.11+ features like TaskGroups and asyncio.timeout, which are current best practices. The 'Golden Rule' and the \u274c/\u2705 contrasts provide high-impact, actionable guidance. It successfully bridges theory (the event loop) with practical production needs (legacy sync bridging, cancellation safety).",
  "deterministic_metrics": {
    "deterministic_score": 0.7499999999999999,
    "pattern_count": 8,
    "has_core_principle": true,
    "has_strong_guidance": true,
    "has_good_bad_contrast": true,
    "code_examples_count": 10,
    "deterministic_issues": [
      "Missing Overview section",
      "Missing key insights after patterns"
    ],
    "deterministic_strengths": [
      "Has skill name",
      "Description follows 'Use when...' pattern",
      "Has When to Use section",
      "Has Core Patterns section",
      "Has Quick Start section",
      "Includes real-world impact/benefits",
      "Has Quick Start section (v2 recommended)",
      "Uses progressive disclosure pattern with subdirectories",
      "Excellent pattern coverage (8 patterns)",
      "Shows both anti-patterns (\u274c) and production patterns (\u2705)",
      "All code blocks have language specification",
      "Code examples are complete (no placeholders)",
      "Code examples are substantial",
      "Rich code examples (10 blocks)",
      "Has clear core principle statement",
      "Has strong imperative guidance (Iron Law style)",
      "Has Good/Bad contrast examples",
      "Adequate description quality"
    ]
  },
  "calibrated_score": 0.7499999999999999
}

============================================================
END FILE: data/mlflow/runs/330001648406427495/2a8000d86d6548a8b79496545e5df469/artifacts/quality_assessment.json
============================================================

============================================================
FILE: data/mlflow/runs/330001648406427495/2a8000d86d6548a8b79496545e5df469/artifacts/skill_content.md
============================================================

---
name: async-programming
description: Use when applications exhibit I/O-bound bottlenecks, unresponsive event loops due to blocking calls, or complex task orchestration needs. Triggers include high-latency API integrations, race conditions in concurrent operations, or bridging legacy sync libraries into async architectures.
---

# Asynchronous Programming in Python

Python's `asyncio` provides a framework for cooperative multitasking. Unlike threading, where the OS preempts execution, `asyncio` relies on explicit yield points (`await`). The core principle is simple: **One thread, one loop.** If you block that loop, you block the world.

## Core Principle: The Single-Threaded Event Loop

The event loop is a continuous loop that monitors "events" (like network data arriving) and schedules tasks. Because it runs on a single thread, any function that does not explicitly yield control back to the loop via `await` will freeze all other concurrent tasks.

**The Golden Rule:** NEVER perform blocking I/O or heavy CPU-bound computation directly in an `async` function without a bridging mechanism.

## When to Use This Skill

- **High-Concurrency I/O**: Managing thousands of simultaneous HTTP connections or WebSockets.
- **Microservices Orchestration**: Aggregating data from multiple high-latency external APIs.
- **Database Scalability**: Handling high-frequency queries using non-blocking drivers (e.g., `motor`, `asyncpg`).
- **Responsive UI/CLIs**: Keeping an interface responsive while background tasks process data.

## Quick Start

Execute multiple tasks safely using Python 3.11+ `TaskGroup`.

```python
import asyncio
import httpx

async def fetch_url(client, url):
    # 'await' yields control back to the loop while waiting for the network
    response = await client.get(url)
    return response.status_code

async def main():
    urls = ["https://python.org", "https://pypi.org"]
    
    async with httpx.AsyncClient() as client:
        # TaskGroup ensures all tasks finish or fail together
        async with asyncio.TaskGroup() as tg:
            tasks = [tg.create_task(fetch_url(client, u)) for u in urls]
        
        # Once the context manager exits, all results are ready
        results = [t.result() for t in tasks]
        print(f"Fetched {len(results)} pages.")

if __name__ == "__main__":
    asyncio.run(main())
```

---

## Core Patterns

### 1. Identifying and Refactoring Blocking I/O
Synchronous libraries like `requests` or `time.sleep` block the thread. In an async context, these are catastrophic.

❌ **Anti-Pattern: Blocking the Loop**
```python
import asyncio
import requests # Synchronous library!
import time

async def blocked_task():
    # Blocks the loop for 1 second. No other tasks can run.
    time.sleep(1) 
    # Blocks the loop while waiting for the network.
    requests.get("https://example.com") 
```

✅ **Production Pattern: Non-Blocking Calls**
```python
import asyncio
import httpx # Asynchronous library

async def non_blocking_task():
    # Yields control back to loop immediately
    await asyncio.sleep(1) 
    
    async with httpx.AsyncClient() as client:
        # Yields control during network latency
        await client.get("https://example.com")
```

### 2. Structured Concurrency with TaskGroups
In Python 3.11+, `TaskGroup` provides a safer way to manage multiple tasks compared to `asyncio.gather`. If one task in a group fails, others are cancelled automatically, preventing "zombie" tasks.

❌ **Anti-Pattern: Manual Task Management**
```python
# Unsafe: If one fails, the others might keep running in the background
tasks = [asyncio.create_task(work(i)) for i in range(5)]
results = await asyncio.gather(*tasks) 
```

✅ **Production Pattern: TaskGroup**
```python
async with asyncio.TaskGroup() as tg:
    # Managed: Errors in any task propagate and cancel the group
    t1 = tg.create_task(fetch_api_a())
    t2 = tg.create_task(fetch_api_b())
# Result access is safe here
print(t1.result(), t2.result())
```

### 3. Bridging the Gap: Sync in Async
When you MUST use a legacy library that has no async equivalent, offload it to a separate thread to prevent loop blockage.

✅ **Production Pattern: `asyncio.to_thread`**
```python
import asyncio
import requests

