<!-- Chunk 1448: bytes 5531477-5532616, type=function -->
def expensive_operation(arg1, arg2):
    print("Performing expensive operation...")
    # Simulate an expensive operation
    import time
    time.sleep(2)
    return arg1 + arg2

print(expensive_operation(1, 2))
print(expensive_operation(1, 2))  # Result is retrieved from the cache
print(expensive_operation(2, 3))
```

**Explanation:**

1.  The `cache` decorator stores the results of the decorated function in a dictionary called `wrapper.cache`.
2.  Before calling the function, the `wrapper` checks if the result for the given arguments is already in the cache.
3.  If the result is in the cache, it returns the cached result. Otherwise, it calls the function, stores the result in the cache, and returns the result.

**Output:**

```
Performing expensive operation...
3
3
Performing expensive operation...
5
```

# Decorator Design Patterns

Decorators can be used to implement various design patterns, such as:

*   **Singleton:** Ensure that only one instance of a class is created.
*   **Observer:** Notify observers when a function is called.
*   **Retry:** Retry a function call if it fails.

## Singleton Decorator

```python
