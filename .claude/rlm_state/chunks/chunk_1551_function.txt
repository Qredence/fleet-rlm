<!-- Chunk 1551: bytes 6410284-6412216, type=function -->
def update_job(job_id: str, updates: dict[str, Any]) -> JobState | None:
    """
    Update a job with the provided updates.

    Args:
        job_id: Job identifier
        updates: Dictionary of fields to update

    Returns:
        Updated JobState if found, None otherwise

    """
    from .job_manager import get_job_manager

    manager = get_job_manager()
    updated_job = manager.update_job(job_id, updates)
    if updated_job:
        JOBS[job_id] = updated_job
    return updated_job


async def wait_for_hitl_response(job_id: str, timeout: float = 3600.0) -> dict[str, Any]:
    """
    Wait for user to provide HITL response via API.

    This uses an event-driven mechanism instead of polling to avoid:
    - unnecessary latency (poll interval)
    - duplicate prompts in clients that poll immediately after POSTing a response

    Uses asyncio.Event on the JobState instance for atomic signaling.
    """
    job = JOBS[job_id]

    # Ensure event is initialized (handles loaded sessions)
    if job.hitl_event is None:
        job.hitl_event = asyncio.Event()

    # Fast-path: response already present (race-safe check)
    response = job.hitl_response
    if response is not None:
        job.hitl_response = None
        job.hitl_event.clear()  # Reset event for next interaction
        job.updated_at = datetime.now(UTC)
        return response

    # Wait for response to be set
    try:
        await asyncio.wait_for(job.hitl_event.wait(), timeout=timeout)
    except TimeoutError as exc:
        raise TimeoutError("HITL response timed out") from exc

    # Atomic check and clear - response is guaranteed to be set after event fires
    response = job.hitl_response
    assert response is not None, "Response should be set after event fires"  # noqa: S101
    job.hitl_response = None
    job.hitl_event.clear()  # Reset for next interaction
    job.updated_at = datetime.now(UTC)
    return response


