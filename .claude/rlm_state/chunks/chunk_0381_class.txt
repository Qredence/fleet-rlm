<!-- Chunk 381: bytes 567461-568948, type=class -->
class ConfigurableModule(dspy.Module):
    def __init__(self, max_length: int = 300, temperature: float = 0.7):
        super().__init__()
        self.max_length = max_length
        self.temperature = temperature
        self.process = dspy.Predict(
            MySignature,
            temperature=temperature
        )

    def forward(self, input_data: str):
        result = self.process(input=input_data, max_length=self.max_length)
        return dspy.Prediction(output=result.output)
```


============================================================
END FILE: .fleet/letta/skills/dspy-basics/references/programs.md
============================================================

============================================================
FILE: .fleet/letta/skills/dspy-basics/references/signatures.md
============================================================

# DSPy Signatures

DSPy signatures define the input/output contract for your programs. This guide covers signature design patterns, field usage, and best practices.

## Table of Contents

- [Basic Signature Structure](#basic-signature-structure)
- [InputField vs OutputField](#inputfield-vs-outputfield)
- [Type Hints](#type-hints)
- [Descriptions and Hints](#descriptions-and-hints)
- [Design Patterns](#design-patterns)
- [Best Practices](#best-practices)

## Basic Signature Structure

A DSPy signature is a class that inherits from `dspy.Signature` and defines input and output fields:

```python
import dspy

