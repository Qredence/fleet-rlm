<!-- Chunk 1554: bytes 6414644-6416369, type=function -->
def load_job_session(job_id: str) -> JobState | None:
    """
    Load job state from disk.

    Args:
        job_id: The job ID to load

    Returns:
        JobState if found, None otherwise

    """
    if not _is_safe_job_id(job_id):
        logger.warning("Cannot load session: unsafe job id %s", _sanitize_for_log(job_id))
        return None

    try:
        session_file = resolve_path_within_root(SESSION_DIR, f"{job_id}.json")
        if not session_file.exists():
            return None

        session_data = json.loads(session_file.read_text(encoding="utf-8"))

        # Reconstruct JobState from saved data
        # Need to handle nested models properly
        tdd_data = session_data.pop("tdd_workflow", {})
        deep_data = session_data.pop("deep_understanding", {})

        job = JobState(**session_data)

        # Restore nested models
        if tdd_data:
            job.tdd_workflow = TDDWorkflowState(**tdd_data)
        if deep_data:
            job.deep_understanding = DeepUnderstandingState(**deep_data)

        # Reinitialize hitl_event and hitl_lock (not serialized)
        job.hitl_event = asyncio.Event()
        job.hitl_lock = asyncio.Lock()

        JOBS[job_id] = job
        logger.info("Loaded session for job %s", _sanitize_for_log(job_id))
        return job

    except ValueError as e:
        logger.warning(
            "Cannot load session for job %s: %s",
            _sanitize_for_log(job_id),
            _sanitize_for_log(e),
        )
        return None

    except Exception as e:
        logger.error(
            "Failed to load session for job %s: %s",
            _sanitize_for_log(job_id),
            _sanitize_for_log(e),
        )
        return None


