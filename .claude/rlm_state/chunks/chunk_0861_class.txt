<!-- Chunk 861: bytes 3057788-3061029, type=class -->
class MyService(BaseService):
    def __init__(
        self,
        skill_repository: SkillRepository = None,
        custom_dependency: CustomService = None,
    ):
        super().__init__(skill_repository=skill_repository)
        self.custom = custom_dependency or CustomService()
```

### Using in API Routes

```python
from fastapi import Depends
from skill_fleet.api.dependencies import get_analytics_service

@router.get("/analytics/{skill_id}")
async def get_analytics(
    skill_id: str,
    analytics: AnalyticsService = Depends(get_analytics_service),
):
    """Get analytics for a skill."""
    return await analytics.get_skill_usage_stats(skill_id)
```

### Creating Dependency Providers

```python
# src/skill_fleet/api/dependencies.py
from fastapi import Depends
from skill_fleet.services import AnalyticsService

async def get_analytics_service() -> AnalyticsService:
    """Provide analytics service instance."""
    return AnalyticsService()

# Or with singleton pattern
_analytics_service: AnalyticsService | None = None

async def get_analytics_service_singleton() -> AnalyticsService:
    """Provide singleton analytics service."""
    global _analytics_service
    if _analytics_service is None:
        _analytics_service = AnalyticsService()
    return _analytics_service
```

---

## Testing Services

### Unit Testing with Mocks

```python
import pytest
from unittest.mock import Mock
from skill_fleet.services import AnalyticsService
from skill_fleet.domain import Skill, SkillMetadata

@pytest.mark.asyncio
async def test_get_skill_usage_stats():
    # Arrange
    mock_repo = Mock()
    mock_repo.get.return_value = Skill(
        metadata=SkillMetadata(
            skill_id="test-skill",
            name="test",
            description="Test skill"
        ),
        content="content"
    )

    service = AnalyticsService(skill_repository=mock_repo)

    # Act
    result = await service.get_skill_usage_stats("test-skill", "7d")

    # Assert
    assert result["skill_id"] == "test-skill"
    assert "usage_count" in result
    mock_repo.get.assert_called_once_with("test-skill")
```

### Integration Testing with Fixtures

```python
@pytest.fixture
async def skill_service(test_db):
    """Provide service with test database."""
    repo = TestSkillRepository(test_db)
    service = SkillService(skill_repository=repo)
    yield service
    # Cleanup
    await repo.close()

@pytest.mark.asyncio
async def test_create_skill_integration(skill_service):
    """Test skill creation with real dependencies."""
    result = await skill_service.create_skill(
        task_description="Test skill",
        user_id="test-user"
    )

    assert result.job_id is not None
    assert result.status == JobStatus.PENDING
```

### Testing Error Handling

```python
@pytest.mark.asyncio
async def test_promote_nonexistent_skill():
    """Test promoting non-existent skill raises error."""
    mock_repo = Mock()
    mock_repo.get.return_value = None

    service = SkillService(skill_repository=mock_repo)

    with pytest.raises(ValidationError, match="not found"):
        await service.promote_skill("nonexistent")
```

---

## Best Practices

### 1. Keep Services Thin

```python
# âœ… Good: Service orchestrates
