<!-- Chunk 1352: bytes 5048276-5049516, type=class -->
class UserUpdate(BaseModel):
    name: Optional[str] = None
    email: Optional[str] = None
    age: Optional[int] = None

@app.patch("/users/{user_id}")
async def update_user(
    user_id: int,
    update: UserUpdate,
    db: AsyncSession = Depends(get_db)
):
    user = await db.get(User, user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    # CRITICAL: Only update provided fields
    update_data = update.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(user, field, value)

    await db.commit()
    await db.refresh(user)
    return user
```

**Key insight:** `exclude_unset=True` only includes fields actually provided in the request, preventing `None` overwrites.

### 3. Converting Python Functions to Endpoints

**The problem:** Existing Python code needs API exposure. Common mistakes: blocking operations, missing validation, no error handling, wrong return types.

**Transformation steps:**
1. Add Pydantic models for request/response
2. Make functions async if they do I/O
3. Replace exceptions with `HTTPException`
4. Add `response_model` for validation
5. Use `Depends` for shared resources

**Before - Blocking utility:**
```python
