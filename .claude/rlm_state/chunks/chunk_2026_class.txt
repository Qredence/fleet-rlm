<!-- Chunk 2026: bytes 7914539-7917884, type=class -->
class TestSecurityEdgeCases:
    """Tests for edge cases and attack vectors."""

    def test_unicode_normalization_attack(self, tmp_path: Path):
        """Test that Unicode normalization doesn't allow escapes."""
        root = tmp_path / "root"
        root.mkdir()

        # Try various Unicode representations that might normalize to ..
        # Most should be rejected by the character validation
        with pytest.raises(ValueError):
            resolve_path_within_root(root, "path/\u2024\u2024/escape")

    def test_null_byte_injection(self, tmp_path: Path):
        """Test that null byte injection is prevented."""
        root = tmp_path / "root"
        root.mkdir()

        with pytest.raises(ValueError):
            resolve_path_within_root(root, "safe\x00../../../etc/passwd")

    def test_mixed_separators(self, tmp_path: Path):
        """Test that mixed separators don't bypass validation."""
        root = tmp_path / "root"
        root.mkdir()

        with pytest.raises(ValueError):
            resolve_path_within_root(root, "path\\..\\escape")

    def test_url_encoding_attack(self, tmp_path: Path):
        """Test that URL-encoded traversal is rejected."""
        root = tmp_path / "root"
        root.mkdir()

        # %2e%2e should not work
        with pytest.raises(ValueError):
            resolve_path_within_root(root, "%2e%2e/escape")

    def test_very_long_path(self, tmp_path: Path):
        """Test that very long paths are handled safely."""
        root = tmp_path / "root"
        root.mkdir()

        # Create a very long but valid path
        long_segment = "a" * 255  # Max filename length on most systems
        # This should work or raise an OS error, not a security error
        try:
            result = resolve_path_within_root(root, long_segment)
            # If it succeeds, verify it's still within root
            assert result.parent == root.resolve()
        except ValueError:
            # Acceptable if validation rejects it
            pass
        except OSError:
            # Acceptable if OS rejects it
            pass


============================================================
END FILE: tests/common/test_security.py
============================================================

============================================================
FILE: tests/conftest.py
============================================================

"""Global pytest configuration and fixtures."""

from __future__ import annotations

import os
from typing import TYPE_CHECKING
from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from fastapi.testclient import TestClient

# Set development environment for all tests to allow wildcard CORS,
# SQLite database fallback, and other development-friendly defaults.
# This must happen before any imports that use settings
os.environ["SKILL_FLEET_ENV"] = "development"
os.environ["SKILL_FLEET_CORS_ORIGINS"] = "*"

# Use in-memory SQLite for tests unless DATABASE_URL is explicitly set
if "DATABASE_URL" not in os.environ:
    os.environ["DATABASE_URL"] = "sqlite:///./test_skill_fleet.db"

if TYPE_CHECKING:
    pass


# =============================================================================
# FastAPI App Fixtures
# =============================================================================


@pytest.fixture
