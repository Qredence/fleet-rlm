<!-- Chunk 768: bytes 2626927-2632153, type=class -->
class JobState(BaseModel):
    """Represents the current state of a background job."""

    job_id: str
    status: str = "pending"
    hitl_type: str | None = None      # Type of HITL interaction
    hitl_data: dict[str, Any] | None = None  # HITL prompt data
    hitl_response: dict[str, Any] | None = None  # User's response
    result: Any | None = None          # Final result
    error: str | None = None           # Error message if failed
    saved_path: str | None = None      # Where skill was saved
```

---

## Job Creation

### Creating a Job

```python
from skill_fleet.api.services.jobs import create_job

job_id = create_job()
# Returns: "f47ac10b-58cc-4372-a567-0e02b2c3d479"
```

**Job Storage:**
- Current: In-memory dictionary (`JOBS = {}`)
- Production: Use Redis or database

### From API Endpoint

```http
POST /api/v2/skills/create
Content-Type: application/json

{
    "task_description": "Create a Python async skill",
    "user_id": "user_123"
}
```

**Response:**
```json
{
    "job_id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "status": "accepted"
}
```

---

## Job Execution

### Background Task

```python
async def run_skill_creation(job_id: str, task_description: str, user_id: str):
    """Background task to run the skill creation program."""
    job = JOBS[job_id]
    job.status = "running"

    async def hitl_callback(interaction_type: str, data: dict):
        """Handle Human-in-the-Loop interactions."""
        job.status = "pending_hitl"
        job.hitl_type = interaction_type
        job.hitl_data = data

        # Wait for user response via API
        try:
            response = await wait_for_hitl_response(job_id)
            job.status = "running"
            return response
        except TimeoutError:
            job.status = "failed"
            job.error = "HITL interaction timed out"
            raise

    try:
        program = SkillCreationProgram()
        result = await program.aforward(
            task_description=task_description,
            user_context={"user_id": user_id},
            taxonomy_structure="{}",
            existing_skills="[]",
            hitl_callback=hitl_callback,
        )

        job.status = result.status  # completed/failed
        job.result = result

        # Auto-save to taxonomy
        if result.status == "completed":
            saved_path = save_skill_to_taxonomy(result)
            job.saved_path = saved_path

    except Exception as e:
        job.status = "failed"
        job.error = str(e)
```

---

## HITL Interactions

### HITL Flow

```mermaid
sequenceDiagram
    participant API as FastAPI
    participant Job as Background Job
    participant User as User Client

    API->>Job: Start skill creation
    Job->>Job: Run Phase 1
    Job->>API: Set status=pending_hitl
    User->>API: GET /hitl/{job_id}/prompt
    API-->>User: Return HITL prompt
    User->>API: POST /hitl/{job_id}/response
    API->>Job: Resume with response
    Job->>Job: Continue workflow
```

### Waiting for Response

```python
async def wait_for_hitl_response(job_id: str, timeout: float = 3600.0) -> dict[str, Any]:
    """Wait for user to provide HITL response via API."""
    job = JOBS[job_id]
    start_time = asyncio.get_event_loop().time()

    while job.hitl_response is None:
        if asyncio.get_event_loop().time() - start_time > timeout:
            raise TimeoutError("HITL response timed out")
        await asyncio.sleep(1)

    response = job.hitl_response
    job.hitl_response = None  # Clear for next interaction
    return response
```

`★ Insight ─────────────────────────────────────`
The timeout defaults to 1 hour (3600 seconds) which is generous for HITL interactions. This allows users time to review generated content and provide thoughtful feedback. Adjust based on your use case.
`─────────────────────────────────────────────────`

---

## Job Polling

### Client-Side Polling

```python
import requests
import time

JOB_ID = "f47ac10b-58cc-4372-a567-0e02b2c3d479"
BASE_URL = "http://localhost:8000/api/v2"

while True:
    response = requests.get(f"{BASE_URL}/hitl/{JOB_ID}/prompt")
    data = response.json()
    status = data["status"]

    if status == "pending_hitl":
        # Show HITL prompt to user
        handle_hitl_prompt(data)

    elif status == "completed":
        skill_content = data["skill_content"]
        print("Skill created!")
        print(skill_content)
        break

    elif status == "failed":
        print(f"Job failed: {data['error']}")
        break

    time.sleep(2)
```

### Webhook Alternative (Future)

```python
# When creating skill, provide webhook URL
{
    "task_description": "...",
    "webhook_url": "https://your-app.com/webhooks/skill-complete",
    "webhook_secret": "your-secret"
}

# Server POSTs to webhook when job completes
{
    "job_id": "...",
    "status": "completed",
    "result": {...},
    "signature": "hmac-sha256"
}
```

---

## Job Storage

### Current Implementation

In-memory dictionary (not suitable for production):

```python
# src/skill_fleet/api/jobs.py

JOBS: dict[str, JobState] = {}
```

### Production: Redis

```python
import redis
import json

redis_client = redis.Redis(host='localhost', port=6379, db=0)

