<!-- Chunk 1167: bytes 4426086-4437178, type=class -->
class SkillBootstrapper:
    """Bootstrap user-specific skill sets based on onboarding."""
    
    def __init__(
        self,
        taxonomy_manager: TaxonomyManager,
        skill_creator: TaxonomySkillCreator,
        profiles_path: Path
    ):
        self.taxonomy = taxonomy_manager
        self.creator = skill_creator
        self.profiles = self._load_profiles(profiles_path)
    
    def _load_profiles(self, profiles_path: Path) -> Dict:
        """Load bootstrap profiles configuration."""
        with open(profiles_path, 'r') as f:
            return json.load(f)
    
    async def onboard_user(
        self,
        user_id: str,
        responses: Dict
    ) -> Dict:
        """Onboard a new user and bootstrap their skills.
        
        Args:
            user_id: Unique user identifier
            responses: User's onboarding questionnaire responses
        
        Returns:
            Dict with user profile and mounted skills
        """
        print(f"ðŸŽ¯ Onboarding user: {user_id}")
        
        # Analyze responses to determine profile
        profile = self.analyze_responses(responses)
        print(f"ðŸ“Š Profile identified: {profile['primaryRole']}")
        
        # Generate skill plan
        skill_plan = self.generate_skill_plan(profile)
        print(f"ðŸ“‹ Skill plan: {len(skill_plan['required'])} required, "
              f"{len(skill_plan['onDemand'])} on-demand")
        
        # Generate required skills
        mounted_skills = []
        for skill_path in skill_plan['required']:
            # Check if skill exists
            if not self.taxonomy.skill_exists(skill_path):
                print(f"ðŸ”¨ Generating skill: {skill_path}")
                result = await self._generate_skill_for_path(
                    skill_path,
                    user_id
                )
                if result['status'] == 'approved':
                    mounted_skills.append(result['skill_id'])
            else:
                # Load existing skill
                skill_id = self._path_to_skill_id(skill_path)
                mounted_skills.append(skill_id)
                print(f"âœ“ Loaded existing skill: {skill_id}")
        
        # Register on-demand skills
        self.register_on_demand_skills(user_id, skill_plan['onDemand'])
        
        # Create user profile
        user_profile = {
            "user_id": user_id,
            "profile": profile,
            "mounted_skills": mounted_skills,
            "on_demand_skills": skill_plan['onDemand'],
            "created_at": datetime.utcnow().isoformat(),
            "ready_for_tasks": True
        }
        
        # Persist user profile
        self._save_user_profile(user_profile)
        
        print(f"ðŸŽ‰ Onboarding complete! {len(mounted_skills)} skills mounted.")
        
        return user_profile
    
    def analyze_responses(self, responses: Dict) -> Dict:
        """Map user responses to skill requirements."""
        profile = {
            "primaryRole": responses.get('role', 'general_purpose'),
            "techStack": responses.get('tech_stack', []),
            "commonTasks": responses.get('common_tasks', []),
            "experience_level": responses.get('experience_level', 'mid-level'),
            "preferences": responses.get('preferences', {})
        }
        return profile
    
    def generate_skill_plan(self, profile: Dict) -> Dict:
        """Generate skill plan based on user profile."""
        role = profile['primaryRole']
        
        # Get base plan for role
        base_plan = self.profiles['bootstrap_profiles'].get(
            role,
            self.profiles['bootstrap_profiles']['general_purpose']
        )
        
        required = base_plan['required'].copy()
        on_demand = base_plan['on_demand'].copy()
        
        # Augment based on tech stack
        for tech in profile['techStack']:
            tech_skills = self.profiles['tech_stack_mapping'].get(tech, [])
            required.extend(tech_skills)
        
        # Augment based on common tasks
        for task in profile['commonTasks']:
            task_skills = self.profiles['task_mapping'].get(task, [])
            required.extend(task_skills)
        
        # Remove duplicates
        required = list(set(required))
        on_demand = list(set(on_demand))
        
        return {
            "required": required,
            "onDemand": on_demand
        }
    
    async def _generate_skill_for_path(
        self,
        skill_path: str,
        user_id: str
    ) -> Dict:
        """Generate a skill for a specific taxonomy path."""
        # Infer task description from path
        task_description = self._path_to_task_description(skill_path)
        
        result = self.creator.forward(
            task_description=task_description,
            user_context={"user_id": user_id},
            auto_approve=True  # Auto-approve bootstrap skills
        )
        
        return result
    
    def register_on_demand_skills(
        self,
        user_id: str,
        on_demand_paths: List[str]
    ):
        """Register skills for on-demand generation."""
        # TODO: Implement on-demand skill registry
        pass
    
    def _path_to_skill_id(self, path: str) -> str:
        """Convert taxonomy path to skill_id."""
        return path.replace('/', '.')
    
    def _path_to_task_description(self, path: str) -> str:
        """Convert taxonomy path to task description for generation."""
        parts = path.split('/')
        last_part = parts[-1].replace('_', ' ')
        category = parts[0].replace('_', ' ')
        
        return f"Create a {last_part} skill in the {category} category"
    
    def _save_user_profile(self, profile: Dict):
        """Persist user profile to storage."""
        # TODO: Implement user profile storage
        pass
```

**File: config/profiles/bootstrap_profiles.json**
```json
{
  "bootstrap_profiles": {
    "web_developer": {
      "required": [
        "technical_skills/programming/languages/javascript_typescript",
        "technical_skills/programming/paradigms/object_oriented",
        "tool_proficiency/development_tools/version_control",
        "specializations/frontend_development",
        "task_focus_areas/build_create"
      ],
      "on_demand": [
        "technical_skills/infrastructure/containerization",
        "specializations/backend_development",
        "technical_skills/apis_integration/rest_apis"
      ]
    },
    "backend_developer": {
      "required": [
        "technical_skills/programming/languages/python",
        "technical_skills/data_engineering/storage/relational_databases",
        "technical_skills/apis_integration/rest_apis",
        "specializations/backend_development",
        "task_focus_areas/build_create"
      ],
      "on_demand": [
        "technical_skills/infrastructure/cloud_platforms",
        "technical_skills/security/authentication_authorization",
        "domain_knowledge/business_intelligence"
      ]
    },
    "data_scientist": {
      "required": [
        "technical_skills/programming/languages/python",
        "domain_knowledge/machine_learning",
        "technical_skills/data_engineering/processing/etl_pipelines",
        "tool_proficiency/data_tools/visualization_tools",
        "task_focus_areas/research_explore"
      ],
      "on_demand": [
        "domain_knowledge/nlp_understanding",
        "domain_knowledge/computer_vision",
        "technical_skills/data_engineering/storage/vector_databases"
      ]
    },
    "ml_engineer": {
      "required": [
        "technical_skills/programming/languages/python",
        "domain_knowledge/machine_learning",
        "specializations/ai_ml_engineering",
        "technical_skills/infrastructure/cloud_platforms",
        "task_focus_areas/build_create"
      ],
      "on_demand": [
        "domain_knowledge/nlp_understanding",
        "technical_skills/infrastructure/containerization",
        "task_focus_areas/optimize_improve"
      ]
    },
    "devops_engineer": {
      "required": [
        "technical_skills/infrastructure/cloud_platforms",
        "technical_skills/infrastructure/containerization",
        "technical_skills/infrastructure/infrastructure_as_code",
        "specializations/devops_sre",
        "task_focus_areas/maintain_support"
      ],
      "on_demand": [
        "technical_skills/programming/languages/shell_scripting",
        "tool_proficiency/monitoring_observability",
        "technical_skills/security"
      ]
    },
    "general_purpose": {
      "required": [
        "cognitive_skills/analysis",
        "cognitive_skills/synthesis",
        "cognitive_skills/reasoning",
        "task_focus_areas/build_create"
      ],
      "on_demand": [
        "technical_skills/programming/languages/python",
        "tool_proficiency/development_tools",
        "task_focus_areas/debug_fix"
      ]
    }
  },
  "tech_stack_mapping": {
    "JavaScript/TypeScript": [
      "technical_skills/programming/languages/javascript_typescript"
    ],
    "Python": [
      "technical_skills/programming/languages/python"
    ],
    "React": [
      "specializations/frontend_development/react_ecosystem"
    ],
    "Node.js": [
      "technical_skills/programming/languages/javascript_typescript/node_runtime"
    ],
    "Docker": [
      "technical_skills/infrastructure/containerization/docker"
    ],
    "Kubernetes": [
      "technical_skills/infrastructure/containerization/kubernetes"
    ],
    "AWS": [
      "technical_skills/infrastructure/cloud_platforms/aws_services"
    ],
    "PostgreSQL": [
      "technical_skills/data_engineering/storage/relational_databases"
    ],
    "MongoDB": [
      "technical_skills/data_engineering/storage/nosql_databases"
    ]
  },
  "task_mapping": {
    "Building new features": [
      "task_focus_areas/build_create"
    ],
    "Debugging issues": [
      "task_focus_areas/debug_fix"
    ],
    "Performance optimization": [
      "task_focus_areas/optimize_improve"
    ],
    "Code review": [
      "cognitive_skills/analysis/code_analysis"
    ],
    "Writing tests": [
      "technical_skills/programming/practices/testing"
    ],
    "Documentation": [
      "cognitive_skills/synthesis/content_generation/documentation"
    ],
    "Data analysis": [
      "cognitive_skills/analysis/data_analysis"
    ],
    "API design": [
      "cognitive_skills/synthesis/design_synthesis/api_design"
    ]
  }
}
```

### Day 32-35: Onboarding UI/CLI

**File: src/cli/onboarding_cli.py**
```python
"""Interactive onboarding CLI."""
import click
from rich.console import Console
from rich.prompt import Prompt, Confirm
from rich.progress import Progress
import asyncio

from ..onboarding.bootstrap import SkillBootstrapper
from ..taxonomy.manager import TaxonomyManager
from ..workflow.skill_creator import TaxonomySkillCreator

console = Console()


@click.command()
@click.option('--user-id', prompt='Enter your user ID', help='Unique user identifier')
@click.option('--skills-root', default='./skills', help='Path to skills directory')
