<!-- Chunk 1697: bytes 7172516-7233214, type=size -->
ation Checklist:",
          "description": "List of validation checks to perform"
        }
      ]
    },
    "lm": null
  },
  "edit.edit.predict": {
    "traces": [],
    "train": [],
    "demos": [
      {
        "augmented": true,
        "skill_skeleton": "{\n  \"root_path\": \"technical_skills/web_development/frontend/react/hooks\",\n  \"files\": [\n    {\n      \"path\": \"metadata.json\",\n      \"content_type\": \"json\",\n      \"description\": \"Skill metadata including capabilities and versioning.\"\n    },\n    {\n      \"path\": \"SKILL.md\",\n      \"content_type\": \"markdown\",\n      \"description\": \"Main documentation for React Hooks management.\"\n    },\n    {\n      \"path\": \"capabilities/state_management.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Logic for useState and useReducer implementations.\"\n    },\n    {\n      \"path\": \"capabilities/effect_synchronization.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Logic for useEffect and useLayoutEffect synchronization.\"\n    },\n    {\n      \"path\": \"capabilities/context_consumption.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Context API integration logic.\"\n    },\n    {\n      \"path\": \"capabilities/custom_hook_abstraction.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Framework for composing reusable custom hooks.\"\n    },\n    {\n      \"path\": \"capabilities/performance_optimization.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Implementation of useMemo and useCallback patterns.\"\n    },\n    {\n      \"path\": \"examples/use-fetch-example.md\",\n      \"content_type\": \"markdown\",\n      \"description\": \"Example of a custom hook for API data fetching.\"\n    },\n    {\n      \"path\": \"examples/auth-context-example.md\",\n      \"content_type\": \"markdown\",\n      \"description\": \"Example of global state management using useContext.\"\n    },\n    {\n      \"path\": \"tests/test_hooks_logic.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Unit tests for hook state transitions and side effects.\"\n    },\n    {\n      \"path\": \"references/rules-of-hooks.md\",\n      \"content_type\": \"markdown\",\n      \"description\": \"Documentation on React's fundamental constraints for hooks.\"\n    },\n    {\n      \"path\": \"references/common-patterns.md\",\n      \"content_type\": \"markdown\",\n      \"description\": \"Reference for common hook patterns (e.g., Debouncing, Throttling).\"\n    }\n  ],\n  \"directories\": [\n    \"capabilities\",\n    \"examples\",\n    \"tests\",\n    \"resources\",\n    \"references\",\n    \"scripts\",\n    \"assets\"\n  ]\n}",
        "parent_skills": "[\n  {\n    \"skill_id\": \"technical_skills/web_development/frontend/react\",\n    \"name\": \"react-fundamentals\",\n    \"relationship\": \"parent\"\n  },\n  {\n    \"skill_id\": \"technical_skills/web_development/languages/javascript\",\n    \"name\": \"javascript-es6\",\n    \"relationship\": \"dependency\"\n  }\n]",
        "composition_strategy": "This skill acts as the logic engine for React-based frontend development. It composes with `react/fundamentals` by providing the behavioral layer to the structural JSX defined there. It is typically a prerequisite for higher-level state management skills (like Redux or TanStack Query), as those libraries often expose their functionality through hooks.\n\nWhen used in an agentic workflow, this skill should be invoked after the UI structure is defined but before the final styling or testing phases. It integrates with testing skills (like Vitest or React Testing Library) by providing the hooks that need unit testing via specialized utilities like `renderHook`.",
        "revision_feedback": "",
        "reasoning": "The React Hooks skill is designed as a modular behavioral layer for React development. It provides the bridge between static UI and dynamic state. The content follows the provided skeleton, focusing on the five core capabilities: state management, effect synchronization, context consumption, custom hook abstraction, and performance optimization. It leverages the parent 'react-fundamentals' skill by assuming knowledge of components and JSX, while establishing a foundation for advanced libraries. The documentation emphasizes the \"Rules of Hooks\" to ensure architectural integrity.",
        "skill_content": "# React Hooks Management\n\n## Overview\nReact Hooks are the fundamental building blocks for state and lifecycle management in modern functional React components. This skill provides the architectural patterns and implementation logic for managing local state, handling side effects, consuming global context, and optimizing component performance. By abstracting logic into reusable hooks, developers can create highly composable and testable frontend applications.\n\n## Capabilities\n- **State Management**: Implementing local component state using `useState` and complex state logic using `useReducer`.\n- **Effect Synchronization**: Managing side effects, API calls, and manual DOM manipulations using `useEffect` and `useLayoutEffect`.\n- **Context Consumption**: Accessing global application state and dependency injection via `useContext`.\n- **Custom Hook Abstraction**: Encapsulating complex logic into reusable, shareable functions to maintain DRY (Don't Repeat Yourself) principles.\n- **Performance Optimization**: Reducing unnecessary re-renders and expensive computations using `useMemo` and `useCallback`.\n\n## Dependencies\n- `technical_skills/web_development/frontend/react`: Core component lifecycle and JSX syntax.\n- `technical_skills/web_development/languages/javascript`: ES6+ features (destructuring, arrow functions, async/await).\n\n## Usage Examples\n\n### Custom Fetch Hook\nA reusable pattern for handling asynchronous data fetching with loading and error states.\n```javascript\nimport { useState, useEffect } from 'react';\n\nfunction useFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        const response = await fetch(url);\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n    fetchData();\n  }, [url]);\n\n  return { data, loading, error };\n}\n```\n\n### Performance Optimization with useCallback\nPreventing child component re-renders by memoizing callback functions.\n```javascript\nimport React, { useState, useCallback } from 'react';\n\nconst Parent = () => {\n  const [count, setCount] = useState(0);\n  \n  // Memoized function to prevent Child re-renders\n  const increment = useCallback(() => {\n    setCount(c => c + 1);\n  }, []);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <Child onIncrement={increment} />\n    </div>\n  );\n};\n```",
        "capability_implementations": [
          {
            "name": "State Management",
            "content": "Logic for managing component-level state. Use `useState` for simple primitives and `useReducer` for complex state objects or when the next state depends on the previous one. \n\n**Key Patterns:**\n- Functional updates: `setCount(prev => prev + 1)`\n- Reducer pattern: `(state, action) => newState`"
          },
          {
            "name": "Effect Synchronization",
            "content": "Handles side effects that interact with systems outside of React (APIs, Subscriptions, Timers). \n\n**Key Patterns:**\n- Dependency arrays: Control when effects run.\n- Cleanup functions: `return () => clearInterval(id)` to prevent memory leaks.\n- `useLayoutEffect`: For DOM measurements before the paint."
          },
          {
            "name": "Context Consumption",
            "content": "Provides a way to pass data through the component tree without having to pass props down manually at every level. \n\n**Key Patterns:**\n- Provider pattern: Wrapping the tree in `<MyContext.Provider>`.\n- Custom hooks for context: `const useAuth = () => useContext(AuthContext)`."
          },
          {
            "name": "Custom Hook Abstraction",
            "content": "Extracting component logic into reusable functions. Custom hooks must start with the prefix 'use' and follow all Rules of Hooks. They allow sharing stateful logic without changing component hierarchy."
          },
          {
            "name": "Performance Optimization",
            "content": "Tools to avoid expensive re-calculations and unnecessary renders.\n\n**Key Patterns:**\n- `useMemo`: Memoize the result of a calculation.\n- `useCallback`: Memoize a function definition.\n- Referential stability: Ensuring objects/functions passed as props don't trigger re-renders."
          }
        ],
        "usage_examples": [
          {
            "title": "Counter with useReducer",
            "description": "Managing complex state transitions for a counter using the Reducer pattern.",
            "code": "import React, { useReducer } from 'react';\n\nconst initialState = { count: 0 };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment': return { count: state.count + 1 };\n    case 'decrement': return { count: state.count - 1 };\n    default: throw new Error();\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    <>\n      Count: {state.count}\n      <button onClick={() => dispatch({type: 'decrement'})}>-</button>\n      <button onClick={() => dispatch({type: 'increment'})}>+</button>\n    </>\n  );\n}",
            "expected_output": "A UI displaying the current count with buttons that dispatch actions to modify the state.",
            "language": "python"
          },
          {
            "title": "Window Resize Listener with useEffect",
            "description": "Using useEffect to manage a browser event listener with proper cleanup.",
            "code": "import { useState, useEffect } from 'react';\n\nfunction useWindowWidth() {\n  const [width, setWidth] = useState(window.innerWidth);\n\n  useEffect(() => {\n    const handleResize = () => setWidth(window.innerWidth);\n    window.addEventListener('resize', handleResize);\n    \n    // Cleanup function\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return width;\n}",
            "expected_output": "Returns the current window width and updates dynamically on browser resize.",
            "language": "python"
          }
        ],
        "best_practices": [
          {
            "title": "Adhere to the Rules of Hooks",
            "description": "Only call hooks at the top level. Don't call hooks inside loops, conditions, or nested functions. Only call hooks from React function components or custom hooks.",
            "example": "// BAD\nif (condition) { useEffect(...) }\n\n// GOOD\nuseEffect(() => { if (condition) { ... } }, [condition])"
          },
          {
            "title": "Exhaustive Dependencies",
            "description": "Always include every value from the component scope that is used inside an effect or memoized hook in the dependency array.",
            "example": "useEffect(() => {\n  console.log(name);\n}, [name]); // Include 'name' here"
          },
          {
            "title": "Prefer useReducer for Complex State",
            "description": "When state transitions are complex or involve multiple sub-values, useReducer is preferred over multiple useState calls to keep logic centralized and predictable.",
            "example": ""
          },
          {
            "title": "Keep Hooks Small and Focused",
            "description": "Just like functions, custom hooks should do one thing well. Compose multiple custom hooks if you need to perform multiple distinct tasks (e.g., useAuth + useSubscription).",
            "example": ""
          }
        ],
        "integration_guide": "This skill serves as the behavioral engine for React applications. It integrates directly with the `react-fundamentals` skill by injecting logic into the functional components defined there. When architecting an application, this skill should be used to build a \"headless\" logic layer before UI components are finalized.\n\nIn a larger ecosystem, this skill provides the primitives necessary for third-party libraries. For example, when integrating with `TanStack Query`, developers will use the `Custom Hook Abstraction` capability to wrap query logic. When testing, these hooks should be isolated and tested using `renderHook` from `@testing-library/react-hooks` to ensure state transitions and side effects occur as expected without requiring full DOM rendering."
      },
      {
        "augmented": true,
        "skill_skeleton": "{\n  \"root_path\": \"technical_skills/cloud_infrastructure/container_orchestration/kubernetes_management\",\n  \"files\": [\n    {\n      \"path\": \"metadata.json\",\n      \"content_type\": \"json\",\n      \"description\": \"Skill metadata including capabilities and dependencies.\"\n    },\n    {\n      \"path\": \"SKILL.md\",\n      \"content_type\": \"markdown\",\n      \"description\": \"Main skill documentation and overview.\"\n    },\n    {\n      \"path\": \"capabilities/apply_manifests.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Logic for applying and deleting declarative YAML manifests.\"\n    },\n    {\n      \"path\": \"capabilities/manage_workloads.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Logic for scaling, updating, and monitoring Pods/Deployments.\"\n    },\n    {\n      \"path\": \"capabilities/configure_networking.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Logic for Service and Ingress configuration.\"\n    },\n    {\n      \"path\": \"capabilities/secret_management.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Logic for ConfigMap and Secret injection.\"\n    },\n    {\n      \"path\": \"capabilities/cluster_observability.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Logic for logs, describes, and event inspection.\"\n    },\n    {\n      \"path\": \"references/api-reference.md\",\n      \"content_type\": \"markdown\",\n      \"description\": \"Kubernetes API versioning and resource kind reference.\"\n    },\n    {\n      \"path\": \"references/troubleshooting.md\",\n      \"content_type\": \"markdown\",\n      \"description\": \"Common failure modes (CrashLoopBackOff, ImagePullBackOff, etc.).\"\n    },\n    {\n      \"path\": \"examples/deployment.yaml\",\n      \"content_type\": \"yaml\",\n      \"description\": \"Standard deployment manifest example.\"\n    },\n    {\n      \"path\": \"examples/service.yaml\",\n      \"content_type\": \"yaml\",\n      \"description\": \"ClusterIP and LoadBalancer service examples.\"\n    },\n    {\n      \"path\": \"tests/test_workload_lifecycle.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Integration tests for scaling and rollouts.\"\n    },\n    {\n      \"path\": \"resources/standard-labels.json\",\n      \"content_type\": \"json\",\n      \"description\": \"Recommended labeling schema for Kubernetes resources.\"\n    }\n  ],\n  \"directories\": [\n    \"capabilities\",\n    \"examples\",\n    \"tests\",\n    \"resources\",\n    \"references\",\n    \"scripts\",\n    \"assets\"\n  ]\n}",
        "parent_skills": "[\n  {\n    \"skill_id\": \"technical_skills/cloud_infrastructure/container_orchestration\",\n    \"name\": \"container-orchestration\",\n    \"relationship\": \"parent\"\n  }\n]",
        "composition_strategy": "This skill acts as the execution engine for container orchestration. It consumes outputs from 'docker' skills (container images) and 'yaml' skills (manifest strings) to effect change in a cluster. It is designed to be a downstream dependency for higher-level automation skills like 'helm_package_management' or 'ci_cd_pipelines'.\n\nWhen composing, the agent should first use YAML-related skills to validate or template the manifest, then invoke this skill's 'apply_manifests' capability. For troubleshooting, this skill provides the 'cluster_observability' capability which should be used in a feedback loop with 'log_analysis' or 'debugging' skills.",
        "revision_feedback": "",
        "reasoning": "The Kubernetes Management skill is designed as a core execution layer within the container orchestration hierarchy. It translates declarative intent (YAML) into cluster state. The structure reflects the standard operational lifecycle: deployment (Apply Manifests), lifecycle management (Workloads), connectivity (Networking), security (Secrets), and debugging (Observability). It follows a composition strategy where it consumes artifacts from Docker and YAML skills and provides the foundation for higher-level tools like Helm. The documentation focuses on the `kubernetes` Python client and `kubectl` patterns to ensure versatility across automation scripts and manual troubleshooting.",
        "skill_content": "# Kubernetes Management\n\n## Overview\nThe Kubernetes Management skill provides a robust interface for interacting with Kubernetes clusters. It enables the lifecycle management of containerized applications, including deployment, scaling, networking configuration, and observability. This skill serves as the bridge between static configuration files and a running distributed system, allowing for automated infrastructure-as-code (IaC) workflows.\n\n## Capabilities\n- **Apply Manifests**: Declaratively create, update, or delete resources using YAML or JSON manifests.\n- **Manage Workloads**: Handle the lifecycle of Deployments, StatefulSets, and Pods, including scaling and rolling updates.\n- **Configure Networking**: Manage internal and external traffic via Services (ClusterIP, NodePort, LoadBalancer) and Ingress resources.\n- **Secret Management**: Securely inject sensitive data and configuration parameters using Secrets and ConfigMaps.\n- **Cluster Observability**: Inspect cluster health through logs, resource descriptions, and event streams to diagnose issues.\n\n## Dependencies\n- `technical_skills/cloud_infrastructure/container_orchestration` (Parent Context)\n- `kubernetes` (Python library)\n- `kubectl` (CLI tool)\n- `PyYAML` (For manifest parsing)\n\n## Usage Examples\n\n### Applying a Deployment\n```python\nfrom kubernetes import client, config, utils\n\ndef deploy_app(manifest_path):\n    config.load_kube_config()\n    k8s_client = client.ApiClient()\n    utils.create_from_yaml(k8s_client, manifest_path, verbose=True)\n    print(\"Deployment applied successfully.\")\n```\n\n### Scaling a Deployment\n```python\nfrom kubernetes import client, config\n\ndef scale_deployment(name, namespace, replicas):\n    config.load_kube_config()\n    apps_v1 = client.AppsV1Api()\n    body = {\"spec\": {\"replicas\": replicas}}\n    apps_v1.patch_namespaced_deployment_scale(name, namespace, body)\n    print(f\"Scaled {name} to {replicas} replicas.\")\n```",
        "capability_implementations": [
          {
            "name": "apply_manifests",
            "content": "Uses the `kubernetes.utils.create_from_yaml` or `patch` methods to synchronize local YAML files with the cluster state. Supports multi-document YAML files and handles resource creation or updates (server-side apply logic)."
          },
          {
            "name": "manage_workloads",
            "content": "Provides methods to interact with the `AppsV1Api`. Includes functions for `patch_namespaced_deployment` to trigger rolling restarts (by updating annotations) and `read_namespaced_deployment_status` to monitor rollout progress."
          },
          {
            "name": "configure_networking",
            "content": "Manages `CoreV1Api` for Services and `NetworkingV1Api` for Ingress. Facilitates the mapping of container ports to cluster-wide endpoints and configures host-based routing rules."
          },
          {
            "name": "secret_management",
            "content": "Handles the creation and injection of `V1Secret` and `V1ConfigMap` objects. Includes logic for base64 encoding sensitive data and mounting these resources as volumes or environment variables in Pod specs."
          },
          {
            "name": "cluster_observability",
            "content": "Implements log streaming via `read_namespaced_pod_log` and event monitoring. Provides detailed diagnostic data by wrapping `kubectl describe` equivalent API calls to identify reasons for failures like `CrashLoopBackOff`."
          }
        ],
        "usage_examples": [
          {
            "title": "Check Pod Status",
            "description": "Retrieve and print the status of all pods in a specific namespace.",
            "code": "from kubernetes import client, config\n\nconfig.load_kube_config()\nv1 = client.CoreV1Api()\nprint('Listing pods with their IPs:')\nret = v1.list_namespaced_pod(namespace='default')\nfor i in ret.items:\n    print(f'{i.status.pod_ip} - {i.metadata.name} ({i.status.phase})')",
            "expected_output": "Listing pods with their IPs:\n10.244.0.15 - nginx-deployment-6b474476c4-abc12 (Running)",
            "language": "python"
          },
          {
            "title": "Fetch Container Logs",
            "description": "Stream logs from a specific container within a pod for troubleshooting.",
            "code": "from kubernetes import client, config\n\nconfig.load_kube_config()\nv1 = client.CoreV1Api()\npod_name = 'web-server-pod'\nnamespace = 'default'\n\ntry:\n    api_response = v1.read_namespaced_pod_log(name=pod_name, namespace=namespace)\n    print(api_response)\nexcept Exception as e:\n    print(f'Error: {e}')",
            "expected_output": "[2023-10-27 10:00:01] INFO: Starting server on port 80\n[2023-10-27 10:00:05] GET /index.html 200",
            "language": "python"
          }
        ],
        "best_practices": [
          {
            "title": "Use Namespaces for Isolation",
            "description": "Always specify a namespace for resources to avoid cluttering the 'default' namespace and to enable better resource quota management and security boundaries.",
            "example": "metadata:\n  name: my-app\n  namespace: production"
          },
          {
            "title": "Define Resource Requests and Limits",
            "description": "Always set CPU and Memory requests/limits for containers to ensure the scheduler can place pods effectively and prevent individual pods from exhausting node resources.",
            "example": "resources:\n  requests:\n    memory: '64Mi'\n    cpu: '250m'\n  limits:\n    memory: '128Mi'\n    cpu: '500m'"
          },
          {
            "title": "Implement Liveness and Readiness Probes",
            "description": "Use probes to allow Kubernetes to automatically restart unhealthy containers and ensure traffic is only sent to pods that are ready to handle it.",
            "example": "readinessProbe:\n  httpGet:\n    path: /healthz\n    port: 8080"
          },
          {
            "title": "Prefer Declarative Management",
            "description": "Use YAML manifests and 'apply' logic rather than imperative 'run' or 'edit' commands to maintain a clear audit trail and compatibility with GitOps workflows.",
            "example": "kubectl apply -f deployment.yaml"
          }
        ],
        "integration_guide": "This skill is designed to be the execution component of a larger DevOps pipeline. It integrates seamlessly with `yaml_processing` skills to validate and transform templates (e.g., replacing placeholders in a `deployment.yaml`) before applying them to the cluster. When a deployment fails, the `cluster_observability` capability should be invoked to feed error logs back into a `troubleshooting_agent` skill for automated remediation.\n\nFor advanced orchestration, this skill serves as the foundational layer for `helm_package_management`. While this skill manages raw resources, Helm handles versioned releases of those resources. In CI/CD contexts, this skill is triggered after a `docker_build` skill successfully pushes a new image to a registry, updating the deployment manifest with the new image tag."
      },
      {
        "augmented": true,
        "skill_skeleton": "{\n  \"root_path\": \"technical_skills/devops/infrastructure_as_code/terraform\",\n  \"files\": [\n    {\n      \"path\": \"metadata.json\",\n      \"content_type\": \"json\",\n      \"description\": \"Skill metadata including versioning and capability definitions.\"\n    },\n    {\n      \"path\": \"SKILL.md\",\n      \"content_type\": \"markdown\",\n      \"description\": \"Main documentation for the Terraform management skill.\"\n    },\n    {\n      \"path\": \"capabilities/state_management.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Implementation of state backend configuration and migration logic.\"\n    },\n    {\n      \"path\": \"capabilities/resource_provisioning.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Core logic for init, plan, apply, and destroy operations.\"\n    },\n    {\n      \"path\": \"capabilities/module_development.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Tools for scaffolding and validating Terraform modules.\"\n    },\n    {\n      \"path\": \"capabilities/provider_configuration.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Logic for multi-provider setup and authentication checks.\"\n    },\n    {\n      \"path\": \"capabilities/refactoring.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Handlers for terraform state mv and refactoring workflows.\"\n    },\n    {\n      \"path\": \"references/hcl-patterns.md\",\n      \"content_type\": \"markdown\",\n      \"description\": \"Reference guide for HCL syntax and common resource patterns.\"\n    },\n    {\n      \"path\": \"examples/basic-ec2-module.tf\",\n      \"content_type\": \"text\",\n      \"description\": \"Example HCL for a basic AWS EC2 module.\"\n    },\n    {\n      \"path\": \"tests/test_state_migration.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Integration tests for migrating state from local to remote backends.\"\n    }\n  ],\n  \"directories\": [\n    \"capabilities\",\n    \"examples\",\n    \"tests\",\n    \"resources\",\n    \"references\",\n    \"scripts\",\n    \"assets\"\n  ]\n}",
        "parent_skills": "[\n  {\n    \"skill_id\": \"technical_skills/devops/infrastructure_as_code\",\n    \"name\": \"infrastructure-as-code\",\n    \"relationship\": \"parent\"\n  },\n  {\n    \"skill_id\": \"technical_skills/cloud_computing\",\n    \"name\": \"cloud-computing\",\n    \"relationship\": \"dependency\"\n  }\n]",
        "composition_strategy": "This skill acts as an orchestrator within a DevOps pipeline. It consumes cloud architecture designs (from `technical_skills/cloud_computing`) and converts them into executable code. It is designed to be used in conjunction with version control skills to ensure that infrastructure changes are audited and peer-reviewed.\n\nIn a complex workflow, this skill handles the 'Provisioning' phase, which typically follows 'Design' and precedes 'Configuration Management' (e.g., Ansible) or 'Application Deployment'. It provides the necessary outputs (IP addresses, DNS names, ARN/IDs) that downstream skills require to perform software installation or service configuration.",
        "revision_feedback": "",
        "reasoning": "The Terraform management skill is designed as a core component of the Infrastructure as Code (IaC) hierarchy. It focuses on the full lifecycle of infrastructure—from initial scaffolding and provider setup to state management and complex refactoring. The structure emphasizes modularity (through module development) and reliability (through state management). This skill bridges the gap between high-level cloud architecture and operational reality, providing a programmatic way to manage cloud resources. The inclusion of refactoring capabilities acknowledges the long-term maintenance needs of infrastructure, while the integration guide highlights its role as a bridge between cloud design and configuration management.",
        "skill_content": "# Terraform Infrastructure Management\n\n## Overview\nThe Terraform Management skill provides a comprehensive framework for orchestrating infrastructure through HashiCorp Configuration Language (HCL). It enables the definition, provisioning, and management of cloud and on-premises resources in a predictable, version-controlled manner. This skill covers the entire Terraform lifecycle, including state management, provider configuration, module development, and safe infrastructure refactoring.\n\n## Capabilities\n- **State Management**: Configuration of remote backends (S3, GCS, Terraform Cloud), state locking, and secure migration of state files between environments.\n- **Resource Provisioning**: Execution of core Terraform workflows (`init`, `plan`, `apply`, `destroy`) with automated variable injection and output parsing.\n- **Module Development**: Scaffolding reusable, documented modules with standardized inputs, outputs, and validation rules to promote DRY (Don't Repeat Yourself) principles.\n- **Provider Configuration**: Management of multi-cloud and multi-region provider blocks, including authentication handling and version pinning.\n- **Infrastructure Refactoring**: Safe modification of existing infrastructure through `moved` blocks and state manipulation commands (`terraform state mv`) to minimize downtime and resource recreation.\n\n## Dependencies\n- `technical_skills/devops/infrastructure_as_code` (Parent context)\n- `technical_skills/cloud_computing` (Resource provider knowledge)\n- Terraform CLI (>= 1.5.0 recommended for `moved` block support)\n\n## Usage Examples\n### Provisioning a Basic Module\n```python\nfrom capabilities.resource_provisioning import TerraformOrchestrator\n\n# Initialize and apply a module\ntf = TerraformOrchestrator(workdir=\"./examples/basic-ec2-module\")\ntf.init()\nplan_path = tf.plan(vars={\"instance_type\": \"t3.micro\"})\ntf.apply(plan_path)\n\n# Access outputs for downstream tools\ninstance_ip = tf.get_output(\"public_ip\")\nprint(f\"Server deployed at: {instance_ip}\")\n```\n\n### State Migration\n```python\nfrom capabilities.state_management import StateManager\n\nmanager = StateManager(workdir=\"./infra\")\nmanager.configure_remote_backend(\n    bucket=\"my-terraform-state\",\n    region=\"us-east-1\",\n    dynamodb_table=\"terraform-lock\"\n)\nmanager.migrate_state() # Handles the 'terraform init -migrate-state' logic\n```",
        "capability_implementations": [
          {
            "name": "State Management",
            "content": "Implements logic for configuring backends and managing state files. It ensures state locking via DynamoDB or similar mechanisms to prevent concurrent modifications. Supports state sub-commands like `list`, `show`, and `pull/push` for disaster recovery scenarios."
          },
          {
            "name": "Resource Provisioning",
            "content": "Wraps the Terraform CLI to execute infrastructure changes. It includes logic to capture and parse `plan` files, ensuring that only approved changes are applied. It also handles the extraction of `outputs` in JSON format for consumption by other automation scripts."
          },
          {
            "name": "Module Development",
            "content": "Provides templates and validation logic for creating HCL modules. Enforces standards such as mandatory `variables.tf`, `outputs.tf`, and `main.tf` files, and validates HCL syntax and formatting using `terraform fmt` and `terraform validate`."
          },
          {
            "name": "Provider Configuration",
            "content": "Automates the setup of provider requirements. It handles the generation of `required_providers` blocks and manages credential injection for AWS, Azure, and GCP, supporting aliases for multi-region deployments."
          },
          {
            "name": "Refactoring",
            "content": "Facilitates the restructuring of HCL code without destroying resources. It automates the generation of `moved` blocks (introduced in Terraform 1.1) and provides a safe interface for `terraform state mv` operations when renaming resources or moving them into modules."
          }
        ],
        "usage_examples": [
          {
            "title": "Automated Plan and Apply",
            "description": "Demonstrates the standard workflow of initializing, planning, and applying infrastructure changes using the Resource Provisioning capability.",
            "code": "from capabilities.resource_provisioning import TerraformRunner\n\nrunner = TerraformRunner(directory='./prod-infra')\nrunner.init()\n\nsuccess, plan_output = runner.plan()\nif success:\n    print('Plan generated successfully.')\n    runner.apply()",
            "expected_output": "Plan generated successfully.\nApply complete! Resources: 5 added, 0 changed, 0 destroyed.",
            "language": "python"
          },
          {
            "title": "HCL Module Scaffolding",
            "description": "Using the Module Development capability to generate a standardized directory structure for a new infrastructure component.",
            "code": "from capabilities.module_development import ModuleScaffolder\n\nscaffolder = ModuleScaffolder(name='s3-static-site')\nscaffolder.create_structure(path='./modules')\nscaffolder.add_variable('bucket_name', type='string', description='Name of the S3 bucket')",
            "expected_output": "Created module structure at ./modules/s3-static-site\nUpdated variables.tf with bucket_name",
            "language": "python"
          },
          {
            "title": "State Resource Migration",
            "description": "Moving a resource from the root state into a module using the Refactoring capability.",
            "code": "from capabilities.refactoring import StateRefactor\n\nrefactor = StateRefactor(workdir='./infra')\n# Move aws_instance.web to module.web_server.aws_instance.this\nrefactor.move_resource('aws_instance.web', 'module.web_server.aws_instance.this')",
            "expected_output": "Successfully moved 1 object within the state.",
            "language": "python"
          }
        ],
        "best_practices": [
          {
            "title": "Always Use Remote State",
            "description": "Never store `terraform.tfstate` files locally or in version control. Use remote backends (S3, GCS, Azure Blob) with state locking enabled to ensure team collaboration and data safety.",
            "example": "terraform {\n  backend \"s3\" {\n    bucket = \"my-company-tfstate\"\n    key    = \"network/terraform.tfstate\"\n    region = \"us-east-1\"\n    dynamodb_table = \"tflock\"\n  }\n}"
          },
          {
            "title": "Pin Provider and Module Versions",
            "description": "To prevent breaking changes during automated runs, always pin providers and external modules to specific versions.",
            "example": "terraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}"
          },
          {
            "title": "Use Variables for Environment Differentiation",
            "description": "Avoid hardcoding values. Use `variables.tf` and `.tfvars` files to allow the same HCL code to deploy to Dev, Staging, and Production environments.",
            "example": "variable \"environment\" { type = string }\nresource \"aws_vpc\" \"main\" {\n  tags = { Name = \"vpc-${var.environment}\" }\n}"
          },
          {
            "title": "Implement 'Moved' Blocks for Refactoring",
            "description": "When renaming resources or moving them into modules, use HCL `moved` blocks instead of manual state manipulation to allow teammates to update their state automatically.",
            "example": "moved {\n  from = aws_instance.old_name\n  to   = aws_instance.new_name\n}"
          }
        ],
        "integration_guide": "The Terraform Management skill is a pivotal orchestrator in the DevOps lifecycle. It integrates directly with `cloud-computing` skills by consuming resource specifications (e.g., VPC CIDRs, instance types) and translating them into HCL. In a typical CI/CD pipeline, this skill should be triggered after code linting and before any configuration management tasks. It produces critical metadata (outputs) such as IP addresses or Load Balancer DNS names, which should be passed to downstream skills like Ansible or Kubernetes deployment operators via environment variables or dynamic inventory files.\n\nFor complex compositions, use this skill to manage the 'Foundational' layer (Networking, IAM, Databases) and provide the resulting ARNs or IDs to application-specific Terraform workspaces via `terraform_remote_state` data sources. This decoupling allows for independent scaling and security scoping of infrastructure components."
      },
      {
        "task_description": "Create a skill for AWS Lambda serverless functions including triggers, layers, and cold start optimization",
        "expected_taxonomy_path": "technical_skills/infrastructure/cloud/aws/lambda",
        "expected_name": "aws-lambda",
        "expected_type": "technical",
        "expected_weight": "medium",
        "expected_capabilities": [
          "function_creation",
          "trigger_configuration",
          "layer_management",
          "environment_variables",
          "cold_start_optimization",
          "logging_monitoring"
        ],
        "expected_dependencies": [],
        "expected_category": "technical_skills/infrastructure/cloud/aws",
        "expected_keywords": [
          "aws",
          "lambda",
          "serverless",
          "faas",
          "cloud"
        ],
        "expected_scope": "Covers AWS Lambda. Does NOT cover EC2 or ECS.",
        "expected_see_also": [
          "technical_skills/infrastructure/cloud/azure/functions"
        ]
      }
    ],
    "signature": {
      "instructions": "Generate comprehensive skill content with composition support.\n\nCreates the main SKILL.md content and supporting documentation.\nNote: YAML frontmatter will be added automatically during registration.\n\nThe skill_content MUST include these sections:\n- # Title (skill name as heading)\n- ## Overview (what the skill does)\n- ## Capabilities (list of discrete capabilities)\n- ## Dependencies (required skills or 'No dependencies')\n- ## Usage Examples (code examples with expected output)",
      "fields": [
        {
          "prefix": "Skill Skeleton:",
          "description": "JSON skill skeleton structure"
        },
        {
          "prefix": "Parent Skills:",
          "description": "Content/metadata from parent/sibling skills for context"
        },
        {
          "prefix": "Composition Strategy:",
          "description": "How this skill composes with others"
        },
        {
          "prefix": "Revision Feedback:",
          "description": "User feedback from previous revision to incorporate (empty if initial generation)"
        },
        {
          "prefix": "Reasoning: Let's think step by step in order to",
          "description": "${reasoning}"
        },
        {
          "prefix": "Skill Content:",
          "description": "Full SKILL.md markdown body content (frontmatter added automatically).\n        Must include: # Title, ## Overview, ## Capabilities, ## Dependencies, ## Usage Examples.\n        Include code blocks with syntax highlighting (```python, ```bash, etc.)."
        },
        {
          "prefix": "Capability Implementations:",
          "description": "Documentation content for each capability"
        },
        {
          "prefix": "Usage Examples:",
          "description": "Runnable usage examples with code and expected output"
        },
        {
          "prefix": "Best Practices:",
          "description": "Best practice recommendations (3-5 items)"
        },
        {
          "prefix": "Integration Guide:",
          "description": "Integration notes and composition patterns (1-2 paragraphs)"
        }
      ]
    },
    "lm": null
  },
  "package.package.predict": {
    "traces": [],
    "train": [],
    "demos": [],
    "signature": {
      "instructions": "You are a Senior DevOps Quality Assurance Engineer specializing in automated skill taxonomy and professional competency frameworks. Your objective is to act as the final gatekeeper for the `agentskills.io` platform, ensuring that every generated skill is technically sound, structurally consistent, and ready for production deployment.\n\nPerform a rigorous cross-validation of the provided skill artifacts and generate the following:\n\n1. **Reasoning**: Conduct a step-by-step analysis comparing `skill_content`, `skill_metadata`, and `capability_implementations`. Identify any discrepancies in naming conventions, taxonomy paths, or dependency declarations.\n2. **Validation Report**: Evaluate the skill against the standard schema. \n    - Mark as `passed=True` only if there are no critical errors. \n    - Issue `warnings` for minor inconsistencies (e.g., dependencies listed in Markdown but missing in JSON). \n    - Provide a checklist of specific validations (Schema, Taxonomy, Capability Mapping, Code Linting).\n3. **Integration Tests**: Generate 3-5 concrete `TestCase` objects derived from the usage examples and capability descriptions. Each test must specify clear `input_data` and the `expected_result` to verify the skill's runtime logic.\n4. **Packaging Manifest**: Create a formal inventory of all required files (e.g., `SKILL.md`, `metadata.json`) and generate a unique checksum for the package.\n5. **Quality Score**: Assign a final score (0.0 to 1.0). A high score (0.9+) requires perfect alignment between metadata and documentation, syntactically correct code blocks, and clear compliance with the taxonomy path.\n\nEnsure all outputs adhere strictly to the `agentskills.io` specification, using kebab-case for names and forward-slash notation for taxonomy paths.",
      "fields": [
        {
          "prefix": "Skill Content:",
          "description": "Generated SKILL.md content"
        },
        {
          "prefix": "Skill Metadata:",
          "description": "JSON skill metadata"
        },
        {
          "prefix": "Taxonomy Path:",
          "description": "Taxonomy path"
        },
        {
          "prefix": "Capability Implementations:",
          "description": "JSON capability documentation"
        },
        {
          "prefix": "Reasoning: Let's think step by step in order to",
          "description": "${reasoning}"
        },
        {
          "prefix": "Validation Report:",
          "description": "Validation results with pass/fail, errors, and warnings"
        },
        {
          "prefix": "Integration Tests:",
          "description": "Test cases to verify skill functionality"
        },
        {
          "prefix": "Packaging Manifest:",
          "description": "Manifest describing the packaged skill"
        },
        {
          "prefix": "Quality Score:",
          "description": "Overall quality score (0.0-1.0)"
        }
      ]
    },
    "lm": null
  },
  "metadata": {
    "dependency_versions": {
      "python": "3.13",
      "dspy": "3.1.0",
      "cloudpickle": "3.1"
    }
  }
}


============================================================
END FILE: src/skill_fleet/config/optimized/skill_creator_miprov2.json
============================================================

============================================================
FILE: src/skill_fleet/config/profiles/bootstrap_profiles.json
============================================================

{
  "bootstrap_profiles": {
    "web_developer": {
      "required": [
        "technical_skills/programming/languages/javascript_typescript",
        "technical_skills/programming/paradigms/object_oriented",
        "tool_proficiency/development_tools/version_control",
        "specializations/frontend_development",
        "task_focus_areas/build_create"
      ],
      "on_demand": [
        "technical_skills/infrastructure/containerization",
        "specializations/backend_development",
        "technical_skills/apis_integration/rest_apis"
      ]
    },
    "backend_developer": {
      "required": [
        "technical_skills/programming/languages/python",
        "technical_skills/data_engineering/storage/relational_databases",
        "technical_skills/apis_integration/rest_apis",
        "specializations/backend_development",
        "task_focus_areas/build_create"
      ],
      "on_demand": [
        "technical_skills/infrastructure/cloud_platforms",
        "technical_skills/security/authentication_authorization",
        "domain_knowledge/business_intelligence"
      ]
    },
    "data_scientist": {
      "required": [
        "technical_skills/programming/languages/python",
        "domain_knowledge/machine_learning",
        "technical_skills/data_engineering/processing/etl_pipelines",
        "tool_proficiency/data_tools/visualization_tools",
        "task_focus_areas/research_explore"
      ],
      "on_demand": [
        "domain_knowledge/nlp_understanding",
        "domain_knowledge/computer_vision",
        "technical_skills/data_engineering/storage/vector_databases"
      ]
    },
    "ml_engineer": {
      "required": [
        "technical_skills/programming/languages/python",
        "domain_knowledge/machine_learning",
        "specializations/ai_ml_engineering",
        "technical_skills/infrastructure/cloud_platforms",
        "task_focus_areas/build_create"
      ],
      "on_demand": [
        "domain_knowledge/nlp_understanding",
        "technical_skills/infrastructure/containerization",
        "task_focus_areas/optimize_improve"
      ]
    },
    "devops_engineer": {
      "required": [
        "technical_skills/infrastructure/cloud_platforms",
        "technical_skills/infrastructure/containerization",
        "technical_skills/infrastructure/infrastructure_as_code",
        "specializations/devops_sre",
        "task_focus_areas/maintain_support"
      ],
      "on_demand": [
        "technical_skills/programming/languages/shell_scripting",
        "tool_proficiency/monitoring_observability",
        "technical_skills/security"
      ]
    },
    "general_purpose": {
      "required": [
        "cognitive_skills/analysis",
        "cognitive_skills/synthesis",
        "cognitive_skills/reasoning",
        "task_focus_areas/build_create"
      ],
      "on_demand": [
        "technical_skills/programming/languages/python",
        "tool_proficiency/development_tools",
        "task_focus_areas/debug_fix"
      ]
    }
  },
  "tech_stack_mapping": {
    "JavaScript/TypeScript": [
      "technical_skills/programming/languages/javascript_typescript"
    ],
    "Python": [
      "technical_skills/programming/languages/python"
    ],
    "React": [
      "specializations/frontend_development/react_ecosystem"
    ],
    "Node.js": [
      "technical_skills/programming/languages/javascript_typescript/node_runtime"
    ],
    "Docker": [
      "technical_skills/infrastructure/containerization/docker"
    ],
    "Kubernetes": [
      "technical_skills/infrastructure/containerization/kubernetes"
    ],
    "AWS": [
      "technical_skills/infrastructure/cloud_platforms/aws_services"
    ],
    "PostgreSQL": [
      "technical_skills/data_engineering/storage/relational_databases"
    ],
    "MongoDB": [
      "technical_skills/data_engineering/storage/nosql_databases"
    ]
  },
  "task_mapping": {
    "Building new features": [
      "task_focus_areas/build_create"
    ],
    "Debugging issues": [
      "task_focus_areas/debug_fix"
    ],
    "Performance optimization": [
      "task_focus_areas/optimize_improve"
    ],
    "Code review": [
      "cognitive_skills/analysis/code_analysis"
    ],
    "Writing tests": [
      "technical_skills/programming/practices/testing"
    ],
    "Documentation": [
      "cognitive_skills/synthesis/content_generation/documentation"
    ],
    "Data analysis": [
      "cognitive_skills/analysis/data_analysis"
    ],
    "API design": [
      "cognitive_skills/synthesis/design_synthesis/api_design"
    ]
  }
}


============================================================
END FILE: src/skill_fleet/config/profiles/bootstrap_profiles.json
============================================================

============================================================
FILE: src/skill_fleet/config/templates/SKILL_md_template.md
============================================================

{{!--
SKILL.md Template - skill-fleet Convention

Spec: https://agentskills.io/specification
Authoring: See writing-skills for TDD-based skill creation process

═══════════════════════════════════════════════════════════════════
TOKEN BUDGET (Critical for agent context efficiency)
═══════════════════════════════════════════════════════════════════

Frontmatter: ~100 tokens (name + description injected into XML prompt)
Body by skill type: - Getting-started/frequent: <150 words - Standard skills: <500 words  
 - Complex technical: <5000 tokens (~500 lines max)

Use references/ and guides/ for deep dives that load on demand.

═══════════════════════════════════════════════════════════════════
DIRECTORY STRUCTURE (skill-fleet convention)
═══════════════════════════════════════════════════════════════════

skill-name/
├── SKILL.md # Required - main skill document
├── metadata.json # Optional - tooling metadata (see metadata*template.json)
├── references/ # Optional - deep-dive pattern docs, API refs (progressive disclosure)
│ ├── quick-start.md
│ ├── common-patterns.md
│ └── capability-implementations/ # Optional - per-capability implementation notes
├── guides/ # Optional - step-by-step workflows, troubleshooting
│ ├── troubleshooting.md
│ └── how-to-*.md
├── templates/ # Optional - boilerplate for reuse
├── scripts/ # Optional - runnable automation helpers
├── examples/ # Optional - runnable demos
│ └── example-name/
│ ├── README.md
│ └── implementation files
└── tests/ # Optional - test scenarios for skill validation
└── test*\*.json

═══════════════════════════════════════════════════════════════════
FRONTMATTER (agentskills.io compliant)
═══════════════════════════════════════════════════════════════════

REQUIRED:
name: Max 64 chars. Lowercase + hyphens only. Must match directory.
description: Max 1024 chars. See CSO section below.

OPTIONAL (use sparingly):
license: License name or LICENSE file reference
compatibility: Max 500 chars. Environment requirements
metadata: Key-value pairs for frontmatter-level tooling data - skill_id, version, type, weight, load_priority - Note: prefer metadata.json for complex tooling data
allowed-tools: Space-delimited tool list (experimental)

═══════════════════════════════════════════════════════════════════
CLAUDE SEARCH OPTIMIZATION (CSO) - Critical for Discovery
═══════════════════════════════════════════════════════════════════

Description = WHEN to use, NOT WHAT it does

The description field determines if Claude loads your skill.
If you summarize the workflow, Claude may follow the description
instead of reading the full skill content.

❌ BAD: Summarizes workflow (Claude takes shortcut)
description: Use when executing plans - dispatches subagent per task with code review

❌ BAD: Too vague
description: For async testing

✅ GOOD: Triggering conditions only
description: Use when building FastAPI apps with async database operations, connection pool issues, or partial update bugs

✅ GOOD: Symptoms and error messages
description: Use when tests have race conditions, timing dependencies, or pass/fail inconsistently

Include in description: - Concrete triggers and symptoms - Error messages agents might search for - Technology names if skill is technology-specific

Do NOT include: - Process steps or workflow summary - What the skill teaches (save for Overview)

═══════════════════════════════════════════════════════════════════
ANTI-PATTERNS (from writing-skills)
═══════════════════════════════════════════════════════════════════

❌ Narrative examples: "In session 2025-10-03, we found..."
→ Too specific, not reusable

❌ Multi-language dilution: example-js.js, example-py.py, example-go.go
→ Mediocre quality, maintenance burden. One excellent example beats many.

❌ Code in flowcharts: step1 [label="import fs"]
→ Can't copy-paste, hard to read

❌ Generic labels: helper1, step2, pattern4
→ Labels should have semantic meaning

## --}}

---
name: {{skill_name_kebab}}
description: Use when {{triggering_conditions}}
{{#if license}}
license: {{license}}
{{/if}}
{{#if compatibility}}
compatibility: {{compatibility}}
{{/if}}
{{#if metadata}}
metadata:
{{#each metadata}}
{{@key}}: {{this}}
{{/each}}
{{/if}}

---

# {{skill_name}}

## Overview

{{overview_description}}

**Core principle:** {{core_principle}}

## Capabilities

{{!-- List 3-8 concrete, testable capabilities. Prefer short verb phrases. --}}

- {{capability_1}}
- {{capability_2}}
- {{capability_3}}

## Dependencies

{{!-- List prerequisite skills/tools AND why they matter. Keep it scannable. --}}

- {{dependency_1}} — {{why_dependency_1}}
- {{dependency_2}} — {{why_dependency_2}}

## When to Use

{{!-- Optional: Include decision flowchart for non-obvious decisions

```dot
digraph when_to_use {
    "Building X?" [shape=diamond];
    "Has symptom Y?" [shape=diamond];
    "Use this skill" [shape=box];
    "Use other approach" [shape=box];

    "Building X?" -> "Has symptom Y?" [label="yes"];
    "Has symptom Y?" -> "Use this skill" [label="yes"];
    "Has symptom Y?" -> "Use other approach" [label="no"];
}
```

--}}

**Use when:**
{{#each use_when}}

- {{this}}
  {{/each}}

**When NOT to use:**
{{#each not_use_when}}

- {{this}}
  {{/each}}

## Quick Reference

| Problem | Solution | Keywords |
| ------- | -------- | -------- |

{{#each quick_reference}}
| {{problem}} | {{solution}} |
{{/each}}

## Core Patterns

### {{pattern_name}}

**The problem:** {{problem_description}}

**❌ Common mistake:**

```{{language}}
{{bad_example}}
```

**✅ Production pattern:**

```{{language}}
{{good_example}}
```

**Key insight:** {{key_insight}}

{{!-- For complex skills with multiple patterns, link to references/ --}}
{{#if capabilities}}

> **Deep dives:** See `references/` for detailed pattern documentation:
> {{#each capabilities}}
>
> - [{{this}}](references/{{this}}.md)
>   {{/each}}
>   {{/if}}

## Usage Examples

{{!-- Include at least 1–3 runnable examples with fenced code blocks. --}}

### {{example_title}}

{{example_description}}

```{{language}}
{{example_code}}
```

## Common Mistakes

| Mistake | Why It's Wrong | Fix |
| ------- | -------------- | --- |

{{#each common_mistakes}}
| {{mistake}} | {{why_wrong}} | {{fix}} |
{{/each}}

{{#if real_world_impact}}

## Real-World Impact

{{#each real_world_impact}}

- {{this}}
  {{/each}}
  {{/if}}

## Strong Guidance

{{!-- Iron Law style rules – imperative statements that MUST be followed --}}

{{#if strong_guidance}}
{{#each strong_guidance}}
- **{{this}}**
{{/each}}
{{else}}
- **NO [action] WITHOUT [prerequisite]** — [explanation]
- **ALWAYS [action]** — [explanation]
- **NEVER [action]** — [explanation]
{{/if}}

## Red Flags

{{#each red_flags}}

- {{this}}
  {{/each}}

**All of these mean: Revisit your approach before proceeding.**

---

## Validation

```bash
# Validate the skill directory
uv run skill-fleet validate path/to/{{skill_name_kebab}}

# Ensure skills are discoverable (optional)
uv run skill-fleet generate-xml
```

**Authoring process:** See `writing-skills` for TDD-based skill creation checklist.


============================================================
END FILE: src/skill_fleet/config/templates/SKILL_md_template.md
============================================================

============================================================
FILE: src/skill_fleet/config/templates/metadata_template.json
============================================================

{
  "$schema": "https://skill-fleet.dev/schemas/metadata.json",
  "_comment": [
    "skill-fleet Metadata Template",
    "",
    "This file contains tooling-specific metadata separate from SKILL.md frontmatter.",
    "Frontmatter (name, description) is the source of truth for agent discovery.",
    "This file extends with skill-fleet specific fields for taxonomy, evolution, and tooling.",
    "",
    "DO NOT duplicate name/description here - they belong in SKILL.md frontmatter only."
  ],

  "skill_id": "{{taxonomy_path}}/{{skill_name_kebab}}",
  "name": "{{skill_name_kebab}}",
  "description": "{{description}}",

  "version": "1.0.0",
  "type": "{{type}}",
  "weight": "{{weight}}",
  "load_priority": "{{load_priority}}",

  "dependencies": [],

  "capabilities": ["{{capability_1}}", "{{capability_2}}"],

  "category": "{{category}}",
  "tags": ["{{tag_1}}", "{{tag_2}}"],

  "created_at": "{{created_at}}",
  "last_modified": "{{last_modified}}",

  "evolution": {
    "version": "1.0.0",
    "parent_id": null,
    "evolution_path": "initial_release",
    "change_log": "{{change_log}}",
    "validation_score": null,
    "integrity_hash": null
  }
}


============================================================
END FILE: src/skill_fleet/config/templates/metadata_template.json
============================================================

============================================================
FILE: src/skill_fleet/config/training/gold_skills.json
============================================================

{
  "version": "1.0",
  "skills": [
    {
      "skill_id": "technical/programming/web-frameworks/python/fastapi",
      "task_description": "Create a high-quality FastAPI production-ready skill with lifecycle management, async database patterns, and testing strategies.",
      "skill_path": "skills/technical_skills/programming/web_frameworks/python/fastapi/SKILL.md",
      "quality_score": 0.855,
      "source": "local",
      "metadata": {
        "curated": true
      }
    },
    {
      "skill_id": "technical_skills/web_development/frontend/react/vite-tailwind-setup",
      "task_description": "Create a modern React frontend setup skill using Vite and Tailwind CSS, focusing on build optimization and developer experience.",
      "skill_path": "skills/technical_skills/web_development/frontend/react/vite/SKILL.md",
      "quality_score": 0.758,
      "source": "local",
      "metadata": {
        "curated": true
      }
    },
    {
      "skill_id": "technical_skills/web_development/frontend/react/react-vite-production-setup",
      "task_description": "Create a production-ready React setup with Vite, including advanced patterns and performance considerations.",
      "skill_path": "skills/technical_skills/web_development/frontend/react/react-vite-production-setup/SKILL.md",
      "quality_score": 0.720,
      "source": "local",
      "metadata": {
        "curated": true
      }
    },
    {
      "skill_id": "technical_skills/programming/languages/python/decorators",
      "task_description": "Create a comprehensive Python decorators skill with preserving metadata, parameterized factories, and async support.",
      "skill_path": "skills/technical_skills/programming/languages/python/decorators/SKILL.md",
      "quality_score": 0.930,
      "source": "local",
      "metadata": {
        "curated": true
      }
    }
  ]
}


============================================================
END FILE: src/skill_fleet/config/training/gold_skills.json
============================================================

============================================================
FILE: src/skill_fleet/config/training/manager.py
============================================================

"""
Training Data Manager for DSPy optimization.

Handles metadata, quality scoring, and filtering of training examples used
for optimizing skill creation prompts.
"""

from __future__ import annotations

import json
import logging
from dataclasses import dataclass, field
from datetime import UTC, datetime
from pathlib import Path
from typing import Any

from pydantic import BaseModel, Field

logger = logging.getLogger(__name__)


