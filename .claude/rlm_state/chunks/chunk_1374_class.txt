<!-- Chunk 1374: bytes 5084054-5097067, type=class -->
class CommonQueryParams:
    def __init__(
        self,
        skip: int = 0,
        limit: int = 100,
        order_by: str = "created_at"
    ):
        self.skip = skip
        self.limit = limit
        self.order_by = order_by

@app.get("/items")
async def get_items(commons: CommonQueryParams = Depends()):
    return {
        "items": items[commons.skip:commons.limit],
        "order": commons.order_by
    }
```

## Annotated Dependencies (Python 3.9+)

```python
from typing import Annotated

DbSession = Annotated[AsyncSession, Depends(get_db)]

@app.get("/users")
async def get_users(db: DbSession):
    # No need to repeat Depends(get_db)
    return await db.execute(select(User))
```

## Best Practices

| Practice | Why |
|----------|-----|
| Use `yield` for resources | Automatic cleanup |
| Always clear overrides | Prevents test pollution |
| Chain dependencies | FastAPI auto-resolves |
| Cache singletons | `lru_cache` for config |
| Type hint dependencies | Better IDE support |

## Common Mistakes

```python
# ❌ Manual dependency passing
async def endpoint(db: AsyncSession):
    db = await get_db()  # Wrong!

# ✅ Let FastAPI handle it
async def endpoint(db: AsyncSession = Depends(get_db)):
    pass
```

## See Also
- [Database Lifecycle Management](database-lifecycle-management.md)
- [Async Testing](async-testing.md)


============================================================
END FILE: skills/python/fastapi-production/capabilities/dependency-injection.md
============================================================

============================================================
FILE: skills/python/fastapi-production/capabilities/fastapi-cli.md
============================================================

# FastAPI CLI

## Overview
The FastAPI CLI (introduced in FastAPI 0.100+) provides a streamlined way to run FastAPI applications in development and production, replacing manual uvicorn commands with a more intuitive interface.

## Installation

The FastAPI CLI is included when you install FastAPI with the `standard` extras:

```bash
uv add "fastapi[standard]"
```

This includes:
- `fastapi` - The core framework
- `uvicorn[standard]` - The ASGI server with high-performance dependencies
- `fastapi-cli[standard]` - The CLI tool (including fastapi-cloud-cli for deployment)
- `httpx` - For testing
- `jinja2` - For templates
- `python-multipart` - For form data parsing

## CLI Commands

### Development: `fastapi dev`

Run your application in development mode with auto-reload:

```bash
fastapi dev main.py
```

**Features:**
- Auto-reload on file changes
- Detailed error messages
- Debug mode enabled
- Runs on http://127.0.0.1:8000 by default

**Example output:**
```
 ╭────────── FastAPI CLI - Development mode ───────────╮
 │                                                     │
 │  Serving at: http://127.0.0.1:8000                  │
 │                                                     │
 │  API docs: http://127.0.0.1:8000/docs               │
 │                                                     │
 │  Running in development mode, for production use:   │
 │                                                     │
 │  fastapi run                                        │
 │                                                     │
 ╰─────────────────────────────────────────────────────╯

INFO:     Will watch for changes in these directories: ['/home/user/code/awesomeapp']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [2248755] using WatchFiles
INFO:     Started server process [2248757]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
```

**Custom host and port:**
```bash
fastapi dev main.py --host 0.0.0.0 --port 8080
```

### Production: `fastapi run`

Run your application in production mode:

```bash
fastapi run main.py
```

**Features:**
- No auto-reload (better performance)
- Optimized for production
- Runs on http://127.0.0.1:8000 by default

**Custom host and port:**
```bash
fastapi run main.py --host 0.0.0.0 --port 8080
```

**Number of workers:**
```bash
fastapi run main.py --workers 4
```

## Comparison: Old vs New

| Old Method (Uvicorn) | New Method (FastAPI CLI) |
|---------------------|-------------------------|
| `uvicorn main:app --reload` | `fastapi dev main.py` |
| `uvicorn main:app` | `fastapi run main.py` |
| `uvicorn main:app --host 0.0.0.0 --port 8080` | `fastapi dev main.py --host 0.0.0.0 --port 8080` |
| Manual dependency management | `uv add "fastapi[standard]"` |

## Quick Reference

| Command | Purpose | Mode |
|---------|---------|------|
| `fastapi dev main.py` | Development server with auto-reload | Development |
| `fastapi run main.py` | Production server | Production |
| `fastapi dev main.py --port 8080` | Custom port | Development |
| `fastapi run main.py --workers 4` | Multiple workers | Production |

## FastAPI Cloud (Optional)

FastAPI Cloud is a deployment service built by the FastAPI team for one-command deployment.

**Login:**
```bash
fastapi login
```

**Deploy:**
```bash
fastapi deploy
```

This deploys your application to FastAPI Cloud and provides a public URL.

> **Note:** FastAPI Cloud is optional. You can deploy FastAPI apps to any cloud provider (AWS, GCP, Azure, Railway, Render, etc.) using traditional deployment methods.

## Common Patterns

### Development Workflow

1. **Install dependencies:**
   ```bash
   uv add "fastapi[standard]"
   ```

2. **Create your app** (main.py):
   ```python
   from fastapi import FastAPI

   app = FastAPI()

   @app.get("/")
   async def root():
       return {"message": "Hello World"}
   ```

3. **Run in development:**
   ```bash
   fastapi dev main.py
   ```

4. **Test at http://127.0.0.1:8000/docs**

### Production Deployment

**Option 1: Using the CLI directly**
```bash
fastapi run main.py --host 0.0.0.0 --port 8000 --workers 4
```

**Option 2: Using gunicorn with uvicorn workers** (recommended for production)
```bash
uv add gunicorn
gunicorn main:app -w 4 -k uvicorn.workers.UvicornWorker
```

**Option 3: FastAPI Cloud**
```bash
fastapi login
fastapi deploy
```

## Best Practices

1. **Use `fastapi dev` for development** - Auto-reload saves time
2. **Use `fastapi run` for simple production deployments** - Good for small apps
3. **Use gunicorn + uvicorn workers for production** - Better process management
4. **Set appropriate worker counts** - Typically 2-4 workers per CPU core
5. **Use environment variables** - Don't hardcode hosts and ports

## Troubleshooting

**"fastapi: command not found"**
- Ensure you installed with `uv add "fastapi[standard]"`
- Check your virtual environment is activated

**Port already in use**
- Use `--port` flag to specify a different port
- Check what's using the port: `lsof -i :8000` (macOS/Linux)

**Auto-reload not working**
- Ensure you're using `fastapi dev`, not `fastapi run`
- Check file permissions

**Workers not spawning**
- Ensure you're using `fastapi run`, not `fastapi dev`
- Check system resources

## See Also

- [Async Testing Capability](async-testing.md)
- [Database Lifecycle Management](database-lifecycle-management.md)
- [Integration Guide](../integration.md)


============================================================
END FILE: skills/python/fastapi-production/capabilities/fastapi-cli.md
============================================================

============================================================
FILE: skills/python/fastapi-production/capabilities/file-upload-handling.md
============================================================

# File Upload Handling

## Overview
Handling file uploads in FastAPI efficiently by streaming rather than loading entire files into memory.

## Problem Statement
**File upload anti-patterns:**
- Loading entire file into memory (OOM with large files)
- Not validating file types/size
- No streaming for processing
- Blocking I/O on file operations

## Pattern: Streaming File Uploads

### ❌ Broken (Loads Entire File)
```python
@app.post("/upload")
async def upload_file(file: UploadFile):
    # ❌ Loads entire file into memory!
    content = await file.read()

    # Process entire file in memory
    result = process_in_memory(content)

    return {"size": len(content)}
```

### ✅ Production Pattern
```python
from fastapi import UploadFile
import pandas as pd
import aiofiles

@app.post("/upload-csv")
async def upload_csv(file: UploadFile):
    # Stream the file - don't load entirely into memory
    df = pd.read_csv(file.file)

    # Process
    results = process_data_frame(df)

    return {"uploaded": len(results), "data": results}
```

## File Type Handling

### 1. Image Upload
```python
from PIL import Image
import io

@app.post("/upload-image")
async def upload_image(file: UploadFile):
    # Validate file type
    if not file.content_type.startswith("image/"):
        raise HTTPException(status_code=400, detail="Not an image")

    # Stream process image
    contents = await file.read()
    image = Image.open(io.BytesIO(contents))

    # Process image
    image.thumbnail((256, 256))

    # Save
    output = io.BytesIO()
    image.save(output, format="JPEG")
    return {"size": len(output.getvalue())}
```

### 2. Large File Streaming
```python
from pathlib import Path

@app.post("/upload-large")
async def upload_large_file(file: UploadFile):
    # Sanitize filename to prevent path traversal
    safe_filename = Path(file.filename).name
    
    # Stream in chunks
    chunk_size = 1024 * 1024  # 1MB chunks
    total_size = 0

    async with aiofiles.open(f"/uploads/{safe_filename}", "wb") as f:
        while chunk := await file.read(chunk_size):
            await f.write(chunk)
            total_size += len(chunk)

    return {"filename": safe_filename, "size": total_size}
```

### 3. Multiple Files
```python
from fastapi import UploadFile, File
from typing import List
from pathlib import Path

@app.post("/upload-multiple")
async def upload_multiple(files: List[UploadFile] = File(...)):
    results = []

    for file in files:
        # Sanitize filename to prevent path traversal
        safe_filename = Path(file.filename).name
        
        # Process each file
        file_path = f"/uploads/{safe_filename}"
        async with aiofiles.open(file_path, "wb") as f:
            await f.write(await file.read())

        results.append({
            "filename": safe_filename,
            "content_type": file.content_type
        })

    return {"uploaded": len(results), "files": results}
```

## Validation

### File Type Validation
```python
ALLOWED_EXTENSIONS = {".csv", ".xlsx", ".json"}
ALLOWED_MIME_TYPES = {
    "text/csv",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/json"
}

@app.post("/upload-data")
async def upload_data(file: UploadFile):
    # Validate extension
    ext = os.path.splitext(file.filename)[1].lower()
    if ext not in ALLOWED_EXTENSIONS:
        raise HTTPException(
            status_code=400,
            detail=f"Extension {ext} not allowed"
        )

    # Validate MIME type
    if file.content_type not in ALLOWED_MIME_TYPES:
        raise HTTPException(
            status_code=400,
            detail=f"MIME type {file.content_type} not allowed"
        )

    # Process file...
```

### File Size Limit
```python
MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB

@app.post("/upload")
async def upload_file(file: UploadFile):
    # Check file size
    file.file.seek(0, os.SEEK_END)
    file_size = file.file.tell()
    file.file.seek(0)

    if file_size > MAX_FILE_SIZE:
        raise HTTPException(
            status_code=413,
            detail=f"File too large. Max size: {MAX_FILE_SIZE} bytes"
        )

    # Process file...
```

## Async File Operations

```python
import aiofiles
import asyncio

async def process_file_async(file_path: str):
    # Async file read
    async with aiofiles.open(file_path, "r") as f:
        content = await f.read()

    # Process content
    lines = content.splitlines()

    # Async file write
    output_path = file_path + ".processed"
    async with aiofiles.open(output_path, "w") as f:
        for line in lines:
            await f.write(process_line(line) + "\n")

    return output_path
```

## Common Mistakes

| Mistake | Impact | Fix |
|---------|--------|-----|
| Loading entire file into memory | OOM with large files | Stream in chunks |
| Not validating file types | Security vulnerability | Check extension + MIME |
| Blocking file I/O | Event loop blocked | Use `aiofiles` |
| No size limits | DoS vulnerability | Enforce max size |
| Synchronous processing | Poor performance | Use async patterns |

## Security Considerations

1. **Validate file extensions** - Prevent executable uploads
2. **Check MIME types** - Double-check with magic bytes
3. **Enforce size limits** - Prevent DoS
4. **Scan for malware** - Use virus scanners in production
5. **Sanitize filenames** - Prevent path traversal

```python
import os

