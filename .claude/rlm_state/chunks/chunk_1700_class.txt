<!-- Chunk 1700: bytes 7234326-7275914, type=class -->
class TrainingDataManager:
    """Manages the lifecycle, quality, and selection of training examples for DSPy."""

    def __init__(self, data_root: Path | str = "config/training") -> None:
        """
        Initialize the training data manager.

        Args:
            data_root: Path to training data directory.

        """
        self.data_root = Path(data_root)
        self.metadata_file = self.data_root / "example_metadata.json"
        self.trainset_file = self.data_root / "trainset.json"
        self._metadata: dict[str, ExampleMetadata] = {}
        self._load_metadata()

    def _load_metadata(self) -> None:
        """Load metadata from disk."""
        if self.metadata_file.exists():
            try:
                data = json.loads(self.metadata_file.read_text())
                self._metadata = {k: ExampleMetadata(**v) for k, v in data.items()}
                logger.info(f"Loaded {len(self._metadata)} training example metadata records")
            except Exception as e:
                logger.error(f"Failed to load metadata: {e}")
                self._metadata = {}
        else:
            logger.warning(f"Metadata file not found at {self.metadata_file}, initializing empty")
            self._metadata = {}

    def save_metadata(self) -> None:
        """Save metadata to disk."""
        try:
            # Ensure directory exists
            self.metadata_file.parent.mkdir(parents=True, exist_ok=True)

            data = {k: v.model_dump() for k, v in self._metadata.items()}
            self.metadata_file.write_text(json.dumps(data, indent=2))
            logger.info("Saved training metadata")
        except Exception as e:
            logger.error(f"Failed to save metadata: {e}")

    def get_trainset(self, config: TrainingDataConfig | None = None) -> list[dict[str, Any]]:
        """
        Get a filtered list of training examples based on configuration.

        Args:
            config: Selection configuration. If None, uses defaults.

        Returns:
            List of example dictionaries (compatible with DSPy)

        """
        if config is None:
            config = TrainingDataConfig()

        # Load raw examples
        if not self.trainset_file.exists():
            logger.warning("Trainset file not found")
            return []

        try:
            raw_examples = json.loads(self.trainset_file.read_text())
        except Exception as e:
            logger.error(f"Failed to load trainset: {e}")
            return []

        # Filter and sort
        scored_examples = []
        for ex in raw_examples:
            # Assume examples have 'task_description' or similar ID field
            # If not, generate a hash/ID
            ex_id = self._get_example_id(ex)
            meta = self._metadata.get(ex_id)

            score = 0.0
            if meta:
                # Weighted score based on quality and success
                score = (meta.quality_score * 0.6) + (meta.success_rate * 0.4)

                # Apply category boost
                if meta.category in config.category_weights:
                    score *= config.category_weights[meta.category]

                if score < config.min_quality_score:
                    continue
            else:
                # New/unknown example - give it a chance (neutral score)
                score = 0.5

            scored_examples.append((score, ex))

        # Sort by score descending
        scored_examples.sort(key=lambda x: x[0], reverse=True)

        # Select top N
        selected = [x[1] for x in scored_examples[: config.max_examples]]

        # Update usage stats
        self._update_usage_stats(selected)

        return selected

    def _get_example_id(self, example: dict) -> str:
        """Generate a consistent ID for an example."""
        # Simple heuristic: hash of the input task
        # In a real system, examples should store their ID
        if "id" in example:
            return example["id"]

        # Fallback for DSPy Examples which might be just input/output
        # Assuming 'task_description' or 'user_intent' is the input key
        content = example.get("task_description") or example.get("user_intent") or str(example)
        import hashlib

        return hashlib.md5(content.encode()).hexdigest()

    def _update_usage_stats(self, examples: list[dict]) -> None:
        """Update last_used timestamp and usage count."""
        now = datetime.now(UTC).isoformat()
        changed = False

        for ex in examples:
            ex_id = self._get_example_id(ex)
            if ex_id in self._metadata:
                self._metadata[ex_id].usage_count += 1
                self._metadata[ex_id].last_used = now
                changed = True
            else:
                # Auto-register new metadata if missing
                self._metadata[ex_id] = ExampleMetadata(
                    example_id=ex_id,
                    task_description=ex.get("task_description", "Unknown task"),
                    category="unknown",
                    created_at=now,
                    last_used=now,
                    usage_count=1,
                )
                changed = True

        if changed:
            self.save_metadata()

    def update_scores(self, results: list[dict[str, Any]]) -> None:
        """
        Update example scores based on optimization run results.

        Args:
            results: List of dicts with 'example_id', 'score' (0-1), 'passed' (bool)

        """
        changed = False
        for res in results:
            ex_id = res.get("example_id")
            if not ex_id or ex_id not in self._metadata:
                continue

            meta = self._metadata[ex_id]

            # Update quality score (moving average)
            new_score = res.get("score", 0.0)
            meta.quality_score = (meta.quality_score * 0.8) + (new_score * 0.2)

            # Update success rate
            passed = 1.0 if res.get("passed") else 0.0
            # Simple moving average for success rate too
            meta.success_rate = (meta.success_rate * 0.9) + (passed * 0.1)

            changed = True

        if changed:
            self.save_metadata()

    def score_examples(self) -> None:
        """
        Run static analysis to score all examples (placeholder).

        In a real implementation, this would use a 'judge' LM to rate examples.
        """
        # Placeholder logic
        for meta in self._metadata.values():
            if meta.quality_score == 0.0:
                meta.quality_score = 0.5  # Reset to neutral
        self.save_metadata()


============================================================
END FILE: src/skill_fleet/config/training/manager.py
============================================================

============================================================
FILE: src/skill_fleet/config/training/quality_criteria.yaml
============================================================

# Quality Criteria for Skill Evaluation
# This file defines the rubric used to assess skill quality during
# evaluation and optimization.

version: "1.0"

# Quality thresholds for pass/fail determination
thresholds:
  minimum_quality: 0.6   # Below this = failed
  target_quality: 0.8    # Good quality target
  excellent_quality: 0.9 # Excellent/gold-standard

# Metric weights for overall score calculation
# All weights should sum to 1.0
metric_weights:
  pattern_count: 0.15
  has_anti_patterns: 0.10
  has_key_insights: 0.10
  has_real_world_impact: 0.10
  has_quick_reference: 0.10
  has_common_mistakes: 0.10
  has_red_flags: 0.05
  frontmatter_completeness: 0.15
  code_examples_quality: 0.15

# Detailed criteria definitions
criteria:
  # Structure criteria
  frontmatter:
    description: "YAML frontmatter completeness"
    required_fields:
      - name
      - description
    recommended_fields:
      - metadata.skill_id
      - metadata.version
      - metadata.type
      - metadata.weight
    optional_fields:
      - license
      - compatibility
      - keywords
      - see_also
    scoring:
      has_name: 0.2
      has_description: 0.2
      description_starts_with_use_when: 0.1
      has_metadata_skill_id: 0.1
      has_metadata_version: 0.1
      has_metadata_type: 0.05
      has_metadata_weight: 0.05
      has_optional_fields: 0.2  # Distributed across optional fields

  sections:
    description: "Required and recommended sections in skill body"
    required:
      - overview
      - when_to_use
      - core_patterns
    recommended:
      - quick_reference
      - common_mistakes
      - red_flags
    optional:
      - real_world_impact
      - validation

  # Pattern criteria
  patterns:
    description: "Quality of patterns in the skill"
    target_count: 5  # Target number of patterns
    minimum_count: 2 # Minimum acceptable
    requirements:
      - anti_pattern_example  # ❌ Common mistake
      - production_pattern    # ✅ Correct approach
      - key_insight          # Summary of critical learning

  # Code quality criteria
  code_examples:
    description: "Quality of code examples"
    requirements:
      - language_specification  # Code blocks should specify language
      - no_placeholders        # No TODO, pass, NotImplementedError
      - substantial_length     # At least 3 lines per block
      - copy_paste_ready       # Should work when copied

# Quality indicators from excellent skills (FastAPI example)
excellence_indicators:
  - "Rich YAML frontmatter with metadata"
  - "Clear Overview with core principle"
  - "When to Use / When NOT to use sections"
  - "Quick Reference table (Problem → Solution → Keywords)"
  - "5+ Core Patterns with ❌/✅ examples"
  - "Key Insight after each pattern"
  - "Common Mistakes table"
  - "Red Flags section"
  - "Real-World Impact with quantified benefits"
  - "Executable code examples"

# Anti-patterns to avoid (from analysis)
anti_patterns:
  - "Placeholder files (empty README.md)"
  - "Non-executable test descriptions"
  - "Missing Key Insights after patterns"
  - "No Real-World Impact section"
  - "Description that summarizes workflow instead of triggering conditions"
  - "Narrative storytelling instead of reusable patterns"
  - "Multi-language dilution (one excellent example is better)"
  - "Generic labels (helper1, step2) instead of semantic names"

# Checklist for manual review
manual_review_checklist:
  structure:
    - "YAML frontmatter with name and description"
    - "Description starts with 'Use when...'"
    - "Description does NOT summarize workflow"
    - "Overview with core principle (1-2 sentences)"
    - "When to Use / When NOT to use sections"
    - "Quick Reference table"
  
  patterns:
    - "5+ Core Patterns"
    - "Each pattern has ❌ anti-pattern example"
    - "Each pattern has ✅ production pattern"
    - "Each pattern has Key Insight"
  
  practical_value:
    - "Common Mistakes table"
    - "Red Flags section"
    - "Real-World Impact with quantified benefits"
  
  code_quality:
    - "No placeholder files"
    - "No narrative storytelling"
    - "One excellent example per pattern"
    - "Code examples are copy-paste ready"
    - "Labels have semantic meaning"
    - "Total SKILL.md under 500 lines (or split to references)"


============================================================
END FILE: src/skill_fleet/config/training/quality_criteria.yaml
============================================================

============================================================
FILE: src/skill_fleet/config/training/trainset.json
============================================================

[
  {
    "task_description": "Create a Python async programming skill covering asyncio, event loops, coroutines, and concurrent execution patterns",
    "expected_taxonomy_path": "technical_skills/programming/languages/python/asynchronous_programming",
    "expected_name": "python-async",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "async_await_syntax",
      "event_loop_management",
      "concurrent_execution",
      "task_creation",
      "exception_handling"
    ],
    "expected_dependencies": ["technical_skills/programming/languages/python"],
    "expected_category": "technical_skills/programming/languages/python",
    "expected_keywords": [
      "asyncio",
      "async",
      "await",
      "coroutines",
      "event-loop",
      "concurrent",
      "python",
      "asynchronous"
    ],
    "expected_scope": "Covers Python asyncio library, async/await syntax, event loops, and concurrent task execution. Does NOT cover threading, multiprocessing, or third-party async libraries like trio or anyio.",
    "expected_see_also": [
      "technical_skills/programming/languages/python/threading",
      "technical_skills/programming/languages/python/multiprocessing"
    ]
  },
  {
    "task_description": "Create a skill for building REST APIs with FastAPI framework including routing, validation, and dependency injection",
    "expected_taxonomy_path": "technical_skills/programming/web_frameworks/python/fastapi",
    "expected_name": "python-fastapi",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "route_definition",
      "request_validation",
      "response_models",
      "dependency_injection",
      "async_endpoints",
      "openapi_documentation"
    ],
    "expected_dependencies": [
      "technical_skills/programming/languages/python",
      "technical_skills/programming/languages/python/asynchronous_programming"
    ],
    "expected_category": "technical_skills/programming/web_frameworks/python",
    "expected_keywords": [
      "fastapi",
      "rest",
      "api",
      "web",
      "python",
      "pydantic",
      "openapi",
      "swagger",
      "async"
    ],
    "expected_scope": "Covers FastAPI framework for building REST APIs including routing, validation with Pydantic, dependency injection, and OpenAPI documentation. Does NOT cover Flask, Django, or frontend development.",
    "expected_see_also": [
      "technical_skills/programming/web_frameworks/python/flask",
      "technical_skills/programming/web_frameworks/python/django"
    ]
  },
  {
    "task_description": "Create a skill for Python decorator patterns and metaprogramming techniques",
    "expected_taxonomy_path": "technical_skills/programming/languages/python/decorators",
    "expected_name": "python-decorators",
    "expected_type": "technical",
    "expected_weight": "lightweight",
    "expected_capabilities": [
      "basic_decorators",
      "parameterized_decorators",
      "class_decorators",
      "functools_wraps",
      "decorator_stacking"
    ],
    "expected_dependencies": ["technical_skills/programming/languages/python"],
    "expected_category": "technical_skills/programming/languages/python",
    "expected_keywords": [
      "decorator",
      "python",
      "metaprogramming",
      "functools",
      "wrapper",
      "annotation"
    ],
    "expected_scope": "Covers Python decorator patterns including function decorators, class decorators, parameterized decorators, and functools utilities. Does NOT cover metaclasses or advanced descriptor protocols.",
    "expected_see_also": [
      "technical_skills/programming/languages/python/metaclasses",
      "technical_skills/programming/languages/python/descriptors"
    ]
  },
  {
    "task_description": "Create a skill for Git version control workflows including branching, merging, and rebasing strategies",
    "expected_taxonomy_path": "tool_proficiency/version_control/git",
    "expected_name": "git-workflows",
    "expected_type": "tool",
    "expected_weight": "medium",
    "expected_capabilities": [
      "branching_strategies",
      "merge_workflows",
      "rebase_techniques",
      "conflict_resolution",
      "history_management",
      "git_hooks"
    ],
    "expected_dependencies": [],
    "expected_category": "tool_proficiency/version_control",
    "expected_keywords": [
      "git",
      "version-control",
      "branching",
      "merge",
      "rebase",
      "github",
      "gitlab",
      "vcs"
    ],
    "expected_scope": "Covers Git version control including branching strategies (GitFlow, trunk-based), merging, rebasing, conflict resolution, and hooks. Does NOT cover other VCS systems like SVN or Mercurial.",
    "expected_see_also": [
      "tool_proficiency/version_control/github",
      "tool_proficiency/ci_cd/github_actions"
    ]
  },
  {
    "task_description": "Create a skill for debugging Python applications using pdb, logging, and profiling tools",
    "expected_taxonomy_path": "task_focus_areas/debug_fix/python_debugging",
    "expected_name": "python-debugging",
    "expected_type": "task_focus",
    "expected_weight": "medium",
    "expected_capabilities": [
      "pdb_debugging",
      "logging_configuration",
      "stack_trace_analysis",
      "profiling",
      "memory_debugging"
    ],
    "expected_dependencies": ["technical_skills/programming/languages/python"],
    "expected_category": "task_focus_areas/debug_fix",
    "expected_keywords": [
      "debug",
      "pdb",
      "logging",
      "profiling",
      "python",
      "traceback",
      "breakpoint",
      "memory"
    ],
    "expected_scope": "Covers Python debugging with pdb, logging configuration, stack trace analysis, CPU/memory profiling. Does NOT cover IDE-specific debuggers or production monitoring tools.",
    "expected_see_also": [
      "task_focus_areas/debug_fix/general_debugging",
      "tool_proficiency/monitoring/python_apm"
    ]
  },
  {
    "task_description": "Create a skill for writing effective unit tests with pytest including fixtures, mocking, and parametrization",
    "expected_taxonomy_path": "technical_skills/programming/testing/python/pytest",
    "expected_name": "python-pytest",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "test_organization",
      "fixtures",
      "parametrization",
      "mocking",
      "assertions",
      "test_coverage"
    ],
    "expected_dependencies": ["technical_skills/programming/languages/python"],
    "expected_category": "technical_skills/programming/testing/python",
    "expected_keywords": [
      "pytest",
      "testing",
      "unit-test",
      "fixtures",
      "mocking",
      "tdd",
      "python",
      "coverage"
    ],
    "expected_scope": "Covers pytest framework including fixtures, parametrization, mocking with pytest-mock, and coverage reporting. Does NOT cover unittest, nose, or integration/e2e testing frameworks.",
    "expected_see_also": [
      "technical_skills/programming/testing/python/unittest",
      "technical_skills/programming/testing/integration"
    ]
  },
  {
    "task_description": "Create a skill for Docker containerization including Dockerfile writing, image optimization, and multi-stage builds",
    "expected_taxonomy_path": "tool_proficiency/containerization/docker",
    "expected_name": "docker-basics",
    "expected_type": "tool",
    "expected_weight": "medium",
    "expected_capabilities": [
      "dockerfile_creation",
      "image_optimization",
      "multi_stage_builds",
      "volume_management",
      "network_configuration",
      "docker_compose"
    ],
    "expected_dependencies": [],
    "expected_category": "tool_proficiency/containerization",
    "expected_keywords": [
      "docker",
      "container",
      "dockerfile",
      "image",
      "compose",
      "devops",
      "deployment"
    ],
    "expected_scope": "Covers Docker containerization including Dockerfile creation, image optimization, multi-stage builds, volumes, networks, and Docker Compose. Does NOT cover Kubernetes, Podman, or container orchestration.",
    "expected_see_also": [
      "tool_proficiency/containerization/kubernetes",
      "tool_proficiency/containerization/podman"
    ]
  },
  {
    "task_description": "Create a skill for SQL database design and query optimization",
    "expected_taxonomy_path": "technical_skills/data_engineering/databases/sql",
    "expected_name": "sql-fundamentals",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "schema_design",
      "query_writing",
      "joins",
      "indexing",
      "query_optimization",
      "transactions"
    ],
    "expected_dependencies": [],
    "expected_category": "technical_skills/data_engineering/databases",
    "expected_keywords": [
      "sql",
      "database",
      "query",
      "schema",
      "joins",
      "indexing",
      "postgresql",
      "mysql"
    ],
    "expected_scope": "Covers SQL fundamentals including schema design, query writing, joins, indexing, optimization, and transactions. Does NOT cover NoSQL databases, ORMs, or database administration.",
    "expected_see_also": [
      "technical_skills/data_engineering/databases/nosql",
      "technical_skills/data_engineering/databases/orm"
    ]
  },
  {
    "task_description": "Create a skill for TypeScript type system including generics, utility types, and type guards",
    "expected_taxonomy_path": "technical_skills/programming/languages/typescript/type_system",
    "expected_name": "typescript-types",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "basic_types",
      "interfaces",
      "generics",
      "utility_types",
      "type_guards",
      "conditional_types"
    ],
    "expected_dependencies": [
      "technical_skills/programming/languages/javascript"
    ],
    "expected_category": "technical_skills/programming/languages/typescript",
    "expected_keywords": [
      "typescript",
      "types",
      "generics",
      "interfaces",
      "type-guards",
      "javascript",
      "static-typing"
    ],
    "expected_scope": "Covers TypeScript type system including basic types, interfaces, generics, utility types, type guards, and conditional types. Does NOT cover TypeScript runtime, build tools, or framework-specific typing.",
    "expected_see_also": [
      "technical_skills/programming/languages/javascript",
      "technical_skills/programming/languages/typescript/compiler"
    ]
  },
  {
    "task_description": "Create a skill for code review best practices including review checklists, feedback patterns, and common issues",
    "expected_taxonomy_path": "task_focus_areas/code_quality/code_review",
    "expected_name": "code-review",
    "expected_type": "task_focus",
    "expected_weight": "lightweight",
    "expected_capabilities": [
      "review_checklists",
      "feedback_patterns",
      "common_issues",
      "security_review",
      "performance_review"
    ],
    "expected_dependencies": [],
    "expected_category": "task_focus_areas/code_quality",
    "expected_keywords": [
      "code-review",
      "pull-request",
      "feedback",
      "quality",
      "checklist",
      "best-practices"
    ],
    "expected_scope": "Covers code review best practices including checklists, constructive feedback patterns, common issues to look for, security and performance review. Does NOT cover automated code analysis tools or CI/CD integration.",
    "expected_see_also": [
      "task_focus_areas/code_quality/static_analysis",
      "task_focus_areas/code_quality/linting"
    ]
  },
  {
    "task_description": "Create a skill for Kubernetes pod management including deployments, services, ConfigMaps, and secrets",
    "expected_taxonomy_path": "tool_proficiency/containerization/kubernetes/core_concepts",
    "expected_name": "kubernetes-core",
    "expected_type": "tool",
    "expected_weight": "heavy",
    "expected_capabilities": [
      "pod_management",
      "deployment_configuration",
      "service_networking",
      "configmap_secrets",
      "resource_limits",
      "health_checks"
    ],
    "expected_dependencies": ["tool_proficiency/containerization/docker"],
    "expected_category": "tool_proficiency/containerization/kubernetes",
    "expected_keywords": [
      "kubernetes",
      "k8s",
      "pods",
      "deployment",
      "service",
      "configmap"
    ],
    "expected_scope": "Covers Kubernetes core concepts. Does NOT cover Helm or service mesh.",
    "expected_see_also": ["tool_proficiency/containerization/docker"]
  },
  {
    "task_description": "Create a skill for GitHub Actions CI/CD workflows including jobs, matrix builds, and secrets management",
    "expected_taxonomy_path": "tool_proficiency/ci_cd/github_actions",
    "expected_name": "github-actions-ci",
    "expected_type": "tool",
    "expected_weight": "medium",
    "expected_capabilities": [
      "workflow_syntax",
      "job_configuration",
      "matrix_builds",
      "secrets_management",
      "artifact_handling",
      "reusable_workflows"
    ],
    "expected_dependencies": ["tool_proficiency/version_control/git"],
    "expected_category": "tool_proficiency/ci_cd",
    "expected_keywords": [
      "github-actions",
      "ci-cd",
      "workflow",
      "pipeline",
      "automation"
    ],
    "expected_scope": "Covers GitHub Actions CI/CD. Does NOT cover Jenkins or CircleCI.",
    "expected_see_also": ["tool_proficiency/version_control/github"]
  },
  {
    "task_description": "Create a skill for React hooks including useState, useEffect, useContext, and custom hooks",
    "expected_taxonomy_path": "technical_skills/programming/web_frameworks/javascript/react/hooks",
    "expected_name": "react-hooks",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "state_hooks",
      "effect_hooks",
      "context_hooks",
      "reducer_hooks",
      "custom_hooks",
      "hook_rules"
    ],
    "expected_dependencies": [
      "technical_skills/programming/languages/javascript"
    ],
    "expected_category": "technical_skills/programming/web_frameworks/javascript/react",
    "expected_keywords": [
      "react",
      "hooks",
      "useState",
      "useEffect",
      "frontend"
    ],
    "expected_scope": "Covers React hooks. Does NOT cover class components or Redux.",
    "expected_see_also": ["technical_skills/programming/languages/javascript"]
  },
  {
    "task_description": "Create a skill for AWS Lambda serverless functions including triggers, layers, and cold start optimization",
    "expected_taxonomy_path": "technical_skills/infrastructure/cloud/aws/lambda",
    "expected_name": "aws-lambda",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "function_creation",
      "trigger_configuration",
      "layer_management",
      "environment_variables",
      "cold_start_optimization",
      "logging_monitoring"
    ],
    "expected_dependencies": [],
    "expected_category": "technical_skills/infrastructure/cloud/aws",
    "expected_keywords": ["aws", "lambda", "serverless", "faas", "cloud"],
    "expected_scope": "Covers AWS Lambda. Does NOT cover EC2 or ECS.",
    "expected_see_also": [
      "technical_skills/infrastructure/cloud/azure/functions"
    ]
  },
  {
    "task_description": "Create a skill for Terraform infrastructure as code including modules, state management, and providers",
    "expected_taxonomy_path": "tool_proficiency/infrastructure_as_code/terraform",
    "expected_name": "terraform-basics",
    "expected_type": "tool",
    "expected_weight": "heavy",
    "expected_capabilities": [
      "provider_configuration",
      "resource_definition",
      "module_creation",
      "state_management",
      "workspace_management",
      "plan_apply_workflow"
    ],
    "expected_dependencies": [],
    "expected_category": "tool_proficiency/infrastructure_as_code",
    "expected_keywords": [
      "terraform",
      "iac",
      "infrastructure",
      "hcl",
      "modules"
    ],
    "expected_scope": "Covers Terraform basics. Does NOT cover Pulumi or CloudFormation.",
    "expected_see_also": ["tool_proficiency/infrastructure_as_code/pulumi"]
  },
  {
    "task_description": "Create a skill for Go error handling patterns including wrapping, sentinel errors, and custom error types",
    "expected_taxonomy_path": "technical_skills/programming/languages/go/error_handling",
    "expected_name": "go-errors",
    "expected_type": "technical",
    "expected_weight": "lightweight",
    "expected_capabilities": [
      "error_wrapping",
      "sentinel_errors",
      "custom_error_types",
      "error_inspection",
      "panic_recover",
      "error_formatting"
    ],
    "expected_dependencies": ["technical_skills/programming/languages/go"],
    "expected_category": "technical_skills/programming/languages/go",
    "expected_keywords": ["go", "golang", "errors", "error-handling", "panic"],
    "expected_scope": "Covers Go error handling. Does NOT cover logging frameworks.",
    "expected_see_also": [
      "technical_skills/programming/languages/go/concurrency"
    ]
  },
  {
    "task_description": "Create a skill for prompt engineering techniques including chain-of-thought, few-shot learning, and system prompts",
    "expected_taxonomy_path": "cognitive_skills/reasoning/prompt_engineering",
    "expected_name": "prompt-engineering",
    "expected_type": "cognitive",
    "expected_weight": "medium",
    "expected_capabilities": [
      "chain_of_thought",
      "few_shot_learning",
      "system_prompts",
      "output_formatting",
      "role_playing",
      "prompt_chaining"
    ],
    "expected_dependencies": [],
    "expected_category": "cognitive_skills/reasoning",
    "expected_keywords": [
      "prompt",
      "llm",
      "ai",
      "chain-of-thought",
      "few-shot"
    ],
    "expected_scope": "Covers prompt engineering. Does NOT cover fine-tuning or RAG.",
    "expected_see_also": ["cognitive_skills/reasoning/task_decomposition"]
  },
  {
    "task_description": "Create a skill for JWT authentication including token creation, validation, and refresh token flows",
    "expected_taxonomy_path": "technical_skills/security/authentication/jwt",
    "expected_name": "jwt-auth",
    "expected_type": "technical",
    "expected_weight": "lightweight",
    "expected_capabilities": [
      "token_creation",
      "token_validation",
      "refresh_tokens",
      "claims_management",
      "security_practices",
      "token_storage"
    ],
    "expected_dependencies": [],
    "expected_category": "technical_skills/security/authentication",
    "expected_keywords": ["jwt", "authentication", "token", "auth", "security"],
    "expected_scope": "Covers JWT authentication. Does NOT cover OAuth2 or SAML.",
    "expected_see_also": ["technical_skills/security/authentication/oauth2"]
  },
  {
    "task_description": "Create a skill for GraphQL API design including schemas, resolvers, and subscriptions",
    "expected_taxonomy_path": "technical_skills/apis_integration/graphql",
    "expected_name": "graphql-design",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "schema_design",
      "resolver_implementation",
      "mutations",
      "subscriptions",
      "error_handling",
      "pagination"
    ],
    "expected_dependencies": [],
    "expected_category": "technical_skills/apis_integration",
    "expected_keywords": ["graphql", "api", "schema", "resolver", "apollo"],
    "expected_scope": "Covers GraphQL API design. Does NOT cover REST or gRPC.",
    "expected_see_also": ["technical_skills/apis_integration/rest"]
  },
  {
    "task_description": "Create a skill for Redis caching strategies including TTL, eviction policies, and pub/sub",
    "expected_taxonomy_path": "technical_skills/data_engineering/databases/redis",
    "expected_name": "redis-caching",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "data_structures",
      "ttl_management",
      "eviction_policies",
      "pub_sub",
      "transactions",
      "clustering"
    ],
    "expected_dependencies": [],
    "expected_category": "technical_skills/data_engineering/databases",
    "expected_keywords": ["redis", "cache", "caching", "pub-sub", "key-value"],
    "expected_scope": "Covers Redis caching. Does NOT cover Memcached or CDNs.",
    "expected_see_also": ["technical_skills/data_engineering/databases/sql"]
  },
  {
    "task_description": "Create a skill for technical documentation writing including ADRs, READMEs, and API documentation",
    "expected_taxonomy_path": "task_focus_areas/documentation/technical_writing",
    "expected_name": "technical-docs",
    "expected_type": "task_focus",
    "expected_weight": "lightweight",
    "expected_capabilities": [
      "readme_writing",
      "adr_creation",
      "api_documentation",
      "runbook_writing",
      "code_comments",
      "diagrams"
    ],
    "expected_dependencies": [],
    "expected_category": "task_focus_areas/documentation",
    "expected_keywords": [
      "documentation",
      "readme",
      "adr",
      "api-docs",
      "markdown"
    ],
    "expected_scope": "Covers technical documentation. Does NOT cover user-facing docs.",
    "expected_see_also": ["task_focus_areas/code_quality/code_review"]
  },
  {
    "task_description": "Create a skill for CSS Flexbox and Grid layout including responsive design patterns",
    "expected_taxonomy_path": "technical_skills/programming/web_development/css/layout",
    "expected_name": "css-layout",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "flexbox_layout",
      "grid_layout",
      "responsive_design",
      "media_queries",
      "container_queries",
      "layout_patterns"
    ],
    "expected_dependencies": [],
    "expected_category": "technical_skills/programming/web_development/css",
    "expected_keywords": ["css", "flexbox", "grid", "layout", "responsive"],
    "expected_scope": "Covers CSS layout. Does NOT cover CSS frameworks or preprocessors.",
    "expected_see_also": ["technical_skills/programming/web_development/html"]
  },
  {
    "task_description": "Create a skill for microservices architecture patterns including service discovery, circuit breakers, and saga patterns",
    "expected_taxonomy_path": "technical_skills/software_architecture/microservices",
    "expected_name": "microservices-patterns",
    "expected_type": "technical",
    "expected_weight": "heavy",
    "expected_capabilities": [
      "service_discovery",
      "circuit_breakers",
      "saga_patterns",
      "api_gateway",
      "event_sourcing",
      "service_mesh"
    ],
    "expected_dependencies": [],
    "expected_category": "technical_skills/software_architecture",
    "expected_keywords": [
      "microservices",
      "architecture",
      "distributed",
      "saga",
      "circuit-breaker"
    ],
    "expected_scope": "Covers microservices patterns. Does NOT cover monolith architecture.",
    "expected_see_also": ["technical_skills/software_architecture/event_driven"]
  },
  {
    "task_description": "Create a skill for MCP server implementation including tool definitions, resource handling, and transport protocols",
    "expected_taxonomy_path": "mcp_capabilities/server_development",
    "expected_name": "mcp-server-dev",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "tool_definitions",
      "resource_handling",
      "transport_protocols",
      "server_lifecycle",
      "error_handling",
      "capability_negotiation"
    ],
    "expected_dependencies": [],
    "expected_category": "mcp_capabilities",
    "expected_keywords": [
      "mcp",
      "model-context-protocol",
      "server",
      "tools",
      "resources"
    ],
    "expected_scope": "Covers MCP server implementation. Does NOT cover MCP clients.",
    "expected_see_also": ["mcp_capabilities/client_development"]
  },
  {
    "task_description": "Create a skill for problem decomposition and task planning for complex multi-step problems",
    "expected_taxonomy_path": "cognitive_skills/planning/task_decomposition",
    "expected_name": "task-planning",
    "expected_type": "cognitive",
    "expected_weight": "lightweight",
    "expected_capabilities": [
      "problem_analysis",
      "subtask_identification",
      "dependency_mapping",
      "prioritization",
      "milestone_definition",
      "risk_assessment"
    ],
    "expected_dependencies": [],
    "expected_category": "cognitive_skills/planning",
    "expected_keywords": [
      "planning",
      "decomposition",
      "task-breakdown",
      "problem-solving"
    ],
    "expected_scope": "Covers problem decomposition. Does NOT cover project management tools.",
    "expected_see_also": ["cognitive_skills/reasoning/prompt_engineering"]
  }
]


============================================================
END FILE: src/skill_fleet/config/training/trainset.json
============================================================

============================================================
FILE: src/skill_fleet/core/__init__.py
============================================================

"""
Unified core logic for Skill Fleet.

This module consolidates the workflow and core packages into a unified architecture.

Directory Structure:
- signatures/: DSPy signature definitions
- modules/: DSPy module implementations
- workflows/: Workflow orchestration layer
- hitl/: Human-in-the-loop handlers
- tools/: External tools and integrations
- optimization/: Optimization and evaluation logic
- tracing/: Tracing infrastructure
- config.py: Configuration validation with Pydantic
- models.py: Unified data models
- creator.py: Main entry point for skill creation

Import Guidelines:
- For config: from skill_fleet.core.config import ...
- For models: from skill_fleet.core.models import ...
- For DSPy components: from skill_fleet.dspy import ...
- For HITL: from skill_fleet.core.hitl import ...
- For workflows: from skill_fleet.core.workflows import ...
"""

from skill_fleet.core.config import (
    FleetConfig,
    LegacyAliases,
    ModelConfig,
    ModelParameters,
    ModelsConfig,
    ModelType,
    ReasoningEffort,
    RoleConfig,
    RolesConfig,
    TaskConfig,
    TasksConfig,
    load_config,
    validate_config,
)
from skill_fleet.core.models import (
    # Edit
    BestPractice,
    # Skill Structure
    Capability,
    CapabilityImplementation,
    # Agent
    ChecklistState,
    # HITL Models
    ClarifyingQuestion,
    CompatibilityConstraints,
    # Understanding
    DependencyAnalysis,
    DependencyRef,
    EditResult,
    # Iterate
    EvolutionMetadata,
    # Example Gathering
    ExampleGatheringConfig,
    ExampleGatheringResult,
    ExampleGatheringSession,
    # Initialize
    FileSpec,
    HITLRound,
    HITLSession,
    InitializeResult,
    IterateResult,
    # Package
    PackageResult,
    PackagingManifest,
    ParentSkillInfo,
    PlanResult,
    QuestionAnswer,
    QuestionOption,
    # Composite Results
    QuickSkillResult,
    ResourceRequirements,
    RevisionPlan,
    SkillCreationResult,
    SkillMetadata,
    SkillRevisionResult,
    SkillSkeleton,
    TaskIntent,
    TestCase,
    UnderstandingResult,
    UsageExample,
    UserExample,
    ValidationCheckItem,
    ValidationReport,
)

__all__ = [
    # Configuration
    "load_config",
    "validate_config",
    "FleetConfig",
    "ModelType",
    "ReasoningEffort",
    "ModelParameters",
    "ModelConfig",
    "ModelsConfig",
    "RoleConfig",
    "RolesConfig",
    "TaskConfig",
    "TasksConfig",
    "LegacyAliases",
    # HITL Models
    "QuestionOption",
    "ClarifyingQuestion",
    "QuestionAnswer",
    "HITLRound",
    "HITLSession",
    # Example Gathering
    "UserExample",
    "ExampleGatheringConfig",
    "ExampleGatheringSession",
    "ExampleGatheringResult",
    # Understanding
    "TaskIntent",
    "DependencyRef",
    "DependencyAnalysis",
    "ParentSkillInfo",
    "UnderstandingResult",
    # Skill Structure
    "SkillMetadata",
    "Capability",
    "ResourceRequirements",
    "CompatibilityConstraints",
    "PlanResult",
    # Initialize
    "FileSpec",
    "SkillSkeleton",
    "ValidationCheckItem",
    "InitializeResult",
    # Edit
    "UsageExample",
    "BestPractice",
    "CapabilityImplementation",
    "EditResult",
    # Package
    "ValidationReport",
    "TestCase",
    "PackagingManifest",
    "PackageResult",
    # Iterate
    "RevisionPlan",
    "EvolutionMetadata",
    "IterateResult",
    # Composite Results
    "SkillCreationResult",
    "SkillRevisionResult",
    "QuickSkillResult",
    # Agent
    "ChecklistState",
]


============================================================
END FILE: src/skill_fleet/core/__init__.py
============================================================

============================================================
FILE: src/skill_fleet/core/config.py
============================================================

"""
Configuration validation using Pydantic.

This module provides runtime validation for the Skills Fleet configuration,
ensuring type safety and catching configuration errors early.
"""

from __future__ import annotations

import os
from enum import StrEnum
from pathlib import Path
from typing import Any

import yaml
from pydantic import BaseModel, Field, field_validator, model_validator

# =============================================================================
# Configuration Models
# =============================================================================


