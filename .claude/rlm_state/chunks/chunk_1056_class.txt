<!-- Chunk 1056: bytes 3781944-3792247, type=class -->
class TaxonomyManager:
    """Manages skill taxonomy structure and operations."""
    
    def __init__(self, skills_root: Path):
        self.skills_root = Path(skills_root)
        self.meta_path = self.skills_root / "taxonomy_meta.json"
        self.metadata_cache: Dict[str, SkillMetadata] = {}
        self.load_taxonomy_meta()
        self._load_core_skills()
    
    def load_taxonomy_meta(self) -> Dict:
        """Load taxonomy metadata."""
        if not self.meta_path.exists():
            raise FileNotFoundError(f"Taxonomy metadata not found: {self.meta_path}")
        
        with open(self.meta_path, 'r') as f:
            self.meta = json.load(f)
        return self.meta
    
    def _load_core_skills(self):
        """Load always-available core skills."""
        core_dir = self.skills_root / "_core"
        for skill_file in core_dir.glob("*.json"):
            with open(skill_file, 'r') as f:
                skill_data = json.load(f)
                skill_id = skill_data['skill_id']
                self.metadata_cache[skill_id] = SkillMetadata(
                    skill_id=skill_id,
                    version=skill_data['version'],
                    type=skill_data['type'],
                    weight=skill_data['weight'],
                    load_priority=skill_data['load_priority'],
                    dependencies=skill_data['dependencies'],
                    capabilities=skill_data['capabilities'],
                    path=skill_file,
                    always_loaded=skill_data.get('always_loaded', False)
                )
    
    def skill_exists(self, taxonomy_path: str) -> bool:
        """Check if skill exists at given taxonomy path."""
        skill_dir = self.skills_root / taxonomy_path
        return (skill_dir / "metadata.json").exists()
    
    def get_skill_metadata(self, skill_id: str) -> Optional[SkillMetadata]:
        """Retrieve skill metadata."""
        return self.metadata_cache.get(skill_id)
    
    def get_mounted_skills(self, user_id: str) -> List[str]:
        """Get currently mounted skills for a user."""
        # TODO: Implement user session management
        # For now, return core skills
        return [s for s, m in self.metadata_cache.items() if m.always_loaded]
    
    def get_relevant_branches(self, task_description: str) -> Dict:
        """Get relevant taxonomy branches for a task.
        
        Returns subset of taxonomy structure based on task keywords.
        """
        # Simple keyword matching for now
        # TODO: Implement semantic matching
        branches = {}
        
        keywords = task_description.lower().split()
        
        if any(k in keywords for k in ['code', 'program', 'develop', 'script']):
            branches['technical_skills/programming'] = self._get_branch_structure('technical_skills/programming')
        
        if any(k in keywords for k in ['data', 'analyze', 'statistics']):
            branches['domain_knowledge/data_science'] = self._get_branch_structure('domain_knowledge')
        
        if any(k in keywords for k in ['debug', 'fix', 'error']):
            branches['task_focus_areas/debug_fix'] = self._get_branch_structure('task_focus_areas')
        
        return branches
    
    def _get_branch_structure(self, branch_path: str) -> Dict:
        """Get directory structure of a taxonomy branch."""
        full_path = self.skills_root / branch_path
        if not full_path.exists():
            return {}
        
        structure = {}
        for item in full_path.iterdir():
            if item.is_dir() and not item.name.startswith('_'):
                structure[item.name] = "available"
        return structure
    
    def get_parent_skills(self, taxonomy_path: str) -> List[Dict]:
        """Get parent and sibling skills for context."""
        path_parts = taxonomy_path.split('/')
        parent_skills = []
        
        # Walk up the tree
        for i in range(len(path_parts) - 1, 0, -1):
            parent_path = '/'.join(path_parts[:i])
            parent_dir = self.skills_root / parent_path
            
            if (parent_dir / "metadata.json").exists():
                with open(parent_dir / "metadata.json", 'r') as f:
                    parent_skills.append({
                        "path": parent_path,
                        "metadata": json.load(f)
                    })
        
        return parent_skills
    
    def register_skill(
        self, 
        path: str, 
        metadata: Dict, 
        content: str,
        evolution: Dict
    ) -> bool:
        """Register a new skill in the taxonomy."""
        skill_dir = self.skills_root / path
        skill_dir.mkdir(parents=True, exist_ok=True)
        
        # Write metadata
        metadata_path = skill_dir / "metadata.json"
        metadata['created_at'] = datetime.utcnow().isoformat()
        metadata['last_modified'] = datetime.utcnow().isoformat()
        metadata['evolution'] = evolution
        
        with open(metadata_path, 'w') as f:
            json.dump(metadata, f, indent=2)
        
        # Write main content
        skill_md_path = skill_dir / "SKILL.md"
        with open(skill_md_path, 'w') as f:
            f.write(content)
        
        # Create subdirectories
        (skill_dir / "capabilities").mkdir(exist_ok=True)
        (skill_dir / "examples").mkdir(exist_ok=True)
        (skill_dir / "tests").mkdir(exist_ok=True)
        (skill_dir / "resources").mkdir(exist_ok=True)
        
        # Update cache
        skill_id = metadata['skill_id']
        self.metadata_cache[skill_id] = SkillMetadata(
            skill_id=skill_id,
            version=metadata['version'],
            type=metadata['type'],
            weight=metadata['weight'],
            load_priority=metadata['load_priority'],
            dependencies=metadata['dependencies'],
            capabilities=metadata['capabilities'],
            path=metadata_path
        )
        
        # Update taxonomy meta
        self._update_taxonomy_stats(metadata)
        
        return True
    
    def _update_taxonomy_stats(self, metadata: Dict):
        """Update taxonomy statistics."""
        self.meta['total_skills'] += 1
        self.meta['generation_count'] += 1
        self.meta['last_updated'] = datetime.utcnow().isoformat()
        
        # Update type statistics
        skill_type = metadata['type']
        if 'by_type' not in self.meta['statistics']:
            self.meta['statistics']['by_type'] = {}
        self.meta['statistics']['by_type'][skill_type] = \
            self.meta['statistics']['by_type'].get(skill_type, 0) + 1
        
        # Save updated meta
        with open(self.meta_path, 'w') as f:
            json.dump(self.meta, f, indent=2)
    
    def validate_dependencies(self, dependencies: List[str]) -> tuple[bool, List[str]]:
        """Validate that all dependencies can be resolved."""
        missing = []
        for dep_id in dependencies:
            if dep_id not in self.metadata_cache:
                # Check if it exists on disk but not loaded
                # For now, simple check
                missing.append(dep_id)
        
        return len(missing) == 0, missing
    
    def detect_circular_dependencies(
        self, 
        skill_id: str, 
        dependencies: List[str],
        visited: Optional[Set[str]] = None
    ) -> tuple[bool, Optional[List[str]]]:
        """Detect circular dependency chains."""
        if visited is None:
            visited = set()
        
        if skill_id in visited:
            return True, list(visited) + [skill_id]
        
        visited.add(skill_id)
        
        for dep_id in dependencies:
            dep_meta = self.get_skill_metadata(dep_id)
            if dep_meta:
                has_cycle, cycle_path = self.detect_circular_dependencies(
                    dep_id,
                    dep_meta.dependencies,
                    visited.copy()
                )
                if has_cycle:
                    return True, cycle_path
        
        return False, None
```

### Day 6-7: Skill Templates

**File: skills/_templates/skill_template.json**
```json
{
  "metadata_template": {
    "skill_id": "{{taxonomy_path}}",
    "version": "1.0.0",
    "type": "{{type}}",
    "weight": "{{weight}}",
    "load_priority": "{{priority}}",
    "dependencies": [],
    "capabilities": [],
    "tags": [],
    "created_at": "{{timestamp}}",
    "last_modified": "{{timestamp}}",
    "generation_reason": "{{reason}}",
    "usage_count": 0,
    "success_rate": 0.0
  },
  "directory_structure": [
    "capabilities/",
    "examples/",
    "tests/",
    "resources/"
  ],
  "required_files": [
    "metadata.json",
    "SKILL.md"
  ]
}
```

**File: config/templates/SKILL_md_template.md**
```markdown
# {{skill_name}}

**Skill ID**: `{{skill_id}}`  
**Version**: {{version}}  
**Type**: {{type}}  
**Weight**: {{weight}}

## Overview

{{overview_description}}

## Capabilities

{{#each capabilities}}
### {{name}}

{{description}}

**Usage:**
```
{{usage_example}}
```
{{/each}}

## Dependencies

{{#if dependencies}}
This skill requires the following skills to be mounted:
{{#each dependencies}}
- `{{this}}` - {{reason}}
{{/each}}
{{else}}
No dependencies - this skill is self-contained.
{{/if}}

## Usage Examples

### Example 1: {{example_1_title}}

```{{example_1_language}}
{{example_1_code}}
```

**Expected Output:**
```
{{example_1_output}}
```

## Best Practices

{{#each best_practices}}
- {{this}}
{{/each}}

## Common Pitfalls

{{#each pitfalls}}
- **{{name}}**: {{description}}
{{/each}}

## Integration Notes

### Composition Patterns

{{composition_notes}}

### Performance Considerations

{{performance_notes}}

## Testing

See `tests/` directory for validation test suite.

## Resources

{{#if external_resources}}
Additional resources required:
{{#each external_resources}}
- {{this}}
{{/each}}
{{/if}}

## Version History

- **1.0.0** ({{created_at}}): Initial generation - {{generation_reason}}

## Metadata

```json
{{metadata_json}}
```
```

## Week 2: DSPy Workflow Implementation

### Day 8-9: DSPy Signatures

**File: src/workflow/signatures.py**
```python
"""DSPy signatures for skill creation workflow."""
import dspy
from typing import List, Dict, Optional

