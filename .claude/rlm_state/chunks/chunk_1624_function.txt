<!-- Chunk 1624: bytes 6662214-6664051, type=function -->
def run_async[T](factory: Callable[[], Awaitable[T]]) -> T:
    """
    Run an async callable from synchronous code.

    This is intended for sync wrappers like `forward()` that need to call an
    async implementation like `aforward()`.
    """
    try:
        asyncio.get_running_loop()
    except RuntimeError:
        return asyncio.run(factory())  # type: ignore[invalid-argument-type]

    result_queue: queue.Queue[tuple[bool, T | BaseException]] = queue.Queue(maxsize=1)

    def _runner() -> None:
        try:
            result_queue.put((True, asyncio.run(factory())))  # type: ignore[invalid-argument-type]
        except BaseException as exc:
            result_queue.put((False, exc))

    thread = threading.Thread(target=_runner, daemon=True)
    thread.start()
    ok, payload = result_queue.get()
    thread.join()

    if ok:
        return payload  # type: ignore[invalid-return-type]
    raise payload  # type: ignore[invalid-raise]


============================================================
END FILE: src/skill_fleet/common/async_utils.py
============================================================

============================================================
FILE: src/skill_fleet/common/dspy_compat.py
============================================================

"""DSPy backward compatibility utilities."""

from typing import Any

import dspy

if hasattr(dspy, "Reasoning"):
    Reasoning = dspy.Reasoning
else:

    class Reasoning(str):
        """Compatibility wrapper for reasoning."""

        content: str | None = None

        def __new__(cls, content: str | None = None, **kwargs):
            """Create a new Reasoning instance."""
            return super().__new__(cls, content or "")

        def __init__(self, content: str | None = None, **kwargs):
            self.content = content


