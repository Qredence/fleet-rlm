<!-- Chunk 1810: bytes 7547123-7550491, type=class -->
class ConversationSession:
    """Manages conversation session state."""

    # Message history
    messages: list[dict[str, Any]] = field(default_factory=list)
    # Collected examples
    collected_examples: list[dict[str, Any]] = field(default_factory=list)
    # Current workflow state
    state: ConversationState = ConversationState.EXPLORING
    # Current task description (refined)
    task_description: str = ""
    # Multi-skill queue (if multiple skills needed)
    multi_skill_queue: list[str] = field(default_factory=list)
    current_skill_index: int = 0
    # Skill draft (if in progress)
    skill_draft: dict[str, Any] | None = None
    # Checklist state
    checklist_state: ChecklistState = field(default_factory=ChecklistState)
    # Confirmation pending (if waiting for user confirmation)
    pending_confirmation: dict[str, Any] | None = None
    # Taxonomy path (proposed)
    taxonomy_path: str = ""
    # Skill metadata draft
    skill_metadata_draft: dict[str, Any] | None = None
    # Deep understanding phase state
    deep_understanding: dict[str, Any] | None = None
    user_problem: str | None = None
    user_goals: list[str] | None = None
    research_context: dict[str, Any] | None = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize session to dict for persistence."""
        return {
            "messages": self.messages,
            "collected_examples": self.collected_examples,
            "state": self.state.value,
            "task_description": self.task_description,
            "multi_skill_queue": self.multi_skill_queue,
            "current_skill_index": self.current_skill_index,
            "skill_draft": self.skill_draft,
            "checklist_state": self.checklist_state.model_dump(),
            "pending_confirmation": self.pending_confirmation,
            "taxonomy_path": self.taxonomy_path,
            "skill_metadata_draft": self.skill_metadata_draft,
            "deep_understanding": self.deep_understanding,
            "user_problem": self.user_problem,
            "user_goals": self.user_goals,
            "research_context": self.research_context,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> ConversationSession:
        """Deserialize session from dict."""
        session = cls()
        session.messages = data.get("messages", [])
        session.collected_examples = data.get("collected_examples", [])
        session.state = ConversationState(data.get("state", "EXPLORING"))
        session.task_description = data.get("task_description", "")
        session.multi_skill_queue = data.get("multi_skill_queue", [])
        session.current_skill_index = data.get("current_skill_index", 0)
        session.skill_draft = data.get("skill_draft")
        if "checklist_state" in data:
            session.checklist_state = ChecklistState(**data["checklist_state"])
        session.pending_confirmation = data.get("pending_confirmation")
        session.taxonomy_path = data.get("taxonomy_path", "")
        session.skill_metadata_draft = data.get("skill_metadata_draft")
        session.deep_understanding = data.get("deep_understanding")
        session.user_problem = data.get("user_problem")
        session.user_goals = data.get("user_goals")
        session.research_context = data.get("research_context")
        return session


@dataclass
