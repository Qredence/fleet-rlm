<!-- Chunk 716: bytes 1872706-2022706, type=size -->
tion!\n```\n\n**After - Production endpoint:**\n```python\nfrom pydantic import BaseModel, Field, validator\nfrom fastapi import HTTPException\n\nclass CreditCard(BaseModel):\n    number: str = Field(..., min_length=13, max_length=19)\n    expiry: str\n    cvv: str = Field(..., min_length=3, max_length=4)\n\n    @validator('number')\n    def luhn_check(cls, v):\n        if not luhn_valid(v):\n            raise ValueError('Invalid card number')\n        return v\n\nclass PaymentRequest(BaseModel):\n    user_id: int\n    amount: float = Field(..., gt=0)  # Must be positive\n    card: CreditCard\n\nclass PaymentResponse(BaseModel):\n    status: str\n    transaction_id: str\n\n@app.post(\"/payment\", response_model=PaymentResponse)\nasync def payment_endpoint(\n    request: PaymentRequest,\n    db: AsyncSession = Depends(get_db)\n):\n    # Async database call\n    user = await db.get(User, request.user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    if user.balance < request.amount:\n        raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n\n    transaction_id = await process_payment_async(request, db)\n    return PaymentResponse(status=\"success\", transaction_id=transaction_id)\n```\n\n### 4. Sync to Async Conversion\n\n**Sync → Async library mapping:**\n\n| Sync Library   | Async Replacement           |\n|----------------|-----------------------------|\n| `requests`     | `httpx.AsyncClient`         |\n| `sqlalchemy`   | `sqlalchemy.ext.asyncio`    |\n| `time.sleep()` | `asyncio.sleep()`           |\n| `open()`       | `aiofiles`                  |\n| `subprocess`   | `asyncio.create_subprocess` |\n| `redis`        | `aioredis`                  |\n\n**Pattern:**\n```python\n# Before - blocking\ndef get_user_data(user_id: int) -> dict:\n    user = db.session.query(User).filter(User.id == user_id).first()\n    response = requests.get(f\"https://api.external.com/user/{user_id}\")\n    return {\"user\": user, \"external\": response.json()}\n\n# After - async\nasync def get_user_data(user_id: int, db: AsyncSession) -> dict:\n    result = await db.execute(select(User).where(User.id == user_id))\n    user = result.scalar_one_or_none()\n\n    async with httpx.AsyncClient() as client:\n        response = await client.get(f\"https://api.external.com/user/{user_id}\")\n\n    return {\"user\": user, \"external\": response.json()}\n```\n\n### 5. Dependency Injection Patterns\n\n**Caching dependencies:**\n```python\nfrom functools import lru_cache\n\n@lru_cache()\ndef get_settings():\n    return Settings()  # Singleton, created once\n\n@lru_cache()\ndef get_redis_client():\n    return redis.Redis(host=settings.REDIS_HOST)\n```\n\n**Testing with overrides:**\n```python\nfrom fastapi.testclient import TestClient\n\ndef test_update_user():\n    async def override_get_db():\n        return test_session  # Use test DB\n\n    app.dependency_overrides[get_db] = override_get_db\n    try:\n        response = client.patch(\"/users/1\", json={\"name\": \"Test\"})\n    finally:\n        app.dependency_overrides.clear()  # Always clean up\n```\n\n**Yield dependencies for cleanup:**\n```python\nasync def get_db():\n    async with AsyncSession(engine) as session:\n        yield session\n        # Automatic cleanup after response\n```\n\n### 6. Async Testing\n\n**The problem:** Using sync `TestClient` with async endpoints causes hangs. Tests pass in isolation but fail together due to database bleeding.\n\n**✅ Production pattern:**\n```python\nimport pytest\nfrom httpx import AsyncClient\n\n@pytest.fixture\nasync def async_client():\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        yield ac\n\n@pytest.fixture\nasync def db_session():\n    engine = create_async_engine(TEST_DATABASE_URL)\n    async with AsyncSession(engine) as session:\n        yield session\n        await session.rollback()  # Clean up after test\n\n@pytest.mark.asyncio\nasync def test_create_user(async_client: AsyncClient):\n    response = await async_client.post(\"/users\", json={\n        \"name\": \"Alice\",\n        \"email\": \"alice@example.com\"\n    })\n    assert response.status_code == 200\n```\n\n### 7. File Upload Handling\n\n**Stream, don't load entirely:**\n```python\nfrom fastapi import UploadFile\nimport pandas as pd\n\n@app.post(\"/upload-csv\")\nasync def upload_csv(file: UploadFile):\n    # Stream the file - don't load entirely into memory\n    df = pd.read_csv(file.file)\n    results = process_data_frame(df)\n    return {\"uploaded\": len(results), \"data\": results}\n```\n\n### 8. Background Tasks\n\n**For operations longer than HTTP timeout:**\n```python\nfrom fastapi import BackgroundTasks\n\ndef long_running_task(task_id: str):\n    result = process_heavy_computation()\n    mark_task_complete(task_id, result)\n\n@app.post(\"/process\")\nasync def start_process(background_tasks: BackgroundTasks):\n    task_id = generate_task_id()\n    background_tasks.add_task(long_running_task, task_id)\n    return {\"task_id\": task_id, \"status\": \"processing\"}\n\n# For production: Use Celery for retries and distributed execution\n```\n\n### 9. FastAPI CLI (New in 0.128.0)\n\n**The problem:** Running FastAPI apps required manual uvicorn commands. Developers had to remember different commands for development vs production.\n\n**❌ Old approach (still works but not recommended):**\n```bash\n# Development with auto-reload\nuvicorn main:app --reload\n\n# Production\nuvicorn main:app --host 0.0.0.0 --port 8000\n```\n\n**✅ Modern approach with FastAPI CLI:**\n```bash\n# Installation (includes CLI + all standard dependencies)\npip install \"fastapi[standard]\"\n\n# Development with auto-reload\nfastapi dev main.py\n\n# Production\nfastapi run main.py --workers 4\n```\n\n**CLI Command Reference:**\n\n| Command                           | Purpose            | Auto-reload |\n|-----------------------------------|--------------------|-------------|\n| `fastapi dev main.py`             | Development server | ✅ Yes       |\n| `fastapi run main.py`             | Production server  | ❌ No        |\n| `fastapi dev main.py --port 8080` | Custom port        | ✅ Yes       |\n| `fastapi run main.py --workers 4` | Multiple workers   | ❌ No        |\n\n**Key benefits:**\n- Unified CLI for development and production\n- Auto-reload by default in dev mode\n- Includes all standard dependencies (uvicorn, httpx, jinja2, python-multipart)\n- Better error messages and output formatting\n\n> **For comprehensive CLI documentation**, see the [FastAPI CLI capability](capabilities/fastapi-cli.md)\n\n**Installation with all standard dependencies:**\n```bash\npip install \"fastapi[standard]\"\n```\n\nThis installs:\n- `fastapi` - Core framework\n- `uvicorn[standard]` - ASGI server with high-performance dependencies\n- `fastapi-cli[standard]` - CLI tool (includes deployment tools)\n- `httpx` - For testing\n- `jinja2` - For templates\n- `python-multipart` - For form data\n\n**Optional: FastAPI Cloud deployment:**\n```bash\nfastapi login\nfastapi deploy\n```\n\n> **Note:** FastAPI Cloud is optional. You can deploy to any cloud provider (AWS, GCP, Azure, Railway, etc.) using traditional deployment methods.\n\n## Common Mistakes\n\n| Mistake                             | Why It's Wrong                                    | Fix                                            |\n|-------------------------------------|---------------------------------------------------|------------------------------------------------|\n| Creating DB engine at import time   | Connections never close, workers leak connections | Create in `lifespan`, dispose in shutdown      |\n| Using `requests` in async endpoints | Blocks entire event loop                          | Use `httpx.AsyncClient`                        |\n| Forgetting `exclude_unset=True`     | Optional fields become `None` and overwrite data  | Use `exclude_unset=True` for PATCH             |\n| Sync fixtures with async tests      | Tests hang or fail mysteriously                   | Use `@pytest.mark.asyncio` with async fixtures |\n| Global state for dependencies       | Can't test, hard to manage lifecycle              | Use `Depends()` with yield                     |\n| Not setting `pool_recycle`          | Database closes idle connections, causing errors  | Set `pool_recycle=3600` or similar             |\n| Using `run_in_executor` as band-aid | Still blocks threads, doesn't scale               | Proper async conversion                        |\n| Missing `max_overflow` parameter    | Pool can't burst under load, requests queue       | Set `max_overflow=20` or similar               |\n\n## Real-World Impact\n\n- **Connection pool exhaustion** fixed with proper lifecycle management → 50 concurrent requests without errors\n- **Test execution time** reduced 80% with proper async fixtures\n- **API response validation** caught 15% of frontend bugs before deployment\n- **Memory usage** reduced 60% by streaming file uploads instead of loading into memory\n- **\"Too many connections\" DB errors** eliminated with proper shutdown handling\n\n## Red Flags - STOP and Reconsider\n\n- Code that \"works locally\" but you haven't load tested\n- Creating database connections at module level\n- Using `@app.on_event(\"startup\")` (deprecated)\n- Missing shutdown handlers\n- No pool parameters on engine creation\n- Using `requests` library in async functions\n- Tests that only pass when run individually\n- `run_in_executor` as primary async strategy\n\n**All of these mean: Revisit your architecture. Production will break.**\n"
      }
    ],
    "signature": {
      "instructions": "Generate a refinement plan based on validation issues and user feedback.\n\nCreate a structured plan for how to refine the skill to address\nvalidation failures and incorporate user's feedback.",
      "fields": [
        {
          "prefix": "Validation Issues:",
          "description": "JSON list of validation issues"
        },
        {
          "prefix": "User Feedback:",
          "description": "User's feedback on how to address issues (may be empty for auto-fix)"
        },
        {
          "prefix": "Current Skill:",
          "description": "Current skill content"
        },
        {
          "prefix": "Reasoning: Let's think step by step in order to",
          "description": "${reasoning}"
        },
        {
          "prefix": "Refinement Plan:",
          "description": "Step-by-step plan for refining the skill"
        },
        {
          "prefix": "Changes:",
          "description": "Specific changes to make: [{section: '...', change_type: 'add/remove/modify', details: '...'}]"
        },
        {
          "prefix": "Estimated Iterations:",
          "description": "Estimated number of refinement iterations needed (1-3)"
        }
      ]
    },
    "lm": null
  },
  "metadata": {
    "dependency_versions": {
      "python": "3.13",
      "dspy": "3.1.0",
      "cloudpickle": "3.1"
    }
  }
}


============================================================
END FILE: config/optimized/skill_creator_bootstrap_v1.json
============================================================

============================================================
FILE: config/optimized/skill_creator_miprov2.json
============================================================

{
  "gather.gather.predict": {
    "traces": [],
    "train": [],
    "demos": [
      {
        "task_description": "Create a skill for Docker containerization including Dockerfile writing, image optimization, and multi-stage builds",
        "expected_taxonomy_path": "tool_proficiency/containerization/docker",
        "expected_name": "docker-basics",
        "expected_type": "tool",
        "expected_weight": "medium",
        "expected_capabilities": [
          "dockerfile_creation",
          "image_optimization",
          "multi_stage_builds",
          "volume_management",
          "network_configuration",
          "docker_compose"
        ],
        "expected_dependencies": [],
        "expected_category": "tool_proficiency/containerization",
        "expected_keywords": [
          "docker",
          "container",
          "dockerfile",
          "image",
          "compose",
          "devops",
          "deployment"
        ],
        "expected_scope": "Covers Docker containerization including Dockerfile creation, image optimization, multi-stage builds, volumes, networks, and Docker Compose. Does NOT cover Kubernetes, Podman, or container orchestration.",
        "expected_see_also": [
          "tool_proficiency/containerization/kubernetes",
          "tool_proficiency/containerization/podman"
        ]
      },
      {
        "task_description": "Create a Python async programming skill covering asyncio, event loops, coroutines, and concurrent execution patterns",
        "expected_taxonomy_path": "technical_skills/programming/languages/python/asynchronous_programming",
        "expected_name": "python-async",
        "expected_type": "technical",
        "expected_weight": "medium",
        "expected_capabilities": [
          "async_await_syntax",
          "event_loop_management",
          "concurrent_execution",
          "task_creation",
          "exception_handling"
        ],
        "expected_dependencies": [
          "technical_skills/programming/languages/python"
        ],
        "expected_category": "technical_skills/programming/languages/python",
        "expected_keywords": [
          "asyncio",
          "async",
          "await",
          "coroutines",
          "event-loop",
          "concurrent",
          "python",
          "asynchronous"
        ],
        "expected_scope": "Covers Python asyncio library, async/await syntax, event loops, and concurrent task execution. Does NOT cover threading, multiprocessing, or third-party async libraries like trio or anyio.",
        "expected_see_also": [
          "technical_skills/programming/languages/python/threading",
          "technical_skills/programming/languages/python/multiprocessing"
        ]
      },
      {
        "task_description": "Create a skill for code review best practices including review checklists, feedback patterns, and common issues",
        "expected_taxonomy_path": "task_focus_areas/code_quality/code_review",
        "expected_name": "code-review",
        "expected_type": "task_focus",
        "expected_weight": "lightweight",
        "expected_capabilities": [
          "review_checklists",
          "feedback_patterns",
          "common_issues",
          "security_review",
          "performance_review"
        ],
        "expected_dependencies": [],
        "expected_category": "task_focus_areas/code_quality",
        "expected_keywords": [
          "code-review",
          "pull-request",
          "feedback",
          "quality",
          "checklist",
          "best-practices"
        ],
        "expected_scope": "Covers code review best practices including checklists, constructive feedback patterns, common issues to look for, security and performance review. Does NOT cover automated code analysis tools or CI/CD integration.",
        "expected_see_also": [
          "task_focus_areas/code_quality/static_analysis",
          "task_focus_areas/code_quality/linting"
        ]
      },
      {
        "task_description": "Create a skill for AWS Lambda serverless functions including triggers, layers, and cold start optimization",
        "expected_taxonomy_path": "technical_skills/infrastructure/cloud/aws/lambda",
        "expected_name": "aws-lambda",
        "expected_type": "technical",
        "expected_weight": "medium",
        "expected_capabilities": [
          "function_creation",
          "trigger_configuration",
          "layer_management",
          "environment_variables",
          "cold_start_optimization",
          "logging_monitoring"
        ],
        "expected_dependencies": [],
        "expected_category": "technical_skills/infrastructure/cloud/aws",
        "expected_keywords": [
          "aws",
          "lambda",
          "serverless",
          "faas",
          "cloud"
        ],
        "expected_scope": "Covers AWS Lambda. Does NOT cover EC2 or ECS.",
        "expected_see_also": [
          "technical_skills/infrastructure/cloud/azure/functions"
        ]
      }
    ],
    "signature": {
      "instructions": "Act as a Requirement Architect for a high-precision software engineering and DevOps skill taxonomy. Your goal is to lead a discovery session that transforms a vague \"Task Description\" into a concrete set of usage examples and definitions.\n\nFollow these logical steps to generate your output:\n1. **Analyze Coverage:** Evaluate the `task_description` and any `user_responses` against the provided `config`. Determine if you have at least `min_examples` that cover the \"Happy Path,\" \"Edge Cases,\" and \"Error Boundaries.\"\n2. **Extract & Refine:** \n   - Identify any new `UserExample` objects (input vs. expected output) from the latest user message.\n   - Extract \"Terminology Updates\" for any domain-specific jargon, internal tool names, or DevOps concepts mentioned.\n   - Update the `refined_task` to be more technically descriptive based on these new insights.\n3. **Question Strategically:** If the `readiness_score` is below the threshold, generate 1-3 highly specific questions. Focus on \"Trigger Phrases\" (what the user actually says to the AI), specific tool constraints (e.g., \"Which CI/CD provider?\"), and \"Definition of Done.\"\n4. **Evaluate Readiness:** Assign a `readiness_score` (0.0-1.0). A high score (0.8+) requires that the skill's boundaries (inclusions/exclusions) are now unmistakable and the capability requirements are grounded in the `collected_examples`.\n\n**Constraint:** Do not assume defaults. If the user mentions a specific DevOps tool (e.g., Terraform, Kubernetes, Jenkins), tailor your questions and examples to that specific ecosystem.",
      "fields": [
        {
          "prefix": "Task Description:",
          "description": "Initial task description from user"
        },
        {
          "prefix": "User Responses:",
          "description": "JSON list of user responses to previous clarifying questions (empty [] on first call)"
        },
        {
          "prefix": "Collected Examples:",
          "description": "JSON list of UserExample objects collected so far (empty [] on first call)"
        },
        {
          "prefix": "Config:",
          "description": "JSON ExampleGatheringConfig with min_examples, readiness_threshold, max_questions"
        },
        {
          "prefix": "Reasoning: Let's think step by step in order to",
          "description": "${reasoning}"
        },
        {
          "prefix": "Clarifying Questions:",
          "description": "1-3 focused questions to ask the user (fewer is better). Empty list if ready to proceed."
        },
        {
          "prefix": "New Examples:",
          "description": "New examples extracted from user responses (add to collected_examples)"
        },
        {
          "prefix": "Terminology Updates:",
          "description": "Key terms and definitions learned from this round"
        },
        {
          "prefix": "Refined Task:",
          "description": "Updated task description incorporating insights from examples"
        },
        {
          "prefix": "Readiness Score:",
          "description": "0.0-1.0 score. >= threshold means ready to proceed. Based on example coverage, clarity, and edge cases."
        },
        {
          "prefix": "Readiness Reasoning:",
          "description": "Brief explanation of readiness score (why ready or what's missing)"
        }
      ]
    },
    "lm": null
  },
  "understand.understand.predict": {
    "traces": [],
    "train": [],
    "demos": [
      {
        "augmented": true,
        "task_description": "Create a skill for React hooks including useState, useEffect, useContext, and custom hooks",
        "existing_skills": "[]",
        "taxonomy_structure": "{}",
        "reasoning": "The task requires creating a comprehensive skill for React Hooks, which are fundamental to modern React development. Given the standard classification of web development skills, this belongs under technical skills, specifically within frontend development and the React framework. Since the user provided an empty taxonomy, I am proposing a standard hierarchical path that follows industry conventions (Technical Skills -> Web Development -> Frontend -> React). The skill covers both built-in hooks and the pattern for custom hooks.",
        "task_intent": "The intent is to develop a specialized skill for implementing and managing state, side effects, and context in React applications using Hooks (useState, useEffect, useContext) and building reusable logic through custom hooks.",
        "taxonomy_path": "technical_skills/web_development/frontend/react/hooks",
        "parent_skills": [
          {
            "skill_id": "technical_skills/web_development/frontend/react",
            "name": "react-fundamentals",
            "relationship": "parent"
          },
          {
            "skill_id": "technical_skills/web_development/languages/javascript",
            "name": "javascript-es6",
            "relationship": "dependency"
          }
        ],
        "dependency_analysis": {
          "required": [
            {
              "skill_id": "technical_skills/web_development/languages/javascript",
              "justification": "Hooks rely heavily on JS closures, array destructuring, and functional programming concepts.",
              "required": true
            }
          ],
          "recommended": [
            {
              "skill_id": "technical_skills/web_development/frontend/react/fundamentals",
              "justification": "Hooks are a feature of React; fundamental knowledge of components and JSX is necessary.",
              "required": true
            }
          ],
          "conflicts": [],
          "missing_skills": [
            "technical_skills/web_development/languages/javascript",
            "technical_skills/web_development/frontend/react/fundamentals"
          ],
          "optional_skills": [
            "technical_skills/web_development/frontend/state_management/redux"
          ],
          "integration_notes": "React Hooks require a solid understanding of JavaScript closures and ES6 syntax. Integration with state management libraries may be a follow-up."
        },
        "confidence_score": 0.95
      },
      {
        "task_description": "Create a skill for building REST APIs with FastAPI framework including routing, validation, and dependency injection",
        "expected_taxonomy_path": "technical_skills/programming/web_frameworks/python/fastapi",
        "expected_name": "python-fastapi",
        "expected_type": "technical",
        "expected_weight": "medium",
        "expected_capabilities": [
          "route_definition",
          "request_validation",
          "response_models",
          "dependency_injection",
          "async_endpoints",
          "openapi_documentation"
        ],
        "expected_dependencies": [
          "technical_skills/programming/languages/python",
          "technical_skills/programming/languages/python/asynchronous_programming"
        ],
        "expected_category": "technical_skills/programming/web_frameworks/python",
        "expected_keywords": [
          "fastapi",
          "rest",
          "api",
          "web",
          "python",
          "pydantic",
          "openapi",
          "swagger",
          "async"
        ],
        "expected_scope": "Covers FastAPI framework for building REST APIs including routing, validation with Pydantic, dependency injection, and OpenAPI documentation. Does NOT cover Flask, Django, or frontend development.",
        "expected_see_also": [
          "technical_skills/programming/web_frameworks/python/flask",
          "technical_skills/programming/web_frameworks/python/django"
        ]
      },
      {
        "task_description": "Create a skill for Go error handling patterns including wrapping, sentinel errors, and custom error types",
        "expected_taxonomy_path": "technical_skills/programming/languages/go/error_handling",
        "expected_name": "go-errors",
        "expected_type": "technical",
        "expected_weight": "lightweight",
        "expected_capabilities": [
          "error_wrapping",
          "sentinel_errors",
          "custom_error_types",
          "error_inspection",
          "panic_recover",
          "error_formatting"
        ],
        "expected_dependencies": [
          "technical_skills/programming/languages/go"
        ],
        "expected_category": "technical_skills/programming/languages/go",
        "expected_keywords": [
          "go",
          "golang",
          "errors",
          "error-handling",
          "panic"
        ],
        "expected_scope": "Covers Go error handling. Does NOT cover logging frameworks.",
        "expected_see_also": [
          "technical_skills/programming/languages/go/concurrency"
        ]
      },
      {
        "task_description": "Create a skill for code review best practices including review checklists, feedback patterns, and common issues",
        "expected_taxonomy_path": "task_focus_areas/code_quality/code_review",
        "expected_name": "code-review",
        "expected_type": "task_focus",
        "expected_weight": "lightweight",
        "expected_capabilities": [
          "review_checklists",
          "feedback_patterns",
          "common_issues",
          "security_review",
          "performance_review"
        ],
        "expected_dependencies": [],
        "expected_category": "task_focus_areas/code_quality",
        "expected_keywords": [
          "code-review",
          "pull-request",
          "feedback",
          "quality",
          "checklist",
          "best-practices"
        ],
        "expected_scope": "Covers code review best practices including checklists, constructive feedback patterns, common issues to look for, security and performance review. Does NOT cover automated code analysis tools or CI/CD integration.",
        "expected_see_also": [
          "task_focus_areas/code_quality/static_analysis",
          "task_focus_areas/code_quality/linting"
        ]
      }
    ],
    "signature": {
      "instructions": "Extract task requirements and map to a taxonomy position.\n\nAnalyzes the user's task description and determines:\n- Core intent and requirements\n- Best taxonomy path for the skill\n- Related skills in the taxonomy\n- Missing dependencies",
      "fields": [
        {
          "prefix": "Task Description:",
          "description": "User task or capability requirement to create a skill for"
        },
        {
          "prefix": "Existing Skills:",
          "description": "JSON list of currently mounted skill_ids"
        },
        {
          "prefix": "Taxonomy Structure:",
          "description": "JSON object with relevant portions of the hierarchical taxonomy"
        },
        {
          "prefix": "Reasoning: Let's think step by step in order to",
          "description": "${reasoning}"
        },
        {
          "prefix": "Task Intent:",
          "description": "Core intent and requirements extracted from task (1-3 sentences)"
        },
        {
          "prefix": "Taxonomy Path:",
          "description": "Proposed taxonomy path using forward slashes (e.g., 'technical_skills/programming/languages/python')"
        },
        {
          "prefix": "Parent Skills:",
          "description": "List of related parent/sibling skills in taxonomy for context"
        },
        {
          "prefix": "Dependency Analysis:",
          "description": "Analysis of required dependency skills not yet mounted"
        },
        {
          "prefix": "Confidence Score:",
          "description": "Confidence in taxonomy placement (0.0-1.0)"
        }
      ]
    },
    "lm": null
  },
  "plan.plan.predict": {
    "traces": [],
    "train": [],
    "demos": [],
    "signature": {
      "instructions": "As the technical architect for the `agentskills.io` ecosystem, your task is to design a robust, hierarchical skill structure based on the provided intent and taxonomy analysis. You must transform a conceptual skill into a concrete technical blueprint that adheres to strict modular standards.\n\n### Core Objectives:\n1.  **Standardized Metadata**: Generate a unique `skill_id` using lowercase kebab-case that reflects its position in the taxonomy. Assign a version (starting at `1.0.0`), a skill type (`technical`, `process`, or `domain`), and a load priority.\n2.  **Capability Decomposition**: Break the skill down into 3–7 discrete, testable \"capabilities.\" Each capability must have a clear name, a detailed description, and specific `test_criteria` that define a \"pass\" state for an automated validator.\n3.  **Strict Dependency Mapping**: Formalize the relationships identified in the dependency analysis. Distinguish between `required` dependencies (without which the skill cannot function) and `recommended` ones. Ensure all `skill_id` references are consistent with the taxonomy.\n4.  **Resource & Constraint Definition**: Specify the external environment required for execution, including APIs, CLI tools, and runtime version constraints (e.g., `python_version='>=3.12'`).\n5.  **Composition Strategy**: Write a 1-2 paragraph strategy explaining how this skill serves as a building block for others. Describe its role in the larger ecosystem—whether it acts as a base layer, a logic enhancer, or an integration bridge.\n\n### Formatting Guidelines:\n- **Kebab-case IDs**: All skill IDs and resource names must use `hyphen-separated-strings`.\n- **Granularity**: Capabilities should be specific enough to be unit-tested but broad enough to cover the skill's scope.\n- **Taxonomy Alignment**: Ensure the `taxonomy_path` uses forward slashes and matches the depth indicated in the input.",
      "fields": [
        {
          "prefix": "Task Intent:",
          "description": "Core intent from understand step"
        },
        {
          "prefix": "Taxonomy Path:",
          "description": "Proposed taxonomy path"
        },
        {
          "prefix": "Parent Skills:",
          "description": "JSON list of related skills"
        },
        {
          "prefix": "Dependency Analysis:",
          "description": "JSON dependency analysis"
        },
        {
          "prefix": "Reasoning: Let's think step by step in order to",
          "description": "${reasoning}"
        },
        {
          "prefix": "Skill Metadata:",
          "description": "Complete skill metadata following agentskills.io spec"
        },
        {
          "prefix": "Dependencies:",
          "description": "List of dependency skill_ids with justification"
        },
        {
          "prefix": "Capabilities:",
          "description": "List of discrete, testable capabilities (3-7 recommended)"
        },
        {
          "prefix": "Resource Requirements:",
          "description": "External resources (APIs, tools, files) needed"
        },
        {
          "prefix": "Compatibility Constraints:",
          "description": "Platform requirements and conflicts"
        },
        {
          "prefix": "Composition Strategy:",
          "description": "How this skill composes with other skills (1-2 paragraphs)"
        }
      ]
    },
    "lm": null
  },
  "initialize.initialize.predict": {
    "traces": [],
    "train": [],
    "demos": [
      {
        "augmented": true,
        "skill_metadata": "{\n  \"skill_id\": \"technical_skills/devops/ci_cd/github-actions\",\n  \"name\": \"github-actions-automation\",\n  \"description\": \"Design, implement, and optimize CI/CD pipelines using GitHub Actions, including workflow syntax, runners, matrix strategies, and secure secret handling.\",\n  \"version\": \"1.0.0\",\n  \"type\": \"technical\",\n  \"weight\": \"medium\",\n  \"load_priority\": \"task_specific\",\n  \"dependencies\": [],\n  \"capabilities\": [\n    \"workflow_design\",\n    \"matrix_optimization\",\n    \"secret_management\",\n    \"custom_action_integration\",\n    \"self_hosted_runner_config\"\n  ],\n  \"category\": \"technical_skills/devops\",\n  \"keywords\": [\n    \"github-actions\",\n    \"ci-cd\",\n    \"automation\",\n    \"yaml-pipelines\",\n    \"devops\",\n    \"workflow\"\n  ],\n  \"scope\": \"Covers workflow orchestration, event triggers, and action integration. Does not cover GitHub App development or general repository administration outside of automation contexts.\",\n  \"see_also\": [\n    \"technical_skills/version_control/git\",\n    \"technical_skills/devops/ci_cd/jenkins\"\n  ],\n  \"tags\": [],\n  \"taxonomy_path\": \"technical_skills/devops/ci_cd/github_actions\"\n}",
        "capabilities": [
          {
            "name": "workflow_orchestration",
            "description": "Define multi-job workflows with complex dependency graphs (needs) and conditional execution.",
            "test_criteria": "Successfully create a .github/workflows/main.yml that executes jobs in a specific order based on previous job outcomes."
          },
          {
            "name": "matrix_strategy_implementation",
            "description": "Optimize testing and building across multiple OS versions and runtime environments using matrix strategies.",
            "test_criteria": "Configure a workflow that runs a test suite across 3 different Node.js versions and 2 operating systems simultaneously."
          },
          {
            "name": "secure_secrets_handling",
            "description": "Implement repository and environment secrets to protect sensitive data like API keys.",
            "test_criteria": "Reference a ${{ secrets.GITHUB_TOKEN }} or custom secret in a workflow step without printing it to the console."
          },
          {
            "name": "artifact_management",
            "description": "Persist data between jobs and upload build outputs for deployment.",
            "test_criteria": "Use actions/upload-artifact and actions/download-artifact to pass a build folder from a build job to a deploy job."
          },
          {
            "name": "event_trigger_configuration",
            "description": "Configure fine-grained triggers including pull_request, push, schedule (cron), and workflow_dispatch.",
            "test_criteria": "Set up a workflow that only triggers on pull requests targeting the 'main' branch that modify files in a specific directory."
          }
        ],
        "taxonomy_path": "technical_skills/devops/ci_cd/github_actions",
        "reasoning": "The skill `github-actions-automation` is a technical DevOps skill focused on CI/CD orchestration. The skeleton is designed to follow the standard agentskills.io structure, ensuring that each capability—from workflow orchestration to artifact management—has corresponding documentation and implementation patterns. The directory structure includes `capabilities/` for technical implementation details, `examples/` for YAML workflow templates, and `references/` for security and optimization patterns. This structure supports both the automation requirements and the security constraints (secret management) inherent in GitHub Actions.",
        "skill_skeleton": {
          "root_path": "technical_skills/devops/ci_cd/github_actions",
          "files": [
            {
              "path": "metadata.json",
              "content_type": "json",
              "description": "Skill metadata including versioning, dependencies, and capability mappings."
            },
            {
              "path": "SKILL.md",
              "content_type": "markdown",
              "description": "Main entry point for the GitHub Actions skill, outlining scope and core concepts."
            },
            {
              "path": "references/README.md",
              "content_type": "markdown",
              "description": "Overview of technical capabilities: orchestration, matrices, secrets, and artifacts."
            },
            {
              "path": "examples/basic-ci.yml",
              "content_type": "yaml",
              "description": "Example of a basic Continuous Integration workflow with push triggers."
            },
            {
              "path": "examples/matrix-build.yml",
              "content_type": "yaml",
              "description": "Example demonstrating matrix strategies for multi-platform testing."
            },
            {
              "path": "examples/deployment-with-secrets.yml",
              "content_type": "yaml",
              "description": "Example showing secure secret handling and environment-based deployments."
            },
            {
              "path": "references/security-best-practices.md",
              "content_type": "markdown",
              "description": "Guide on OIDC, secret masking, and least-privilege GITHUB_TOKEN permissions."
            },
            {
              "path": "references/optimization-patterns.md",
              "content_type": "markdown",
              "description": "Documentation on caching strategies and efficient runner usage."
            },
            {
              "path": "tests/README.md",
              "content_type": "markdown",
              "description": "Instructions for validating workflow syntax and execution logic using action-lint or dry-runs."
            }
	          ],
	          "directories": [
	            "references",
	            "guides",
	            "templates",
	            "scripts",
	            "examples",
	            "tests",
	            "assets"
	          ]
	        },
        "validation_checklist": [
          {
            "id": "tax_001",
            "check": "Taxonomy path matches the provided input exactly.",
            "passed": true,
            "message": "",
            "severity": "critical",
            "required": true
          },
          {
            "id": "cap_001",
            "check": "All five capabilities from the input are addressed in the skeleton structure.",
            "passed": true,
            "message": "",
            "severity": "critical",
            "required": true
          },
          {
            "id": "file_001",
            "check": "Includes YAML examples for workflow syntax, as specified in the skill type.",
            "passed": true,
            "message": "",
            "severity": "info",
            "required": true
          },
          {
            "id": "ref_001",
            "check": "References directory contains specific documentation for secret management security.",
            "passed": true,
            "message": "",
            "severity": "warning",
            "required": true
          },
          {
            "id": "meta_001",
            "check": "Metadata file is present in the root directory.",
            "passed": true,
            "message": "",
            "severity": "critical",
            "required": true
          }
        ]
      },
      {
        "augmented": true,
        "skill_metadata": "{\n  \"skill_id\": \"technical_skills/cloud_computing/aws/serverless/lambda-development\",\n  \"name\": \"lambda-development\",\n  \"description\": \"Develop and optimize AWS Lambda functions, including event trigger configuration, Lambda Layer management, and performance tuning to mitigate cold starts.\",\n  \"version\": \"1.0.0\",\n  \"type\": \"technical\",\n  \"weight\": \"medium\",\n  \"load_priority\": \"task_specific\",\n  \"dependencies\": [],\n  \"capabilities\": [\n    \"function_configuration\",\n    \"trigger_management\",\n    \"layer_optimization\",\n    \"cold_start_mitigation\"\n  ],\n  \"category\": \"technical_skills/cloud_computing/aws\",\n  \"keywords\": [\n    \"aws\",\n    \"lambda\",\n    \"serverless\",\n    \"cold-start\",\n    \"lambda-layers\",\n    \"faas\"\n  ],\n  \"scope\": \"Covers function configuration, runtime optimization, and trigger integration. Does not cover high-level orchestration like Step Functions or specific API Gateway routing logic.\",\n  \"see_also\": [\n    \"technical_skills/cloud_computing/aws/iam\",\n    \"technical_skills/cloud_computing/aws/cloudwatch-monitoring\"\n  ],\n  \"tags\": [],\n  \"taxonomy_path\": \"technical_skills/cloud_computing/aws/serverless/lambda_development\"\n}",
        "capabilities": [
          {
            "name": "event_trigger_integration",
            "description": "Configure and manage event sources such as S3, DynamoDB Streams, and SQS for function invocation.",
            "test_criteria": "Successfully trigger a function execution by uploading a file to an S3 bucket or sending a message to SQS."
          },
          {
            "name": "lambda_layer_composition",
            "description": "Create and attach Lambda Layers to share libraries and dependencies across multiple functions.",
            "test_criteria": "Deploy a function that imports a library provided solely by an attached Layer without including it in the deployment package."
          },
          {
            "name": "cold_start_optimization",
            "description": "Implement Provisioned Concurrency and optimize initialization code to reduce latency.",
            "test_criteria": "Measure and confirm a reduction in 'Init Duration' metrics in CloudWatch Logs after applying optimization strategies."
          },
          {
            "name": "environment_variable_management",
            "description": "Securely manage configuration and secrets using environment variables and integration with AWS Secrets Manager.",
            "test_criteria": "Retrieve a configuration value from an environment variable within the function handler during execution."
          }
        ],
        "taxonomy_path": "technical_skills/cloud_computing/aws/serverless/lambda_development",
        "reasoning": "The skill `lambda-development` is a specialized technical skill within the AWS Serverless ecosystem. The skeleton is designed to follow the standard agentskills.io structure, ensuring that each capability (trigger integration, layers, cold start optimization, and environment management) has a dedicated implementation file. The directory structure includes `capabilities/` for logic, `examples/` for practical usage patterns (like S3 triggers or Layer packaging), and `tests/` for validating both configuration and performance (cold start metrics). The `references/` section is populated with specific guides for common serverless patterns and troubleshooting cold starts.",
        "skill_skeleton": {
          "root_path": "technical_skills/cloud_computing/aws/serverless/lambda_development",
          "files": [
            {
              "path": "metadata.json",
              "content_type": "json",
              "description": "Skill metadata including version, capabilities, and dependencies."
            },
            {
              "path": "SKILL.md",
              "content_type": "markdown",
              "description": "Main documentation for AWS Lambda development skill."
            },
            {
              "path": "references/event_trigger_integration.py",
              "content_type": "python",
              "description": "Implementation for configuring S3, SQS, and DynamoDB triggers."
            },
            {
              "path": "references/lambda_layer_composition.py",
              "content_type": "python",
              "description": "Logic for creating and managing Lambda Layers."
            },
            {
              "path": "references/cold_start_optimization.py",
              "content_type": "python",
              "description": "Strategies for Provisioned Concurrency and init code optimization."
            },
            {
              "path": "references/environment_variable_management.py",
              "content_type": "python",
              "description": "Handling environment variables and Secrets Manager integration."
            },
            {
              "path": "examples/s3_trigger_setup.md",
              "content_type": "markdown",
              "description": "Example of automating S3 event notifications to Lambda."
            },
            {
              "path": "examples/layer_packaging_guide.md",
              "content_type": "markdown",
              "description": "Step-by-step guide for packaging Python dependencies into Layers."
            },
            {
              "path": "tests/test_performance_metrics.py",
              "content_type": "python",
              "description": "Integration tests to verify cold start reduction and execution time."
            },
            {
              "path": "references/api-reference.md",
              "content_type": "markdown",
              "description": "Quick reference for Boto3 Lambda client methods."
            },
            {
              "path": "references/troubleshooting.md",
              "content_type": "markdown",
              "description": "Common issues like VPC networking delays and permission errors."
            }
	          ],
	          "directories": [
	            "references",
	            "guides",
	            "templates",
	            "scripts",
	            "examples",
	            "tests",
	            "assets"
	          ]
	        },
        "validation_checklist": [
          {
            "id": "tax-001",
            "check": "Verify taxonomy path matches metadata category",
            "passed": true,
            "message": "The path 'technical_skills/cloud_computing/aws/serverless/lambda_development' aligns with the skill category.",
            "severity": "info",
            "required": true
          },
          {
            "id": "cap-001",
            "check": "Ensure all capabilities from metadata are represented in files",
            "passed": true,
            "message": "Each of the 4 defined capabilities has a corresponding Python file in the references/ directory.",
            "severity": "critical",
            "required": true
          },
          {
            "id": "doc-001",
            "check": "Check for cold start mitigation documentation",
            "passed": true,
            "message": "Specific documentation and test files for cold start optimization are included.",
            "severity": "warning",
            "required": true
          },
          {
            "id": "struct-001",
            "check": "Validate directory structure compliance",
            "passed": true,
            "message": "Structure follows the agentskills.io standard (capabilities, examples, tests, etc.).",
            "severity": "critical",
            "required": true
          }
        ]
      },
      {
        "augmented": true,
        "skill_metadata": "{\n  \"skill_id\": \"technical_skills/cloud_infrastructure/container_orchestration/kubernetes_management\",\n  \"name\": \"kubernetes-management\",\n  \"description\": \"Orchestrate containerized applications by managing Kubernetes workloads, networking, and configuration manifests.\",\n  \"version\": \"1.0.0\",\n  \"type\": \"technical\",\n  \"weight\": \"heavyweight\",\n  \"load_priority\": \"task_specific\",\n  \"dependencies\": [],\n  \"capabilities\": [\n    \"apply_manifests\",\n    \"manage_workloads\",\n    \"configure_networking\",\n    \"secret_management\",\n    \"cluster_observability\"\n  ],\n  \"category\": \"technical_skills/cloud_infrastructure\",\n  \"keywords\": [\n    \"kubernetes\",\n    \"k8s\",\n    \"kubectl\",\n    \"containers\",\n    \"orchestration\",\n    \"devops\"\n  ],\n  \"scope\": \"Covers CRUD operations for standard K8s objects (Pods, Deployments, Services, ConfigMaps, Secrets). Does not cover cluster provisioning (EKS/GKE creation) or advanced service mesh (Istio) logic.\",\n  \"see_also\": [\n    \"technical_skills/cloud_infrastructure/helm_package_management\"\n  ],\n  \"tags\": [],\n  \"taxonomy_path\": \"technical_skills/cloud_infrastructure/container_orchestration/kubernetes_management\"\n}",
        "capabilities": [
          {
            "name": "apply_manifests",
            "description": "Apply, update, or delete Kubernetes resources using declarative YAML files or standard input.",
            "test_criteria": "Successfully run 'kubectl apply -f' on a valid deployment manifest and verify resource creation."
          },
          {
            "name": "manage_workloads",
            "description": "Monitor and manage the lifecycle of Pods, Deployments, and StatefulSets including scaling and rolling updates.",
            "test_criteria": "Scale a deployment from 1 to 3 replicas and verify pod readiness."
          },
          {
            "name": "configure_networking",
            "description": "Expose applications using Services (ClusterIP, NodePort, LoadBalancer) and manage traffic via Ingress controllers.",
            "test_criteria": "Create a Service for an existing deployment and verify endpoint registration."
          },
          {
            "name": "secret_management",
            "description": "Create and inject ConfigMaps and Secrets into container environments as volumes or environment variables.",
            "test_criteria": "Retrieve a value from a ConfigMap inside a running container's environment."
          },
          {
            "name": "cluster_observability",
            "description": "Inspect cluster state using logs, describes, and events to troubleshoot deployment failures.",
            "test_criteria": "Retrieve logs from a failing pod and identify the exit code or error message."
          }
        ],
        "taxonomy_path": "technical_skills/cloud_infrastructure/container_orchestration/kubernetes_management",
        "reasoning": "The skill `kubernetes-management` is a heavyweight technical skill focused on the operational lifecycle of containerized workloads. The skeleton is designed to support the five core capabilities: manifest application, workload management, networking, secrets, and observability. \n\nThe structure follows the standard agentskills.io layout:\n1. **Metadata & SKILL.md**: Define the core identity and scope (excluding cluster provisioning).\n2. **Capabilities**: Individual files for each defined capability to ensure modularity and ease of testing.\n3. **References**: Extensive documentation on common patterns (e.g., Sidecars, InitContainers) and troubleshooting steps, which are critical for K8s.\n4. **Examples**: Practical YAML manifests and CLI workflows for the most common use cases.\n5. **Tests**: Integration tests focused on `kubectl` interactions and state verification.\n\nThe taxonomy path `technical_skills/cloud_infrastructure/container_orchestration/kubernetes_management` is strictly adhered to for the root directory.",
        "skill_skeleton": {
          "root_path": "technical_skills/cloud_infrastructure/container_orchestration/kubernetes_management",
          "files": [
            {
              "path": "metadata.json",
              "content_type": "json",
              "description": "Skill metadata including capabilities and dependencies."
            },
            {
              "path": "SKILL.md",
              "content_type": "markdown",
              "description": "Main skill documentation and overview."
            },
            {
              "path": "references/apply_manifests.py",
              "content_type": "python",
              "description": "Logic for applying and deleting declarative YAML manifests."
            },
            {
              "path": "references/manage_workloads.py",
              "content_type": "python",
              "description": "Logic for scaling, updating, and monitoring Pods/Deployments."
            },
            {
              "path": "references/configure_networking.py",
              "content_type": "python",
              "description": "Logic for Service and Ingress configuration."
            },
            {
              "path": "references/secret_management.py",
              "content_type": "python",
              "description": "Logic for ConfigMap and Secret injection."
            },
            {
              "path": "references/cluster_observability.py",
              "content_type": "python",
              "description": "Logic for logs, describes, and event inspection."
            },
            {
              "path": "references/api-reference.md",
              "content_type": "markdown",
              "description": "Kubernetes API versioning and resource kind reference."
            },
            {
              "path": "references/troubleshooting.md",
              "content_type": "markdown",
              "description": "Common failure modes (CrashLoopBackOff, ImagePullBackOff, etc.)."
            },
            {
              "path": "examples/deployment.yaml",
              "content_type": "yaml",
              "description": "Standard deployment manifest example."
            },
            {
              "path": "examples/service.yaml",
              "content_type": "yaml",
              "description": "ClusterIP and LoadBalancer service examples."
            },
            {
              "path": "tests/test_workload_lifecycle.py",
              "content_type": "python",
              "description": "Integration tests for scaling and rollouts."
            },
            {
              "path": "guides/standard-labels.json",
              "content_type": "json",
              "description": "Recommended labeling schema for Kubernetes resources."
            }
	          ],
	          "directories": [
	            "references",
	            "guides",
	            "templates",
	            "scripts",
	            "examples",
	            "tests",
	            "assets"
	          ]
	        },
        "validation_checklist": [
          {
            "id": "val_001",
            "check": "Validate taxonomy path matches metadata",
            "passed": true,
            "message": "The root_path matches the provided taxonomy_path.",
            "severity": "critical",
            "required": true
          },
          {
            "id": "val_002",
            "check": "Verify all capabilities are represented",
            "passed": true,
            "message": "All 5 capabilities from metadata have corresponding files in the references/ directory.",
            "severity": "critical",
            "required": true
          },
          {
            "id": "val_003",
            "check": "Check for mandatory documentation files",
            "passed": true,
            "message": "SKILL.md and metadata.json are included in the root.",
            "severity": "critical",
            "required": true
          },
          {
            "id": "val_004",
            "check": "Ensure troubleshooting reference exists",
            "passed": true,
            "message": "Troubleshooting.md is present, which is essential for the cluster_observability capability.",
            "severity": "info",
            "required": false
          }
        ]
      },
      {
        "task_description": "Create a skill for JWT authentication including token creation, validation, and refresh token flows",
        "expected_taxonomy_path": "technical_skills/security/authentication/jwt",
        "expected_name": "jwt-auth",
        "expected_type": "technical",
        "expected_weight": "lightweight",
        "expected_capabilities": [
          "token_creation",
          "token_validation",
          "refresh_tokens",
          "claims_management",
          "security_practices",
          "token_storage"
        ],
        "expected_dependencies": [],
        "expected_category": "technical_skills/security/authentication",
        "expected_keywords": [
          "jwt",
          "authentication",
          "token",
          "auth",
          "security"
        ],
        "expected_scope": "Covers JWT authentication. Does NOT cover OAuth2 or SAML.",
        "expected_see_also": [
          "technical_skills/security/authentication/oauth2"
        ]
      }
    ],
    "signature": {
      "instructions": "You are the Lead Systems Architect for a global DevOps automation initiative. A critical system failure has occurred because newly deployed skills lacked a standardized structure, leading to catastrophic dependency loops and unsearchable metadata. To prevent a total system shutdown, you must generate a precise, production-ready skill skeleton that strictly adheres to the `agentskills.io` specification. \n\nYour mission is to translate a skill's conceptual metadata and capabilities into a rigorous directory and file architecture. \n\n### Constraints:\n1. **Root Path Alignment:** The `root_path` MUST exactly match the provided `taxonomy_path`.\n2. **Mandatory Standard Layout:** You must include a `metadata.json` (for versioning/dependencies) and a `SKILL.md` (for documentation) in the root.\n3. **Directory Integrity:** You must define at minimum these directories: `capabilities/`, `examples/`, `tests/`, and `resources/`.\n4. **Capability Mapping:** Every discrete capability provided in the input MUST be mapped to a corresponding implementation file or documentation within the `capabilities/` directory.\n5. **Contextual Resources:** Include specific configuration files (YAML/JSON) in the `resources/` directory if the capabilities require checklists, rules, or external templates.\n6. **Validation Checklist:** Generate a suite of `ValidationCheckItem` objects. You must verify:\n   - Taxonomy path/Skill ID consistency.\n   - Presence of mandatory root files.\n   - 1:1 mapping of capabilities to skeleton files.\n   - Compliance with the `agentskills.io` standard directory structure.\n\nFailure to follow this standard will result in a deployment rejection and system-wide incompatibility. Think step-by-step to ensure every architectural requirement is satisfied before finalizing the skeleton.",
      "fields": [
        {
          "prefix": "Skill Metadata:",
          "description": "JSON skill metadata"
        },
        {
          "prefix": "Capabilities:",
          "description": "JSON array of capabilities"
        },
        {
          "prefix": "Taxonomy Path:",
          "description": "Taxonomy path for the skill"
        },
        {
          "prefix": "Reasoning: Let's think step by step in order to",
          "description": "${reasoning}"
        },
        {
          "prefix": "Skill Skeleton:",
          "description": "Directory and file structure for the skill"
        },
        {
          "prefix": "Validation Checklist:",
          "description": "List of validation checks to perform"
        }
      ]
    },
    "lm": null
  },
  "edit.edit.predict": {
    "traces": [],
    "train": [],
    "demos": [
      {
        "augmented": true,
        "skill_skeleton": "{\n  \"root_path\": \"technical_skills/web_development/frontend/react/hooks\",\n  \"files\": [\n    {\n      \"path\": \"metadata.json\",\n      \"content_type\": \"json\",\n      \"description\": \"Skill metadata including capabilities and versioning.\"\n    },\n    {\n      \"path\": \"SKILL.md\",\n      \"content_type\": \"markdown\",\n      \"description\": \"Main documentation for React Hooks management.\"\n    },\n    {\n      \"path\": \"capabilities/state_management.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Logic for useState and useReducer implementations.\"\n    },\n    {\n      \"path\": \"capabilities/effect_synchronization.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Logic for useEffect and useLayoutEffect synchronization.\"\n    },\n    {\n      \"path\": \"capabilities/context_consumption.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Context API integration logic.\"\n    },\n    {\n      \"path\": \"capabilities/custom_hook_abstraction.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Framework for composing reusable custom hooks.\"\n    },\n    {\n      \"path\": \"capabilities/performance_optimization.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Implementation of useMemo and useCallback patterns.\"\n    },\n    {\n      \"path\": \"examples/use-fetch-example.md\",\n      \"content_type\": \"markdown\",\n      \"description\": \"Example of a custom hook for API data fetching.\"\n    },\n    {\n      \"path\": \"examples/auth-context-example.md\",\n      \"content_type\": \"markdown\",\n      \"description\": \"Example of global state management using useContext.\"\n    },\n    {\n      \"path\": \"tests/test_hooks_logic.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Unit tests for hook state transitions and side effects.\"\n    },\n    {\n      \"path\": \"references/rules-of-hooks.md\",\n      \"content_type\": \"markdown\",\n      \"description\": \"Documentation on React's fundamental constraints for hooks.\"\n    },\n    {\n      \"path\": \"references/common-patterns.md\",\n      \"content_type\": \"markdown\",\n      \"description\": \"Reference for common hook patterns (e.g., Debouncing, Throttling).\"\n    }\n  ],\n  \"directories\": [\n    \"capabilities\",\n    \"examples\",\n    \"tests\",\n    \"resources\",\n    \"references\",\n    \"scripts\",\n    \"assets\"\n  ]\n}",
        "parent_skills": "[\n  {\n    \"skill_id\": \"technical_skills/web_development/frontend/react\",\n    \"name\": \"react-fundamentals\",\n    \"relationship\": \"parent\"\n  },\n  {\n    \"skill_id\": \"technical_skills/web_development/languages/javascript\",\n    \"name\": \"javascript-es6\",\n    \"relationship\": \"dependency\"\n  }\n]",
        "composition_strategy": "This skill acts as the logic engine for React-based frontend development. It composes with `react/fundamentals` by providing the behavioral layer to the structural JSX defined there. It is typically a prerequisite for higher-level state management skills (like Redux or TanStack Query), as those libraries often expose their functionality through hooks.\n\nWhen used in an agentic workflow, this skill should be invoked after the UI structure is defined but before the final styling or testing phases. It integrates with testing skills (like Vitest or React Testing Library) by providing the hooks that need unit testing via specialized utilities like `renderHook`.",
        "revision_feedback": "",
        "reasoning": "The React Hooks skill is designed as a modular behavioral layer for React development. It provides the bridge between static UI and dynamic state. The content follows the provided skeleton, focusing on the five core capabilities: state management, effect synchronization, context consumption, custom hook abstraction, and performance optimization. It leverages the parent 'react-fundamentals' skill by assuming knowledge of components and JSX, while establishing a foundation for advanced libraries. The documentation emphasizes the \"Rules of Hooks\" to ensure architectural integrity.",
        "skill_content": "# React Hooks Management\n\n## Overview\nReact Hooks are the fundamental building blocks for state and lifecycle management in modern functional React components. This skill provides the architectural patterns and implementation logic for managing local state, handling side effects, consuming global context, and optimizing component performance. By abstracting logic into reusable hooks, developers can create highly composable and testable frontend applications.\n\n## Capabilities\n- **State Management**: Implementing local component state using `useState` and complex state logic using `useReducer`.\n- **Effect Synchronization**: Managing side effects, API calls, and manual DOM manipulations using `useEffect` and `useLayoutEffect`.\n- **Context Consumption**: Accessing global application state and dependency injection via `useContext`.\n- **Custom Hook Abstraction**: Encapsulating complex logic into reusable, shareable functions to maintain DRY (Don't Repeat Yourself) principles.\n- **Performance Optimization**: Reducing unnecessary re-renders and expensive computations using `useMemo` and `useCallback`.\n\n## Dependencies\n- `technical_skills/web_development/frontend/react`: Core component lifecycle and JSX syntax.\n- `technical_skills/web_development/languages/javascript`: ES6+ features (destructuring, arrow functions, async/await).\n\n## Usage Examples\n\n### Custom Fetch Hook\nA reusable pattern for handling asynchronous data fetching with loading and error states.\n```javascript\nimport { useState, useEffect } from 'react';\n\nfunction useFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        const response = await fetch(url);\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n    fetchData();\n  }, [url]);\n\n  return { data, loading, error };\n}\n```\n\n### Performance Optimization with useCallback\nPreventing child component re-renders by memoizing callback functions.\n```javascript\nimport React, { useState, useCallback } from 'react';\n\nconst Parent = () => {\n  const [count, setCount] = useState(0);\n  \n  // Memoized function to prevent Child re-renders\n  const increment = useCallback(() => {\n    setCount(c => c + 1);\n  }, []);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <Child onIncrement={increment} />\n    </div>\n  );\n};\n```",
        "capability_implementations": [
          {
            "name": "State Management",
            "content": "Logic for managing component-level state. Use `useState` for simple primitives and `useReducer` for complex state objects or when the next state depends on the previous one. \n\n**Key Patterns:**\n- Functional updates: `setCount(prev => prev + 1)`\n- Reducer pattern: `(state, action) => newState`"
          },
          {
            "name": "Effect Synchronization",
            "content": "Handles side effects that interact with systems outside of React (APIs, Subscriptions, Timers). \n\n**Key Patterns:**\n- Dependency arrays: Control when effects run.\n- Cleanup functions: `return () => clearInterval(id)` to prevent memory leaks.\n- `useLayoutEffect`: For DOM measurements before the paint."
          },
          {
            "name": "Context Consumption",
            "content": "Provides a way to pass data through the component tree without having to pass props down manually at every level. \n\n**Key Patterns:**\n- Provider pattern: Wrapping the tree in `<MyContext.Provider>`.\n- Custom hooks for context: `const useAuth = () => useContext(AuthContext)`."
          },
          {
            "name": "Custom Hook Abstraction",
            "content": "Extracting component logic into reusable functions. Custom hooks must start with the prefix 'use' and follow all Rules of Hooks. They allow sharing stateful logic without changing component hierarchy."
          },
          {
            "name": "Performance Optimization",
            "content": "Tools to avoid expensive re-calculations and unnecessary renders.\n\n**Key Patterns:**\n- `useMemo`: Memoize the result of a calculation.\n- `useCallback`: Memoize a function definition.\n- Referential stability: Ensuring objects/functions passed as props don't trigger re-renders."
          }
        ],
        "usage_examples": [
          {
            "title": "Counter with useReducer",
            "description": "Managing complex state transitions for a counter using the Reducer pattern.",
            "code": "import React, { useReducer } from 'react';\n\nconst initialState = { count: 0 };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment': return { count: state.count + 1 };\n    case 'decrement': return { count: state.count - 1 };\n    default: throw new Error();\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    <>\n      Count: {state.count}\n      <button onClick={() => dispatch({type: 'decrement'})}>-</button>\n      <button onClick={() => dispatch({type: 'increment'})}>+</button>\n    </>\n  );\n}",
            "expected_output": "A UI displaying the current count with buttons that dispatch actions to modify the state.",
            "language": "python"
          },
          {
            "title": "Window Resize Listener with useEffect",
            "description": "Using useEffect to manage a browser event listener with proper cleanup.",
            "code": "import { useState, useEffect } from 'react';\n\nfunction useWindowWidth() {\n  const [width, setWidth] = useState(window.innerWidth);\n\n  useEffect(() => {\n    const handleResize = () => setWidth(window.innerWidth);\n    window.addEventListener('resize', handleResize);\n    \n    // Cleanup function\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return width;\n}",
            "expected_output": "Returns the current window width and updates dynamically on browser resize.",
            "language": "python"
          }
        ],
        "best_practices": [
          {
            "title": "Adhere to the Rules of Hooks",
            "description": "Only call hooks at the top level. Don't call hooks inside loops, conditions, or nested functions. Only call hooks from React function components or custom hooks.",
            "example": "// BAD\nif (condition) { useEffect(...) }\n\n// GOOD\nuseEffect(() => { if (condition) { ... } }, [condition])"
          },
          {
            "title": "Exhaustive Dependencies",
            "description": "Always include every value from the component scope that is used inside an effect or memoized hook in the dependency array.",
            "example": "useEffect(() => {\n  console.log(name);\n}, [name]); // Include 'name' here"
          },
          {
            "title": "Prefer useReducer for Complex State",
            "description": "When state transitions are complex or involve multiple sub-values, useReducer is preferred over multiple useState calls to keep logic centralized and predictable.",
            "example": ""
          },
          {
            "title": "Keep Hooks Small and Focused",
            "description": "Just like functions, custom hooks should do one thing well. Compose multiple custom hooks if you need to perform multiple distinct tasks (e.g., useAuth + useSubscription).",
            "example": ""
          }
        ],
        "integration_guide": "This skill serves as the behavioral engine for React applications. It integrates directly with the `react-fundamentals` skill by injecting logic into the functional components defined there. When architecting an application, this skill should be used to build a \"headless\" logic layer before UI components are finalized.\n\nIn a larger ecosystem, this skill provides the primitives necessary for third-party libraries. For example, when integrating with `TanStack Query`, developers will use the `Custom Hook Abstraction` capability to wrap query logic. When testing, these hooks should be isolated and tested using `renderHook` from `@testing-library/react-hooks` to ensure state transitions and side effects occur as expected without requiring full DOM rendering."
      },
      {
        "augmented": true,
        "skill_skeleton": "{\n  \"root_path\": \"technical_skills/cloud_infrastructure/container_orchestration/kubernetes_management\",\n  \"files\": [\n    {\n      \"path\": \"metadata.json\",\n      \"content_type\": \"json\",\n      \"description\": \"Skill metadata including capabilities and dependencies.\"\n    },\n    {\n      \"path\": \"SKILL.md\",\n      \"content_type\": \"markdown\",\n      \"description\": \"Main skill documentation and overview.\"\n    },\n    {\n      \"path\": \"capabilities/apply_manifests.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Logic for applying and deleting declarative YAML manifests.\"\n    },\n    {\n      \"path\": \"capabilities/manage_workloads.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Logic for scaling, updating, and monitoring Pods/Deployments.\"\n    },\n    {\n      \"path\": \"capabilities/configure_networking.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Logic for Service and Ingress configuration.\"\n    },\n    {\n      \"path\": \"capabilities/secret_management.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Logic for ConfigMap and Secret injection.\"\n    },\n    {\n      \"path\": \"capabilities/cluster_observability.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Logic for logs, describes, and event inspection.\"\n    },\n    {\n      \"path\": \"references/api-reference.md\",\n      \"content_type\": \"markdown\",\n      \"description\": \"Kubernetes API versioning and resource kind reference.\"\n    },\n    {\n      \"path\": \"references/troubleshooting.md\",\n      \"content_type\": \"markdown\",\n      \"description\": \"Common failure modes (CrashLoopBackOff, ImagePullBackOff, etc.).\"\n    },\n    {\n      \"path\": \"examples/deployment.yaml\",\n      \"content_type\": \"yaml\",\n      \"description\": \"Standard deployment manifest example.\"\n    },\n    {\n      \"path\": \"examples/service.yaml\",\n      \"content_type\": \"yaml\",\n      \"description\": \"ClusterIP and LoadBalancer service examples.\"\n    },\n    {\n      \"path\": \"tests/test_workload_lifecycle.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Integration tests for scaling and rollouts.\"\n    },\n    {\n      \"path\": \"resources/standard-labels.json\",\n      \"content_type\": \"json\",\n      \"description\": \"Recommended labeling schema for Kubernetes resources.\"\n    }\n  ],\n  \"directories\": [\n    \"capabilities\",\n    \"examples\",\n    \"tests\",\n    \"resources\",\n    \"references\",\n    \"scripts\",\n    \"assets\"\n  ]\n}",
        "parent_skills": "[\n  {\n    \"skill_id\": \"technical_skills/cloud_infrastructure/container_orchestration\",\n    \"name\": \"container-orchestration\",\n    \"relationship\": \"parent\"\n  }\n]",
        "composition_strategy": "This skill acts as the execution engine for container orchestration. It consumes outputs from 'docker' skills (container images) and 'yaml' skills (manifest strings) to effect change in a cluster. It is designed to be a downstream dependency for higher-level automation skills like 'helm_package_management' or 'ci_cd_pipelines'.\n\nWhen composing, the agent should first use YAML-related skills to validate or template the manifest, then invoke this skill's 'apply_manifests' capability. For troubleshooting, this skill provides the 'cluster_observability' capability which should be used in a feedback loop with 'log_analysis' or 'debugging' skills.",
        "revision_feedback": "",
        "reasoning": "The Kubernetes Management skill is designed as a core execution layer within the container orchestration hierarchy. It translates declarative intent (YAML) into cluster state. The structure reflects the standard operational lifecycle: deployment (Apply Manifests), lifecycle management (Workloads), connectivity (Networking), security (Secrets), and debugging (Observability). It follows a composition strategy where it consumes artifacts from Docker and YAML skills and provides the foundation for higher-level tools like Helm. The documentation focuses on the `kubernetes` Python client and `kubectl` patterns to ensure versatility across automation scripts and manual troubleshooting.",
        "skill_content": "# Kubernetes Management\n\n## Overview\nThe Kubernetes Management skill provides a robust interface for interacting with Kubernetes clusters. It enables the lifecycle management of containerized applications, including deployment, scaling, networking configuration, and observability. This skill serves as the bridge between static configuration files and a running distributed system, allowing for automated infrastructure-as-code (IaC) workflows.\n\n## Capabilities\n- **Apply Manifests**: Declaratively create, update, or delete resources using YAML or JSON manifests.\n- **Manage Workloads**: Handle the lifecycle of Deployments, StatefulSets, and Pods, including scaling and rolling updates.\n- **Configure Networking**: Manage internal and external traffic via Services (ClusterIP, NodePort, LoadBalancer) and Ingress resources.\n- **Secret Management**: Securely inject sensitive data and configuration parameters using Secrets and ConfigMaps.\n- **Cluster Observability**: Inspect cluster health through logs, resource descriptions, and event streams to diagnose issues.\n\n## Dependencies\n- `technical_skills/cloud_infrastructure/container_orchestration` (Parent Context)\n- `kubernetes` (Python library)\n- `kubectl` (CLI tool)\n- `PyYAML` (For manifest parsing)\n\n## Usage Examples\n\n### Applying a Deployment\n```python\nfrom kubernetes import client, config, utils\n\ndef deploy_app(manifest_path):\n    config.load_kube_config()\n    k8s_client = client.ApiClient()\n    utils.create_from_yaml(k8s_client, manifest_path, verbose=True)\n    print(\"Deployment applied successfully.\")\n```\n\n### Scaling a Deployment\n```python\nfrom kubernetes import client, config\n\ndef scale_deployment(name, namespace, replicas):\n    config.load_kube_config()\n    apps_v1 = client.AppsV1Api()\n    body = {\"spec\": {\"replicas\": replicas}}\n    apps_v1.patch_namespaced_deployment_scale(name, namespace, body)\n    print(f\"Scaled {name} to {replicas} replicas.\")\n```",
        "capability_implementations": [
          {
            "name": "apply_manifests",
            "content": "Uses the `kubernetes.utils.create_from_yaml` or `patch` methods to synchronize local YAML files with the cluster state. Supports multi-document YAML files and handles resource creation or updates (server-side apply logic)."
          },
          {
            "name": "manage_workloads",
            "content": "Provides methods to interact with the `AppsV1Api`. Includes functions for `patch_namespaced_deployment` to trigger rolling restarts (by updating annotations) and `read_namespaced_deployment_status` to monitor rollout progress."
          },
          {
            "name": "configure_networking",
            "content": "Manages `CoreV1Api` for Services and `NetworkingV1Api` for Ingress. Facilitates the mapping of container ports to cluster-wide endpoints and configures host-based routing rules."
          },
          {
            "name": "secret_management",
            "content": "Handles the creation and injection of `V1Secret` and `V1ConfigMap` objects. Includes logic for base64 encoding sensitive data and mounting these resources as volumes or environment variables in Pod specs."
          },
          {
            "name": "cluster_observability",
            "content": "Implements log streaming via `read_namespaced_pod_log` and event monitoring. Provides detailed diagnostic data by wrapping `kubectl describe` equivalent API calls to identify reasons for failures like `CrashLoopBackOff`."
          }
        ],
        "usage_examples": [
          {
            "title": "Check Pod Status",
            "description": "Retrieve and print the status of all pods in a specific namespace.",
            "code": "from kubernetes import client, config\n\nconfig.load_kube_config()\nv1 = client.CoreV1Api()\nprint('Listing pods with their IPs:')\nret = v1.list_namespaced_pod(namespace='default')\nfor i in ret.items:\n    print(f'{i.status.pod_ip} - {i.metadata.name} ({i.status.phase})')",
            "expected_output": "Listing pods with their IPs:\n10.244.0.15 - nginx-deployment-6b474476c4-abc12 (Running)",
            "language": "python"
          },
          {
            "title": "Fetch Container Logs",
            "description": "Stream logs from a specific container within a pod for troubleshooting.",
            "code": "from kubernetes import client, config\n\nconfig.load_kube_config()\nv1 = client.CoreV1Api()\npod_name = 'web-server-pod'\nnamespace = 'default'\n\ntry:\n    api_response = v1.read_namespaced_pod_log(name=pod_name, namespace=namespace)\n    print(api_response)\nexcept Exception as e:\n    print(f'Error: {e}')",
            "expected_output": "[2023-10-27 10:00:01] INFO: Starting server on port 80\n[2023-10-27 10:00:05] GET /index.html 200",
            "language": "python"
          }
        ],
        "best_practices": [
          {
            "title": "Use Namespaces for Isolation",
            "description": "Always specify a namespace for resources to avoid cluttering the 'default' namespace and to enable better resource quota management and security boundaries.",
            "example": "metadata:\n  name: my-app\n  namespace: production"
          },
          {
            "title": "Define Resource Requests and Limits",
            "description": "Always set CPU and Memory requests/limits for containers to ensure the scheduler can place pods effectively and prevent individual pods from exhausting node resources.",
            "example": "resources:\n  requests:\n    memory: '64Mi'\n    cpu: '250m'\n  limits:\n    memory: '128Mi'\n    cpu: '500m'"
          },
          {
            "title": "Implement Liveness and Readiness Probes",
            "description": "Use probes to allow Kubernetes to automatically restart unhealthy containers and ensure traffic is only sent to pods that are ready to handle it.",
            "example": "readinessProbe:\n  httpGet:\n    path: /healthz\n    port: 8080"
          },
          {
            "title": "Prefer Declarative Management",
            "description": "Use YAML manifests and 'apply' logic rather than imperative 'run' or 'edit' commands to maintain a clear audit trail and compatibility with GitOps workflows.",
            "example": "kubectl apply -f deployment.yaml"
          }
        ],
        "integration_guide": "This skill is designed to be the execution component of a larger DevOps pipeline. It integrates seamlessly with `yaml_processing` skills to validate and transform templates (e.g., replacing placeholders in a `deployment.yaml`) before applying them to the cluster. When a deployment fails, the `cluster_observability` capability should be invoked to feed error logs back into a `troubleshooting_agent` skill for automated remediation.\n\nFor advanced orchestration, this skill serves as the foundational layer for `helm_package_management`. While this skill manages raw resources, Helm handles versioned releases of those resources. In CI/CD contexts, this skill is triggered after a `docker_build` skill successfully pushes a new image to a registry, updating the deployment manifest with the new image tag."
      },
      {
        "augmented": true,
        "skill_skeleton": "{\n  \"root_path\": \"technical_skills/devops/infrastructure_as_code/terraform\",\n  \"files\": [\n    {\n      \"path\": \"metadata.json\",\n      \"content_type\": \"json\",\n      \"description\": \"Skill metadata including versioning and capability definitions.\"\n    },\n    {\n      \"path\": \"SKILL.md\",\n      \"content_type\": \"markdown\",\n      \"description\": \"Main documentation for the Terraform management skill.\"\n    },\n    {\n      \"path\": \"capabilities/state_management.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Implementation of state backend configuration and migration logic.\"\n    },\n    {\n      \"path\": \"capabilities/resource_provisioning.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Core logic for init, plan, apply, and destroy operations.\"\n    },\n    {\n      \"path\": \"capabilities/module_development.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Tools for scaffolding and validating Terraform modules.\"\n    },\n    {\n      \"path\": \"capabilities/provider_configuration.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Logic for multi-provider setup and authentication checks.\"\n    },\n    {\n      \"path\": \"capabilities/refactoring.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Handlers for terraform state mv and refactoring workflows.\"\n    },\n    {\n      \"path\": \"references/hcl-patterns.md\",\n      \"content_type\": \"markdown\",\n      \"description\": \"Reference guide for HCL syntax and common resource patterns.\"\n    },\n    {\n      \"path\": \"examples/basic-ec2-module.tf\",\n      \"content_type\": \"text\",\n      \"description\": \"Example HCL for a basic AWS EC2 module.\"\n    },\n    {\n      \"path\": \"tests/test_state_migration.py\",\n      \"content_type\": \"python\",\n      \"description\": \"Integration tests for migrating state from local to remote backends.\"\n    }\n  ],\n  \"directories\": [\n    \"capabilities\",\n    \"examples\",\n    \"tests\",\n    \"resources\",\n    \"references\",\n    \"scripts\",\n    \"assets\"\n  ]\n}",
        "parent_skills": "[\n  {\n    \"skill_id\": \"technical_skills/devops/infrastructure_as_code\",\n    \"name\": \"infrastructure-as-code\",\n    \"relationship\": \"parent\"\n  },\n  {\n    \"skill_id\": \"technical_skills/cloud_computing\",\n    \"name\": \"cloud-computing\",\n    \"relationship\": \"dependency\"\n  }\n]",
        "composition_strategy": "This skill acts as an orchestrator within a DevOps pipeline. It consumes cloud architecture designs (from `technical_skills/cloud_computing`) and converts them into executable code. It is designed to be used in conjunction with version control skills to ensure that infrastructure changes are audited and peer-reviewed.\n\nIn a complex workflow, this skill handles the 'Provisioning' phase, which typically follows 'Design' and precedes 'Configuration Management' (e.g., Ansible) or 'Application Deployment'. It provides the necessary outputs (IP addresses, DNS names, ARN/IDs) that downstream skills require to perform software installation or service configuration.",
        "revision_feedback": "",
        "reasoning": "The Terraform management skill is designed as a core component of the Infrastructure as Code (IaC) hierarchy. It focuses on the full lifecycle of infrastructure—from initial scaffolding and provider setup to state management and complex refactoring. The structure emphasizes modularity (through module development) and reliability (through state management). This skill bridges the gap between high-level cloud architecture and operational reality, providing a programmatic way to manage cloud resources. The inclusion of refactoring capabilities acknowledges the long-term maintenance needs of infrastructure, while the integration guide highlights its role as a bridge between cloud design and configuration management.",
        "skill_content": "# Terraform Infrastructure Management\n\n## Overview\nThe Terraform Management skill provides a comprehensive framework for orchestrating infrastructure through HashiCorp Configuration Language (HCL). It enables the definition, provisioning, and management of cloud and on-premises resources in a predictable, version-controlled manner. This skill covers the entire Terraform lifecycle, including state management, provider configuration, module development, and safe infrastructure refactoring.\n\n## Capabilities\n- **State Management**: Configuration of remote backends (S3, GCS, Terraform Cloud), state locking, and secure migration of state files between environments.\n- **Resource Provisioning**: Execution of core Terraform workflows (`init`, `plan`, `apply`, `destroy`) with automated variable injection and output parsing.\n- **Module Development**: Scaffolding reusable, documented modules with standardized inputs, outputs, and validation rules to promote DRY (Don't Repeat Yourself) principles.\n- **Provider Configuration**: Management of multi-cloud and multi-region provider blocks, including authentication handling and version pinning.\n- **Infrastructure Refactoring**: Safe modification of existing infrastructure through `moved` blocks and state manipulation commands (`terraform state mv`) to minimize downtime and resource recreation.\n\n## Dependencies\n- `technical_skills/devops/infrastructure_as_code` (Parent context)\n- `technical_skills/cloud_computing` (Resource provider knowledge)\n- Terraform CLI (>= 1.5.0 recommended for `moved` block support)\n\n## Usage Examples\n### Provisioning a Basic Module\n```python\nfrom capabilities.resource_provisioning import TerraformOrchestrator\n\n# Initialize and apply a module\ntf = TerraformOrchestrator(workdir=\"./examples/basic-ec2-module\")\ntf.init()\nplan_path = tf.plan(vars={\"instance_type\": \"t3.micro\"})\ntf.apply(plan_path)\n\n# Access outputs for downstream tools\ninstance_ip = tf.get_output(\"public_ip\")\nprint(f\"Server deployed at: {instance_ip}\")\n```\n\n### State Migration\n```python\nfrom capabilities.state_management import StateManager\n\nmanager = StateManager(workdir=\"./infra\")\nmanager.configure_remote_backend(\n    bucket=\"my-terraform-state\",\n    region=\"us-east-1\",\n    dynamodb_table=\"terraform-lock\"\n)\nmanager.migrate_state() # Handles the 'terraform init -migrate-state' logic\n```",
        "capability_implementations": [
          {
            "name": "State Management",
            "content": "Implements logic for configuring backends and managing state files. It ensures state locking via DynamoDB or similar mechanisms to prevent concurrent modifications. Supports state sub-commands like `list`, `show`, and `pull/push` for disaster recovery scenarios."
          },
          {
            "name": "Resource Provisioning",
            "content": "Wraps the Terraform CLI to execute infrastructure changes. It includes logic to capture and parse `plan` files, ensuring that only approved changes are applied. It also handles the extraction of `outputs` in JSON format for consumption by other automation scripts."
          },
          {
            "name": "Module Development",
            "content": "Provides templates and validation logic for creating HCL modules. Enforces standards such as mandatory `variables.tf`, `outputs.tf`, and `main.tf` files, and validates HCL syntax and formatting using `terraform fmt` and `terraform validate`."
          },
          {
            "name": "Provider Configuration",
            "content": "Automates the setup of provider requirements. It handles the generation of `required_providers` blocks and manages credential injection for AWS, Azure, and GCP, supporting aliases for multi-region deployments."
          },
          {
            "name": "Refactoring",
            "content": "Facilitates the restructuring of HCL code without destroying resources. It automates the generation of `moved` blocks (introduced in Terraform 1.1) and provides a safe interface for `terraform state mv` operations when renaming resources or moving them into modules."
          }
        ],
        "usage_examples": [
          {
            "title": "Automated Plan and Apply",
            "description": "Demonstrates the standard workflow of initializing, planning, and applying infrastructure changes using the Resource Provisioning capability.",
            "code": "from capabilities.resource_provisioning import TerraformRunner\n\nrunner = TerraformRunner(directory='./prod-infra')\nrunner.init()\n\nsuccess, plan_output = runner.plan()\nif success:\n    print('Plan generated successfully.')\n    runner.apply()",
            "expected_output": "Plan generated successfully.\nApply complete! Resources: 5 added, 0 changed, 0 destroyed.",
            "language": "python"
          },
          {
            "title": "HCL Module Scaffolding",
            "description": "Using the Module Development capability to generate a standardized directory structure for a new infrastructure component.",
            "code": "from capabilities.module_development import ModuleScaffolder\n\nscaffolder = ModuleScaffolder(name='s3-static-site')\nscaffolder.create_structure(path='./modules')\nscaffolder.add_variable('bucket_name', type='string', description='Name of the S3 bucket')",
            "expected_output": "Created module structure at ./modules/s3-static-site\nUpdated variables.tf with bucket_name",
            "language": "python"
          },
          {
            "title": "State Resource Migration",
            "description": "Moving a resource from the root state into a module using the Refactoring capability.",
            "code": "from capabilities.refactoring import StateRefactor\n\nrefactor = StateRefactor(workdir='./infra')\n# Move aws_instance.web to module.web_server.aws_instance.this\nrefactor.move_resource('aws_instance.web', 'module.web_server.aws_instance.this')",
            "expected_output": "Successfully moved 1 object within the state.",
            "language": "python"
          }
        ],
        "best_practices": [
          {
            "title": "Always Use Remote State",
            "description": "Never store `terraform.tfstate` files locally or in version control. Use remote backends (S3, GCS, Azure Blob) with state locking enabled to ensure team collaboration and data safety.",
            "example": "terraform {\n  backend \"s3\" {\n    bucket = \"my-company-tfstate\"\n    key    = \"network/terraform.tfstate\"\n    region = \"us-east-1\"\n    dynamodb_table = \"tflock\"\n  }\n}"
          },
          {
            "title": "Pin Provider and Module Versions",
            "description": "To prevent breaking changes during automated runs, always pin providers and external modules to specific versions.",
            "example": "terraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}"
          },
          {
            "title": "Use Variables for Environment Differentiation",
            "description": "Avoid hardcoding values. Use `variables.tf` and `.tfvars` files to allow the same HCL code to deploy to Dev, Staging, and Production environments.",
            "example": "variable \"environment\" { type = string }\nresource \"aws_vpc\" \"main\" {\n  tags = { Name = \"vpc-${var.environment}\" }\n}"
          },
          {
            "title": "Implement 'Moved' Blocks for Refactoring",
            "description": "When renaming resources or moving them into modules, use HCL `moved` blocks instead of manual state manipulation to allow teammates to update their state automatically.",
            "example": "moved {\n  from = aws_instance.old_name\n  to   = aws_instance.new_name\n}"
          }
        ],
        "integration_guide": "The Terraform Management skill is a pivotal orchestrator in the DevOps lifecycle. It integrates directly with `cloud-computing` skills by consuming resource specifications (e.g., VPC CIDRs, instance types) and translating them into HCL. In a typical CI/CD pipeline, this skill should be triggered after code linting and before any configuration management tasks. It produces critical metadata (outputs) such as IP addresses or Load Balancer DNS names, which should be passed to downstream skills like Ansible or Kubernetes deployment operators via environment variables or dynamic inventory files.\n\nFor complex compositions, use this skill to manage the 'Foundational' layer (Networking, IAM, Databases) and provide the resulting ARNs or IDs to application-specific Terraform workspaces via `terraform_remote_state` data sources. This decoupling allows for independent scaling and security scoping of infrastructure components."
      },
      {
        "task_description": "Create a skill for AWS Lambda serverless functions including triggers, layers, and cold start optimization",
        "expected_taxonomy_path": "technical_skills/infrastructure/cloud/aws/lambda",
        "expected_name": "aws-lambda",
        "expected_type": "technical",
        "expected_weight": "medium",
        "expected_capabilities": [
          "function_creation",
          "trigger_configuration",
          "layer_management",
          "environment_variables",
          "cold_start_optimization",
          "logging_monitoring"
        ],
        "expected_dependencies": [],
        "expected_category": "technical_skills/infrastructure/cloud/aws",
        "expected_keywords": [
          "aws",
          "lambda",
          "serverless",
          "faas",
          "cloud"
        ],
        "expected_scope": "Covers AWS Lambda. Does NOT cover EC2 or ECS.",
        "expected_see_also": [
          "technical_skills/infrastructure/cloud/azure/functions"
        ]
      }
    ],
    "signature": {
      "instructions": "Generate comprehensive skill content with composition support.\n\nCreates the main SKILL.md content and supporting documentation.\nNote: YAML frontmatter will be added automatically during registration.\n\nThe skill_content MUST include these sections:\n- # Title (skill name as heading)\n- ## Overview (what the skill does)\n- ## Capabilities (list of discrete capabilities)\n- ## Dependencies (required skills or 'No dependencies')\n- ## Usage Examples (code examples with expected output)",
      "fields": [
        {
          "prefix": "Skill Skeleton:",
          "description": "JSON skill skeleton structure"
        },
        {
          "prefix": "Parent Skills:",
          "description": "Content/metadata from parent/sibling skills for context"
        },
        {
          "prefix": "Composition Strategy:",
          "description": "How this skill composes with others"
        },
        {
          "prefix": "Revision Feedback:",
          "description": "User feedback from previous revision to incorporate (empty if initial generation)"
        },
        {
          "prefix": "Reasoning: Let's think step by step in order to",
          "description": "${reasoning}"
        },
        {
          "prefix": "Skill Content:",
          "description": "Full SKILL.md markdown body content (frontmatter added automatically).\n        Must include: # Title, ## Overview, ## Capabilities, ## Dependencies, ## Usage Examples.\n        Include code blocks with syntax highlighting (```python, ```bash, etc.)."
        },
        {
          "prefix": "Capability Implementations:",
          "description": "Documentation content for each capability"
        },
        {
          "prefix": "Usage Examples:",
          "description": "Runnable usage examples with code and expected output"
        },
        {
          "prefix": "Best Practices:",
          "description": "Best practice recommendations (3-5 items)"
        },
        {
          "prefix": "Integration Guide:",
          "description": "Integration notes and composition patterns (1-2 paragraphs)"
        }
      ]
    },
    "lm": null
  },
  "package.package.predict": {
    "traces": [],
    "train": [],
    "demos": [],
    "signature": {
      "instructions": "You are a Senior DevOps Quality Assurance Engineer specializing in automated skill taxonomy and professional competency frameworks. Your objective is to act as the final gatekeeper for the `agentskills.io` platform, ensuring that every generated skill is technically sound, structurally consistent, and ready for production deployment.\n\nPerform a rigorous cross-validation of the provided skill artifacts and generate the following:\n\n1. **Reasoning**: Conduct a step-by-step analysis comparing `skill_content`, `skill_metadata`, and `capability_implementations`. Identify any discrepancies in naming conventions, taxonomy paths, or dependency declarations.\n2. **Validation Report**: Evaluate the skill against the standard schema. \n    - Mark as `passed=True` only if there are no critical errors. \n    - Issue `warnings` for minor inconsistencies (e.g., dependencies listed in Markdown but missing in JSON). \n    - Provide a checklist of specific validations (Schema, Taxonomy, Capability Mapping, Code Linting).\n3. **Integration Tests**: Generate 3-5 concrete `TestCase` objects derived from the usage examples and capability descriptions. Each test must specify clear `input_data` and the `expected_result` to verify the skill's runtime logic.\n4. **Packaging Manifest**: Create a formal inventory of all required files (e.g., `SKILL.md`, `metadata.json`) and generate a unique checksum for the package.\n5. **Quality Score**: Assign a final score (0.0 to 1.0). A high score (0.9+) requires perfect alignment between metadata and documentation, syntactically correct code blocks, and clear compliance with the taxonomy path.\n\nEnsure all outputs adhere strictly to the `agentskills.io` specification, using kebab-case for names and forward-slash notation for taxonomy paths.",
      "fields": [
        {
          "prefix": "Skill Content:",
          "description": "Generated SKILL.md content"
        },
        {
          "prefix": "Skill Metadata:",
          "description": "JSON skill metadata"
        },
        {
          "prefix": "Taxonomy Path:",
          "description": "Taxonomy path"
        },
        {
          "prefix": "Capability Implementations:",
          "description": "JSON capability documentation"
        },
        {
          "prefix": "Reasoning: Let's think step by step in order to",
          "description": "${reasoning}"
        },
        {
          "prefix": "Validation Report:",
          "description": "Validation results with pass/fail, errors, and warnings"
        },
        {
          "prefix": "Integration Tests:",
          "description": "Test cases to verify skill functionality"
        },
        {
          "prefix": "Packaging Manifest:",
          "description": "Manifest describing the packaged skill"
        },
        {
          "prefix": "Quality Score:",
          "description": "Overall quality score (0.0-1.0)"
        }
      ]
    },
    "lm": null
  },
  "metadata": {
    "dependency_versions": {
      "python": "3.13",
      "dspy": "3.1.0",
      "cloudpickle": "3.1"
    }
  }
}


============================================================
END FILE: config/optimized/skill_creator_miprov2.json
============================================================

============================================================
FILE: config/profiles/bootstrap_profiles.json
============================================================

{
  "bootstrap_profiles": {
    "web_developer": {
      "required": [
        "technical_skills/programming/languages/javascript_typescript",
        "technical_skills/programming/paradigms/object_oriented",
        "tool_proficiency/development_tools/version_control",
        "specializations/frontend_development",
        "task_focus_areas/build_create"
      ],
      "on_demand": [
        "technical_skills/infrastructure/containerization",
        "specializations/backend_development",
        "technical_skills/apis_integration/rest_apis"
      ]
    },
    "backend_developer": {
      "required": [
        "technical_skills/programming/languages/python",
        "technical_skills/data_engineering/storage/relational_databases",
        "technical_skills/apis_integration/rest_apis",
        "specializations/backend_development",
        "task_focus_areas/build_create"
      ],
      "on_demand": [
        "technical_skills/infrastructure/cloud_platforms",
        "technical_skills/security/authentication_authorization",
        "domain_knowledge/business_intelligence"
      ]
    },
    "data_scientist": {
      "required": [
        "technical_skills/programming/languages/python",
        "domain_knowledge/machine_learning",
        "technical_skills/data_engineering/processing/etl_pipelines",
        "tool_proficiency/data_tools/visualization_tools",
        "task_focus_areas/research_explore"
      ],
      "on_demand": [
        "domain_knowledge/nlp_understanding",
        "domain_knowledge/computer_vision",
        "technical_skills/data_engineering/storage/vector_databases"
      ]
    },
    "ml_engineer": {
      "required": [
        "technical_skills/programming/languages/python",
        "domain_knowledge/machine_learning",
        "specializations/ai_ml_engineering",
        "technical_skills/infrastructure/cloud_platforms",
        "task_focus_areas/build_create"
      ],
      "on_demand": [
        "domain_knowledge/nlp_understanding",
        "technical_skills/infrastructure/containerization",
        "task_focus_areas/optimize_improve"
      ]
    },
    "devops_engineer": {
      "required": [
        "technical_skills/infrastructure/cloud_platforms",
        "technical_skills/infrastructure/containerization",
        "technical_skills/infrastructure/infrastructure_as_code",
        "specializations/devops_sre",
        "task_focus_areas/maintain_support"
      ],
      "on_demand": [
        "technical_skills/programming/languages/shell_scripting",
        "tool_proficiency/monitoring_observability",
        "technical_skills/security"
      ]
    },
    "general_purpose": {
      "required": [
        "cognitive_skills/analysis",
        "cognitive_skills/synthesis",
        "cognitive_skills/reasoning",
        "task_focus_areas/build_create"
      ],
      "on_demand": [
        "technical_skills/programming/languages/python",
        "tool_proficiency/development_tools",
        "task_focus_areas/debug_fix"
      ]
    }
  },
  "tech_stack_mapping": {
    "JavaScript/TypeScript": [
      "technical_skills/programming/languages/javascript_typescript"
    ],
    "Python": [
      "technical_skills/programming/languages/python"
    ],
    "React": [
      "specializations/frontend_development/react_ecosystem"
    ],
    "Node.js": [
      "technical_skills/programming/languages/javascript_typescript/node_runtime"
    ],
    "Docker": [
      "technical_skills/infrastructure/containerization/docker"
    ],
    "Kubernetes": [
      "technical_skills/infrastructure/containerization/kubernetes"
    ],
    "AWS": [
      "technical_skills/infrastructure/cloud_platforms/aws_services"
    ],
    "PostgreSQL": [
      "technical_skills/data_engineering/storage/relational_databases"
    ],
    "MongoDB": [
      "technical_skills/data_engineering/storage/nosql_databases"
    ]
  },
  "task_mapping": {
    "Building new features": [
      "task_focus_areas/build_create"
    ],
    "Debugging issues": [
      "task_focus_areas/debug_fix"
    ],
    "Performance optimization": [
      "task_focus_areas/optimize_improve"
    ],
    "Code review": [
      "cognitive_skills/analysis/code_analysis"
    ],
    "Writing tests": [
      "technical_skills/programming/practices/testing"
    ],
    "Documentation": [
      "cognitive_skills/synthesis/content_generation/documentation"
    ],
    "Data analysis": [
      "cognitive_skills/analysis/data_analysis"
    ],
    "API design": [
      "cognitive_skills/synthesis/design_synthesis/api_design"
    ]
  }
}


============================================================
END FILE: config/profiles/bootstrap_profiles.json
============================================================

============================================================
FILE: config/templates/SKILL_md_template.md
============================================================

{{!--
SKILL.md Template - skill-fleet Convention

Spec: https://agentskills.io/specification
Authoring: See writing-skills for TDD-based skill creation process

═══════════════════════════════════════════════════════════════════
TOKEN BUDGET (Critical for agent context efficiency)
═══════════════════════════════════════════════════════════════════

Frontmatter: ~100 tokens (name + description injected into XML prompt)
Body by skill type: - Getting-started/frequent: <150 words - Standard skills: <500 words

- Complex technical: <5000 tokens (~500 lines max)

Use subdirectories for deep dives that load on demand.

═══════════════════════════════════════════════════════════════════
DIRECTORY STRUCTURE (v2 convention)
═══════════════════════════════════════════════════════════════════

MINIMAL (most common - start here):
skill-name/
└── SKILL.md # Required - main skill document

WITH SUBDIRECTORIES (add only when needed):
skill-name/
├── SKILL.md # Required - main skill document
├── references/ # Optional - deep-dive documentation, API refs
│ └── advanced.md
├── guides/ # Optional - step-by-step procedures, tutorials
│ └── setup.md
├── templates/ # Optional - reusable code templates, boilerplate
│ └── starter.py
├── scripts/ # Optional - automation scripts, tooling
│ └── setup.sh
└── examples/ # Optional - runnable demos, sample code
└── basic.py

Note: metadata.json is optional (for backward compatibility with v1 skills).

═══════════════════════════════════════════════════════════════════
FRONTMATTER (agentskills.io compliant)
═══════════════════════════════════════════════════════════════════

REQUIRED:
name: Max 64 chars. Lowercase + hyphens only. Must match directory.
description: Max 1024 chars. See CSO section below.

OPTIONAL (moved to metadata.json):
license: LICENSE file reference (use metadata.json instead)
compatibility: Max 500 chars. Environment requirements (use metadata.json instead)
allowed-tools: Space-delimited tool list (use metadata.json instead)

NOTE: Complex tooling data (skill_id, version, type, weight, load_priority) belongs in metadata.json ONLY.
This keeps frontmatter minimal and separates concerns: discovery (SKILL.md) vs. taxonomy (metadata.json)

═══════════════════════════════════════════════════════════════════
CLAUDE SEARCH OPTIMIZATION (CSO) - Critical for Discovery
═══════════════════════════════════════════════════════════════════

Description = WHEN to use, NOT WHAT it does

The description field determines if Claude loads your skill.
If you summarize the workflow, Claude may follow the description
instead of reading the full skill content.

❌ BAD: Summarizes workflow (Claude takes shortcut)
description: Use when executing plans - dispatches subagent per task with code review

❌ BAD: Too vague
description: For async testing

✅ GOOD: Triggering conditions only
description: Use when building FastAPI apps with async database operations, connection pool issues, or partial update bugs

✅ GOOD: Symptoms and error messages
description: Use when tests have race conditions, timing dependencies, or pass/fail inconsistently

Include in description: - Concrete triggers and symptoms - Error messages agents might search for - Technology names if skill is technology-specific

Do NOT include: - Process steps or workflow summary - What the skill teaches (save for Overview)

═══════════════════════════════════════════════════════════════════
ANTI-PATTERNS (from writing-skills)
═══════════════════════════════════════════════════════════════════

❌ Narrative examples: "In session 2025-10-03, we found..."
→ Too specific, not reusable

❌ Multi-language dilution: example-js.js, example-py.py, example-go.go
→ Mediocre quality, maintenance burden. One excellent example beats many.

❌ Code in flowcharts: step1 [label="import fs"]
→ Can't copy-paste, hard to read

❌ Generic labels: helper1, step2, pattern4
→ Labels should have semantic meaning

## --}}

---

name: {{skill_name_kebab}}
description: Use when {{triggering_conditions}}

---

# {{skill_name}}

## Overview

{{overview_description}}

**Core principle:** {{core_principle}}

## Capabilities

{{!-- List 3-8 concrete, testable capabilities. Prefer short verb phrases. --}}

- {{capability_1}}
- {{capability_2}}
- {{capability_3}}

## Dependencies

{{!-- List prerequisite skills/tools AND why they matter. Keep it scannable. --}}

- {{dependency_1}} — {{why_dependency_1}}
- {{dependency_2}} — {{why_dependency_2}}

## When to Use

{{!-- Optional: Include decision flowchart for non-obvious decisions

```dot
digraph when_to_use {
    "Building X?" [shape=diamond];
    "Has symptom Y?" [shape=diamond];
    "Use this skill" [shape=box];
    "Use other approach" [shape=box];

    "Building X?" -> "Has symptom Y?" [label="yes"];
    "Has symptom Y?" -> "Use this skill" [label="yes"];
    "Has symptom Y?" -> "Use other approach" [label="no"];
}
```

--}}

**Use when:**
{{#each use_when}}

- {{this}}
  {{/each}}

**When NOT to use:**
{{#each not_use_when}}

- {{this}}
  {{/each}}

## Quick Reference

| Problem | Solution | Keywords |
| ------- | -------- | -------- |

{{#each quick_reference}}
| {{problem}} | {{solution}} |
{{/each}}

## Core Patterns

### {{pattern_name}}

**The problem:** {{problem_description}}

**❌ Common mistake:**

```{{language}}
{{bad_example}}
```

**✅ Production pattern:**

```{{language}}
{{good_example}}
```

**Key insight:** {{key_insight}}

{{!-- For complex skills with multiple reference documents, link to references/ --}}
{{#if references}}

> **Deep dives:** See `references/` for detailed documentation:
> {{#each references}}
>
> - [{{this}}](references/{{this}}.md)
>   {{/each}}
>   {{/if}}

## Usage Examples

{{!-- Include at least 1–3 runnable examples with fenced code blocks. --}}

### {{example_title}}

{{example_description}}

```{{language}}
{{example_code}}
```

## Common Mistakes

| Mistake | Why It's Wrong | Fix |
| ------- | -------------- | --- |

{{#each common_mistakes}}
| {{mistake}} | {{why_wrong}} | {{fix}} |
{{/each}}

{{#if real_world_impact}}

## Real-World Impact

{{#each real_world_impact}}

- {{this}}
  {{/each}}
  {{/if}}

## Strong Guidance

{{!-- Iron Law style rules – imperative statements that MUST be followed --}}

{{#if strong_guidance}}
{{#each strong_guidance}}

- **{{this}}**
  {{/each}}
  {{else}}
- **NO [action] WITHOUT [prerequisite]** — [explanation]
- **ALWAYS [action]** — [explanation]
- **NEVER [action]** — [explanation]
  {{/if}}

## Red Flags

{{#each red_flags}}

- {{this}}
  {{/each}}

**All of these mean: Revisit your approach before proceeding.**

---

## Real-World Impact

{{#if real_world_impact}}
{{#each real_world_impact}}

- {{this}}
{{/each}}
{{else}}
- Describe measurable impact: What improves when agents use this skill?
{{/if}}

---

## Validation

```bash
# Validate the skill directory
uv run skill-fleet validate skills/{{category}}/{{skill_name_kebab}}

# Ensure metadata.json is valid
uv run python -c "import json; json.load(open('skills/{{category}}/{{skill_name_kebab}}/metadata.json'))"

# Generate skills XML (discover all skills)
uv run skill-fleet generate-xml

# Promote draft to taxonomy (when ready)
uv run skill-fleet promote {{job_id}}
```

**Authoring process:** See `writing-skills` for TDD-based skill creation checklist.

**v0.2 Changes** (Jan 2026):
- Frontmatter: `name` and `description` ONLY (minimal, CSO-optimized)
- Tooling metadata: Moved to `metadata.json` (separate concerns)
- New section: Real-World Impact (measurable outcomes)


============================================================
END FILE: config/templates/SKILL_md_template.md
============================================================

============================================================
FILE: config/templates/metadata_template.json
============================================================

{
  "$schema": "https://skill-fleet.dev/schemas/metadata.json",
  "_comment": [
    "skill-fleet Metadata Template",
    "",
    "This file contains tooling-specific metadata separate from SKILL.md frontmatter.",
    "Frontmatter (name, description) is the source of truth for agent discovery.",
    "This file extends with skill-fleet specific fields for taxonomy, evolution, and tooling.",
    "",
    "DO NOT duplicate name/description here - they belong in SKILL.md frontmatter only."
  ],

  "skill_id": "{{taxonomy_path}}/{{skill_name_kebab}}",
  "name": "{{skill_name_kebab}}",
  "description": "{{description}}",

  "version": "1.0.0",
  "type": "{{type}}",
  "weight": "{{weight}}",
  "load_priority": "{{load_priority}}",

  "dependencies": [],

  "capabilities": ["{{capability_1}}", "{{capability_2}}"],

  "category": "{{category}}",
  "tags": ["{{tag_1}}", "{{tag_2}}"],

  "created_at": "{{created_at}}",
  "last_modified": "{{last_modified}}",

  "evolution": {
    "version": "1.0.0",
    "parent_id": null,
    "evolution_path": "initial_release",
    "change_log": "{{change_log}}",
    "validation_score": null,
    "integrity_hash": null
  }
}


============================================================
END FILE: config/templates/metadata_template.json
============================================================

============================================================
FILE: config/training/archive/gold_skills_v1.json
============================================================

{
  "version": "1.0",
  "skills": [
    {
      "skill_id": "technical/programming/web-frameworks/python/fastapi",
      "task_description": "Create a high-quality FastAPI production-ready skill with lifecycle management, async database patterns, and testing strategies.",
      "skill_path": "skills/technical_skills/programming/web_frameworks/python/fastapi/SKILL.md",
      "quality_score": 0.855,
      "source": "local",
      "metadata": {
        "curated": true
      }
    },
    {
      "skill_id": "technical_skills/web_development/frontend/react/vite-tailwind-setup",
      "task_description": "Create a modern React frontend setup skill using Vite and Tailwind CSS, focusing on build optimization and developer experience.",
      "skill_path": "skills/technical_skills/web_development/frontend/react/vite/SKILL.md",
      "quality_score": 0.758,
      "source": "local",
      "metadata": {
        "curated": true
      }
    },
    {
      "skill_id": "technical_skills/web_development/frontend/react/react-vite-production-setup",
      "task_description": "Create a production-ready React setup with Vite, including advanced patterns and performance considerations.",
      "skill_path": "skills/technical_skills/web_development/frontend/react/react-vite-production-setup/SKILL.md",
      "quality_score": 0.720,
      "source": "local",
      "metadata": {
        "curated": true
      }
    },
    {
      "skill_id": "technical_skills/programming/languages/python/decorators",
      "task_description": "Create a comprehensive Python decorators skill with preserving metadata, parameterized factories, and async support.",
      "skill_path": "skills/technical_skills/programming/languages/python/decorators/SKILL.md",
      "quality_score": 0.930,
      "source": "local",
      "metadata": {
        "curated": true
      }
    }
  ]
}


============================================================
END FILE: config/training/archive/gold_skills_v1.json
============================================================

============================================================
FILE: config/training/archive/trainset_v1.json
============================================================

[
  {
    "task_description": "Create a Python async programming skill covering asyncio, event loops, coroutines, and concurrent execution patterns",
    "expected_taxonomy_path": "technical_skills/programming/languages/python/asynchronous_programming",
    "expected_name": "python-async",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "async_await_syntax",
      "event_loop_management",
      "concurrent_execution",
      "task_creation",
      "exception_handling"
    ],
    "expected_dependencies": ["technical_skills/programming/languages/python"],
    "expected_category": "technical_skills/programming/languages/python",
    "expected_keywords": [
      "asyncio",
      "async",
      "await",
      "coroutines",
      "event-loop",
      "concurrent",
      "python",
      "asynchronous"
    ],
    "expected_scope": "Covers Python asyncio library, async/await syntax, event loops, and concurrent task execution. Does NOT cover threading, multiprocessing, or third-party async libraries like trio or anyio.",
    "expected_see_also": [
      "technical_skills/programming/languages/python/threading",
      "technical_skills/programming/languages/python/multiprocessing"
    ]
  },
  {
    "task_description": "Create a skill for building REST APIs with FastAPI framework including routing, validation, and dependency injection",
    "expected_taxonomy_path": "technical_skills/programming/web_frameworks/python/fastapi",
    "expected_name": "python-fastapi",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "route_definition",
      "request_validation",
      "response_models",
      "dependency_injection",
      "async_endpoints",
      "openapi_documentation"
    ],
    "expected_dependencies": [
      "technical_skills/programming/languages/python",
      "technical_skills/programming/languages/python/asynchronous_programming"
    ],
    "expected_category": "technical_skills/programming/web_frameworks/python",
    "expected_keywords": [
      "fastapi",
      "rest",
      "api",
      "web",
      "python",
      "pydantic",
      "openapi",
      "swagger",
      "async"
    ],
    "expected_scope": "Covers FastAPI framework for building REST APIs including routing, validation with Pydantic, dependency injection, and OpenAPI documentation. Does NOT cover Flask, Django, or frontend development.",
    "expected_see_also": [
      "technical_skills/programming/web_frameworks/python/flask",
      "technical_skills/programming/web_frameworks/python/django"
    ]
  },
  {
    "task_description": "Create a skill for Python decorator patterns and metaprogramming techniques",
    "expected_taxonomy_path": "technical_skills/programming/languages/python/decorators",
    "expected_name": "python-decorators",
    "expected_type": "technical",
    "expected_weight": "lightweight",
    "expected_capabilities": [
      "basic_decorators",
      "parameterized_decorators",
      "class_decorators",
      "functools_wraps",
      "decorator_stacking"
    ],
    "expected_dependencies": ["technical_skills/programming/languages/python"],
    "expected_category": "technical_skills/programming/languages/python",
    "expected_keywords": [
      "decorator",
      "python",
      "metaprogramming",
      "functools",
      "wrapper",
      "annotation"
    ],
    "expected_scope": "Covers Python decorator patterns including function decorators, class decorators, parameterized decorators, and functools utilities. Does NOT cover metaclasses or advanced descriptor protocols.",
    "expected_see_also": [
      "technical_skills/programming/languages/python/metaclasses",
      "technical_skills/programming/languages/python/descriptors"
    ]
  },
  {
    "task_description": "Create a skill for Git version control workflows including branching, merging, and rebasing strategies",
    "expected_taxonomy_path": "tool_proficiency/version_control/git",
    "expected_name": "git-workflows",
    "expected_type": "tool",
    "expected_weight": "medium",
    "expected_capabilities": [
      "branching_strategies",
      "merge_workflows",
      "rebase_techniques",
      "conflict_resolution",
      "history_management",
      "git_hooks"
    ],
    "expected_dependencies": [],
    "expected_category": "tool_proficiency/version_control",
    "expected_keywords": [
      "git",
      "version-control",
      "branching",
      "merge",
      "rebase",
      "github",
      "gitlab",
      "vcs"
    ],
    "expected_scope": "Covers Git version control including branching strategies (GitFlow, trunk-based), merging, rebasing, conflict resolution, and hooks. Does NOT cover other VCS systems like SVN or Mercurial.",
    "expected_see_also": [
      "tool_proficiency/version_control/github",
      "tool_proficiency/ci_cd/github_actions"
    ]
  },
  {
    "task_description": "Create a skill for debugging Python applications using pdb, logging, and profiling tools",
    "expected_taxonomy_path": "task_focus_areas/debug_fix/python_debugging",
    "expected_name": "python-debugging",
    "expected_type": "task_focus",
    "expected_weight": "medium",
    "expected_capabilities": [
      "pdb_debugging",
      "logging_configuration",
      "stack_trace_analysis",
      "profiling",
      "memory_debugging"
    ],
    "expected_dependencies": ["technical_skills/programming/languages/python"],
    "expected_category": "task_focus_areas/debug_fix",
    "expected_keywords": [
      "debug",
      "pdb",
      "logging",
      "profiling",
      "python",
      "traceback",
      "breakpoint",
      "memory"
    ],
    "expected_scope": "Covers Python debugging with pdb, logging configuration, stack trace analysis, CPU/memory profiling. Does NOT cover IDE-specific debuggers or production monitoring tools.",
    "expected_see_also": [
      "task_focus_areas/debug_fix/general_debugging",
      "tool_proficiency/monitoring/python_apm"
    ]
  },
  {
    "task_description": "Create a skill for writing effective unit tests with pytest including fixtures, mocking, and parametrization",
    "expected_taxonomy_path": "technical_skills/programming/testing/python/pytest",
    "expected_name": "python-pytest",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "test_organization",
      "fixtures",
      "parametrization",
      "mocking",
      "assertions",
      "test_coverage"
    ],
    "expected_dependencies": ["technical_skills/programming/languages/python"],
    "expected_category": "technical_skills/programming/testing/python",
    "expected_keywords": [
      "pytest",
      "testing",
      "unit-test",
      "fixtures",
      "mocking",
      "tdd",
      "python",
      "coverage"
    ],
    "expected_scope": "Covers pytest framework including fixtures, parametrization, mocking with pytest-mock, and coverage reporting. Does NOT cover unittest, nose, or integration/e2e testing frameworks.",
    "expected_see_also": [
      "technical_skills/programming/testing/python/unittest",
      "technical_skills/programming/testing/integration"
    ]
  },
  {
    "task_description": "Create a skill for Docker containerization including Dockerfile writing, image optimization, and multi-stage builds",
    "expected_taxonomy_path": "tool_proficiency/containerization/docker",
    "expected_name": "docker-basics",
    "expected_type": "tool",
    "expected_weight": "medium",
    "expected_capabilities": [
      "dockerfile_creation",
      "image_optimization",
      "multi_stage_builds",
      "volume_management",
      "network_configuration",
      "docker_compose"
    ],
    "expected_dependencies": [],
    "expected_category": "tool_proficiency/containerization",
    "expected_keywords": [
      "docker",
      "container",
      "dockerfile",
      "image",
      "compose",
      "devops",
      "deployment"
    ],
    "expected_scope": "Covers Docker containerization including Dockerfile creation, image optimization, multi-stage builds, volumes, networks, and Docker Compose. Does NOT cover Kubernetes, Podman, or container orchestration.",
    "expected_see_also": [
      "tool_proficiency/containerization/kubernetes",
      "tool_proficiency/containerization/podman"
    ]
  },
  {
    "task_description": "Create a skill for SQL database design and query optimization",
    "expected_taxonomy_path": "technical_skills/data_engineering/databases/sql",
    "expected_name": "sql-fundamentals",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "schema_design",
      "query_writing",
      "joins",
      "indexing",
      "query_optimization",
      "transactions"
    ],
    "expected_dependencies": [],
    "expected_category": "technical_skills/data_engineering/databases",
    "expected_keywords": [
      "sql",
      "database",
      "query",
      "schema",
      "joins",
      "indexing",
      "postgresql",
      "mysql"
    ],
    "expected_scope": "Covers SQL fundamentals including schema design, query writing, joins, indexing, optimization, and transactions. Does NOT cover NoSQL databases, ORMs, or database administration.",
    "expected_see_also": [
      "technical_skills/data_engineering/databases/nosql",
      "technical_skills/data_engineering/databases/orm"
    ]
  },
  {
    "task_description": "Create a skill for TypeScript type system including generics, utility types, and type guards",
    "expected_taxonomy_path": "technical_skills/programming/languages/typescript/type_system",
    "expected_name": "typescript-types",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "basic_types",
      "interfaces",
      "generics",
      "utility_types",
      "type_guards",
      "conditional_types"
    ],
    "expected_dependencies": [
      "technical_skills/programming/languages/javascript"
    ],
    "expected_category": "technical_skills/programming/languages/typescript",
    "expected_keywords": [
      "typescript",
      "types",
      "generics",
      "interfaces",
      "type-guards",
      "javascript",
      "static-typing"
    ],
    "expected_scope": "Covers TypeScript type system including basic types, interfaces, generics, utility types, type guards, and conditional types. Does NOT cover TypeScript runtime, build tools, or framework-specific typing.",
    "expected_see_also": [
      "technical_skills/programming/languages/javascript",
      "technical_skills/programming/languages/typescript/compiler"
    ]
  },
  {
    "task_description": "Create a skill for code review best practices including review checklists, feedback patterns, and common issues",
    "expected_taxonomy_path": "task_focus_areas/code_quality/code_review",
    "expected_name": "code-review",
    "expected_type": "task_focus",
    "expected_weight": "lightweight",
    "expected_capabilities": [
      "review_checklists",
      "feedback_patterns",
      "common_issues",
      "security_review",
      "performance_review"
    ],
    "expected_dependencies": [],
    "expected_category": "task_focus_areas/code_quality",
    "expected_keywords": [
      "code-review",
      "pull-request",
      "feedback",
      "quality",
      "checklist",
      "best-practices"
    ],
    "expected_scope": "Covers code review best practices including checklists, constructive feedback patterns, common issues to look for, security and performance review. Does NOT cover automated code analysis tools or CI/CD integration.",
    "expected_see_also": [
      "task_focus_areas/code_quality/static_analysis",
      "task_focus_areas/code_quality/linting"
    ]
  },
  {
    "task_description": "Create a skill for Kubernetes pod management including deployments, services, ConfigMaps, and secrets",
    "expected_taxonomy_path": "tool_proficiency/containerization/kubernetes/core_concepts",
    "expected_name": "kubernetes-core",
    "expected_type": "tool",
    "expected_weight": "heavy",
    "expected_capabilities": [
      "pod_management",
      "deployment_configuration",
      "service_networking",
      "configmap_secrets",
      "resource_limits",
      "health_checks"
    ],
    "expected_dependencies": ["tool_proficiency/containerization/docker"],
    "expected_category": "tool_proficiency/containerization/kubernetes",
    "expected_keywords": [
      "kubernetes",
      "k8s",
      "pods",
      "deployment",
      "service",
      "configmap"
    ],
    "expected_scope": "Covers Kubernetes core concepts. Does NOT cover Helm or service mesh.",
    "expected_see_also": ["tool_proficiency/containerization/docker"]
  },
  {
    "task_description": "Create a skill for GitHub Actions CI/CD workflows including jobs, matrix builds, and secrets management",
    "expected_taxonomy_path": "tool_proficiency/ci_cd/github_actions",
    "expected_name": "github-actions-ci",
    "expected_type": "tool",
    "expected_weight": "medium",
    "expected_capabilities": [
      "workflow_syntax",
      "job_configuration",
      "matrix_builds",
      "secrets_management",
      "artifact_handling",
      "reusable_workflows"
    ],
    "expected_dependencies": ["tool_proficiency/version_control/git"],
    "expected_category": "tool_proficiency/ci_cd",
    "expected_keywords": [
      "github-actions",
      "ci-cd",
      "workflow",
      "pipeline",
      "automation"
    ],
    "expected_scope": "Covers GitHub Actions CI/CD. Does NOT cover Jenkins or CircleCI.",
    "expected_see_also": ["tool_proficiency/version_control/github"]
  },
  {
    "task_description": "Create a skill for React hooks including useState, useEffect, useContext, and custom hooks",
    "expected_taxonomy_path": "technical_skills/programming/web_frameworks/javascript/react/hooks",
    "expected_name": "react-hooks",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "state_hooks",
      "effect_hooks",
      "context_hooks",
      "reducer_hooks",
      "custom_hooks",
      "hook_rules"
    ],
    "expected_dependencies": [
      "technical_skills/programming/languages/javascript"
    ],
    "expected_category": "technical_skills/programming/web_frameworks/javascript/react",
    "expected_keywords": [
      "react",
      "hooks",
      "useState",
      "useEffect",
      "frontend"
    ],
    "expected_scope": "Covers React hooks. Does NOT cover class components or Redux.",
    "expected_see_also": ["technical_skills/programming/languages/javascript"]
  },
  {
    "task_description": "Create a skill for AWS Lambda serverless functions including triggers, layers, and cold start optimization",
    "expected_taxonomy_path": "technical_skills/infrastructure/cloud/aws/lambda",
    "expected_name": "aws-lambda",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "function_creation",
      "trigger_configuration",
      "layer_management",
      "environment_variables",
      "cold_start_optimization",
      "logging_monitoring"
    ],
    "expected_dependencies": [],
    "expected_category": "technical_skills/infrastructure/cloud/aws",
    "expected_keywords": ["aws", "lambda", "serverless", "faas", "cloud"],
    "expected_scope": "Covers AWS Lambda. Does NOT cover EC2 or ECS.",
    "expected_see_also": [
      "technical_skills/infrastructure/cloud/azure/functions"
    ]
  },
  {
    "task_description": "Create a skill for Terraform infrastructure as code including modules, state management, and providers",
    "expected_taxonomy_path": "tool_proficiency/infrastructure_as_code/terraform",
    "expected_name": "terraform-basics",
    "expected_type": "tool",
    "expected_weight": "heavy",
    "expected_capabilities": [
      "provider_configuration",
      "resource_definition",
      "module_creation",
      "state_management",
      "workspace_management",
      "plan_apply_workflow"
    ],
    "expected_dependencies": [],
    "expected_category": "tool_proficiency/infrastructure_as_code",
    "expected_keywords": [
      "terraform",
      "iac",
      "infrastructure",
      "hcl",
      "modules"
    ],
    "expected_scope": "Covers Terraform basics. Does NOT cover Pulumi or CloudFormation.",
    "expected_see_also": ["tool_proficiency/infrastructure_as_code/pulumi"]
  },
  {
    "task_description": "Create a skill for Go error handling patterns including wrapping, sentinel errors, and custom error types",
    "expected_taxonomy_path": "technical_skills/programming/languages/go/error_handling",
    "expected_name": "go-errors",
    "expected_type": "technical",
    "expected_weight": "lightweight",
    "expected_capabilities": [
      "error_wrapping",
      "sentinel_errors",
      "custom_error_types",
      "error_inspection",
      "panic_recover",
      "error_formatting"
    ],
    "expected_dependencies": ["technical_skills/programming/languages/go"],
    "expected_category": "technical_skills/programming/languages/go",
    "expected_keywords": ["go", "golang", "errors", "error-handling", "panic"],
    "expected_scope": "Covers Go error handling. Does NOT cover logging frameworks.",
    "expected_see_also": [
      "technical_skills/programming/languages/go/concurrency"
    ]
  },
  {
    "task_description": "Create a skill for prompt engineering techniques including chain-of-thought, few-shot learning, and system prompts",
    "expected_taxonomy_path": "cognitive_skills/reasoning/prompt_engineering",
    "expected_name": "prompt-engineering",
    "expected_type": "cognitive",
    "expected_weight": "medium",
    "expected_capabilities": [
      "chain_of_thought",
      "few_shot_learning",
      "system_prompts",
      "output_formatting",
      "role_playing",
      "prompt_chaining"
    ],
    "expected_dependencies": [],
    "expected_category": "cognitive_skills/reasoning",
    "expected_keywords": [
      "prompt",
      "llm",
      "ai",
      "chain-of-thought",
      "few-shot"
    ],
    "expected_scope": "Covers prompt engineering. Does NOT cover fine-tuning or RAG.",
    "expected_see_also": ["cognitive_skills/reasoning/task_decomposition"]
  },
  {
    "task_description": "Create a skill for JWT authentication including token creation, validation, and refresh token flows",
    "expected_taxonomy_path": "technical_skills/security/authentication/jwt",
    "expected_name": "jwt-auth",
    "expected_type": "technical",
    "expected_weight": "lightweight",
    "expected_capabilities": [
      "token_creation",
      "token_validation",
      "refresh_tokens",
      "claims_management",
      "security_practices",
      "token_storage"
    ],
    "expected_dependencies": [],
    "expected_category": "technical_skills/security/authentication",
    "expected_keywords": ["jwt", "authentication", "token", "auth", "security"],
    "expected_scope": "Covers JWT authentication. Does NOT cover OAuth2 or SAML.",
    "expected_see_also": ["technical_skills/security/authentication/oauth2"]
  },
  {
    "task_description": "Create a skill for GraphQL API design including schemas, resolvers, and subscriptions",
    "expected_taxonomy_path": "technical_skills/apis_integration/graphql",
    "expected_name": "graphql-design",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "schema_design",
      "resolver_implementation",
      "mutations",
      "subscriptions",
      "error_handling",
      "pagination"
    ],
    "expected_dependencies": [],
    "expected_category": "technical_skills/apis_integration",
    "expected_keywords": ["graphql", "api", "schema", "resolver", "apollo"],
    "expected_scope": "Covers GraphQL API design. Does NOT cover REST or gRPC.",
    "expected_see_also": ["technical_skills/apis_integration/rest"]
  },
  {
    "task_description": "Create a skill for Redis caching strategies including TTL, eviction policies, and pub/sub",
    "expected_taxonomy_path": "technical_skills/data_engineering/databases/redis",
    "expected_name": "redis-caching",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "data_structures",
      "ttl_management",
      "eviction_policies",
      "pub_sub",
      "transactions",
      "clustering"
    ],
    "expected_dependencies": [],
    "expected_category": "technical_skills/data_engineering/databases",
    "expected_keywords": ["redis", "cache", "caching", "pub-sub", "key-value"],
    "expected_scope": "Covers Redis caching. Does NOT cover Memcached or CDNs.",
    "expected_see_also": ["technical_skills/data_engineering/databases/sql"]
  },
  {
    "task_description": "Create a skill for technical documentation writing including ADRs, READMEs, and API documentation",
    "expected_taxonomy_path": "task_focus_areas/documentation/technical_writing",
    "expected_name": "technical-docs",
    "expected_type": "task_focus",
    "expected_weight": "lightweight",
    "expected_capabilities": [
      "readme_writing",
      "adr_creation",
      "api_documentation",
      "runbook_writing",
      "code_comments",
      "diagrams"
    ],
    "expected_dependencies": [],
    "expected_category": "task_focus_areas/documentation",
    "expected_keywords": [
      "documentation",
      "readme",
      "adr",
      "api-docs",
      "markdown"
    ],
    "expected_scope": "Covers technical documentation. Does NOT cover user-facing docs.",
    "expected_see_also": ["task_focus_areas/code_quality/code_review"]
  },
  {
    "task_description": "Create a skill for CSS Flexbox and Grid layout including responsive design patterns",
    "expected_taxonomy_path": "technical_skills/programming/web_development/css/layout",
    "expected_name": "css-layout",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "flexbox_layout",
      "grid_layout",
      "responsive_design",
      "media_queries",
      "container_queries",
      "layout_patterns"
    ],
    "expected_dependencies": [],
    "expected_category": "technical_skills/programming/web_development/css",
    "expected_keywords": ["css", "flexbox", "grid", "layout", "responsive"],
    "expected_scope": "Covers CSS layout. Does NOT cover CSS frameworks or preprocessors.",
    "expected_see_also": ["technical_skills/programming/web_development/html"]
  },
  {
    "task_description": "Create a skill for microservices architecture patterns including service discovery, circuit breakers, and saga patterns",
    "expected_taxonomy_path": "technical_skills/software_architecture/microservices",
    "expected_name": "microservices-patterns",
    "expected_type": "technical",
    "expected_weight": "heavy",
    "expected_capabilities": [
      "service_discovery",
      "circuit_breakers",
      "saga_patterns",
      "api_gateway",
      "event_sourcing",
      "service_mesh"
    ],
    "expected_dependencies": [],
    "expected_category": "technical_skills/software_architecture",
    "expected_keywords": [
      "microservices",
      "architecture",
      "distributed",
      "saga",
      "circuit-breaker"
    ],
    "expected_scope": "Covers microservices patterns. Does NOT cover monolith architecture.",
    "expected_see_also": ["technical_skills/software_architecture/event_driven"]
  },
  {
    "task_description": "Create a skill for MCP server implementation including tool definitions, resource handling, and transport protocols",
    "expected_taxonomy_path": "mcp_capabilities/server_development",
    "expected_name": "mcp-server-dev",
    "expected_type": "technical",
    "expected_weight": "medium",
    "expected_capabilities": [
      "tool_definitions",
      "resource_handling",
      "transport_protocols",
      "server_lifecycle",
      "error_handling",
      "capability_negotiation"
    ],
    "expected_dependencies": [],
    "expected_category": "mcp_capabilities",
    "expected_keywords": [
      "mcp",
      "model-context-protocol",
      "server",
      "tools",
      "resources"
    ],
    "expected_scope": "Covers MCP server implementation. Does NOT cover MCP clients.",
    "expected_see_also": ["mcp_capabilities/client_development"]
  },
  {
    "task_description": "Create a skill for problem decomposition and task planning for complex multi-step problems",
    "expected_taxonomy_path": "cognitive_skills/planning/task_decomposition",
    "expected_name": "task-planning",
    "expected_type": "cognitive",
    "expected_weight": "lightweight",
    "expected_capabilities": [
      "problem_analysis",
      "subtask_identification",
      "dependency_mapping",
      "prioritization",
      "milestone_definition",
      "risk_assessment"
    ],
    "expected_dependencies": [],
    "expected_category": "cognitive_skills/planning",
    "expected_keywords": [
      "planning",
      "decomposition",
      "task-breakdown",
      "problem-solving"
    ],
    "expected_scope": "Covers problem decomposition. Does NOT cover project management tools.",
    "expected_see_also": ["cognitive_skills/reasoning/prompt_engineering"]
  }
]


============================================================
END FILE: config/training/archive/trainset_v1.json
============================================================

============================================================
FILE: config/training/example_metadata.json
============================================================

{}

============================================================
END FILE: config/training/example_metadata.json
============================================================

============================================================
FILE: config/training/gold_skills_v2.json
============================================================

{
  "version": "2.0",
  "description": "Golden skill examples extracted from .skills/ directory",
  "skills": [
    {
      "skill_id": ".skills/dspy-advanced",
      "name": "dspy-advanced",
      "description": "Advanced DSPy modules including ReAct agents, tool calling, output refinement (BestOfN, Refine), and adapters. Use when building agent systems, integrating external tools, or implementing multi-step reasoning.",
      "allowed_tools": [],
      "skill_style": "navigation_hub",
      "subdirectory_files": {
        "references": [
          "adapters.md",
          "output-refinement.md",
          "react-tools.md"
        ]
      },
      "structure": {
        "has_when_to_use": true,
        "has_quick_start": true,
        "has_overview": false
      },
      "skill_path": ".skills/dspy-advanced/SKILL.md",
      "content_length": 3261,
      "source": "golden_example"
    },
    {
      "skill_id": ".skills/dspy-basics",
      "name": "dspy-basics",
      "description": "Core DSPy fundamentals for signature design, basic modules (Predict, ChainOfThought), and program composition patterns. Use when creating new signatures, building simple DSPy programs, or learning foundational DSPy concepts.",
      "allowed_tools": [],
      "skill_style": "navigation_hub",
      "subdirectory_files": {
        "references": [
          "programs.md",
          "signatures.md"
        ]
      },
      "structure": {
        "has_when_to_use": true,
        "has_quick_start": true,
        "has_overview": false
      },
      "skill_path": ".skills/dspy-basics/SKILL.md",
      "content_length": 3468,
      "source": "golden_example"
    },
    {
      "skill_id": ".skills/dspy-configuration",
      "name": "dspy-configuration",
      "description": "DSPy configuration, LM setup, caching, and version management. Use when configuring language models, enabling caching, managing dependencies, or setting up multi-provider configurations.",
      "allowed_tools": [],
      "skill_style": "navigation_hub",
      "subdirectory_files": {
        "references": [
          "caching.md",
          "lm-config.md",
          "versioning.md"
        ]
      },
      "structure": {
        "has_when_to_use": true,
        "has_quick_start": true,
        "has_overview": false
      },
      "skill_path": ".skills/dspy-configuration/SKILL.md",
      "content_length": 3327,
      "source": "golden_example"
    },
    {
      "skill_id": ".skills/dspy-development-backup",
      "name": "dspy-development",
      "description": "Provides comprehensive guidance for DSPy framework development including signature design, program construction, optimization workflows, and best practices. Use when working with DSPy modules, creating new signatures, optimizing teleprompters, or debugging DSPy code .",
      "allowed_tools": [],
      "skill_style": "navigation_hub",
      "subdirectory_files": {
        "references": [
          "optimization.md",
          "patterns.md",
          "programs.md",
          "signatures.md"
        ]
      },
      "structure": {
        "has_when_to_use": true,
        "has_quick_start": true,
        "has_overview": false
      },
      "skill_path": ".skills/dspy-development-backup/SKILL.md",
      "content_length": 3704,
      "source": "golden_example"
    },
    {
      "skill_id": ".skills/dspy-optimization",
      "name": "dspy-optimization",
      "description": "DSPy optimizers (teleprompters), evaluation metrics, and optimization workflows. Use when compiling programs with BootstrapFewShot, KNNFewShot, MIPROv2, GEPA, or defining custom metrics.",
      "allowed_tools": [],
      "skill_style": "navigation_hub",
      "subdirectory_files": {
        "references": [
          "metrics.md",
          "optimizers.md"
        ]
      },
      "structure": {
        "has_when_to_use": true,
        "has_quick_start": true,
        "has_overview": false
      },
      "skill_path": ".skills/dspy-optimization/SKILL.md",
      "content_length": 3700,
      "source": "golden_example"
    },
    {
      "skill_id": ".skills/fastapi-stack-development",
      "name": "FastAPI Stack Development",
      "description": "Comprehensive guidance for FastAPI, Typer, and SQLModel development including patterns, best practices, API design, CLI development, database integration, testing, and common workflows. Use this skill when building applications with any of these frameworks.",
      "allowed_tools": [],
      "skill_style": "comprehensive",
      "subdirectory_files": {},
      "structure": {
        "has_when_to_use": tr