<!-- Chunk 800: bytes 2689530-2705031, type=class -->
class StreamingConfig:
    """Streaming configuration."""

    # SSE settings
    SSE_RETRY_TIMEOUT = 3000  # milliseconds
    SSE_HEARTBEAT_INTERVAL = 30  # seconds

    # Session settings
    SESSION_TIMEOUT = 3600  # seconds (1 hour)
    MAX_MESSAGE_HISTORY = 100
    MAX_CONTEXT_SIZE = 10000  # characters

    # Intent detection
    INTENT_CONFIDENCE_THRESHOLD = 0.7
```

## See Also

- **[API: Migration Guide](../api/MIGRATION_V1_TO_V2.md)** - v1 vs v2 API comparison
- **[Service Layer](SERVICE_LAYER.md)** - Service architecture
- **[DSPy Overview](../dspy/index.md)** - DSPy integration


============================================================
END FILE: docs/architecture/CONVERSATIONAL_INTERFACE.md
============================================================

============================================================
FILE: docs/architecture/DATABASE_SYNC.md
============================================================

# Database Sync Guide

Bidirectional synchronization between local `skills/` directory and Neon database.

---

## Overview

The Skills-Fleet system supports bidirectional sync between:
- **Local Files**: `skills/` directory with `SKILL.md` files
- **Neon Database**: Persistent storage with full skill metadata and relations

## Commands

### Export to Database

Export skills from local directory to Neon database:

```bash
# Export all skills to database
uv run skill-fleet export-to-db

# Preview without writing changes
uv run skill-fleet export-to-db --dry-run

# Use custom skills directory
uv run skill-fleet export-to-db --skills-dir ./skills

# Force overwrite existing skills
uv run skill-fleet export-to-db --force
```

**What it does:**
- Scans `skills/` directory for `SKILL.md` files
- Parses YAML frontmatter (name, description, keywords, tags)
- Extracts capabilities and skill content
- Infers taxonomy path from directory structure
- Creates skills with full metadata and relations
- Updates existing skills if found

### Import from Database

Import skills from Neon database to local directory:

```bash
# Import all active skills
uv run skill-fleet import-from-db

# Import specific skill by path
uv run skill-fleet import-from-db --skill-path "development/languages/python"

# Import only draft skills
uv run skill-fleet import-from-db --status draft

# Import all skills (including drafts)
uv run skill-fleet import-from-db --status all
```

**What it does:**
- Reads skills from Neon database
- Filters by path or status
- Writes `SKILL.md` files with YAML frontmatter
- Preserves all metadata (keywords, tags, capabilities)
- Maintains directory structure

### Bidirectional Sync

Synchronize both local files and database:

```bash
# Full bidirectional sync
uv run skill-fleet sync-db

# Preview sync without writing
uv run skill-fleet sync-db --dry-run
```

**What it does:**
1. Exports local changes to database
2. Imports database changes to local files
3. Ensures consistency between both sources

---

## Environment Configuration

The sync commands require `DATABASE_URL` to be set:

```bash
# From .env file
DATABASE_URL="postgresql://neondb_owner:password@host/database?sslmode=require"

# Or export directly
export DATABASE_URL="postgresql://neondb_owner:password@host/database?sslmode=require"
```

**Neon Database Connection:**
```
postgresql://neondb_owner:npg_DroldK7R6Bci@ep-divine-voice-ahu0xhvb.c-3.us-east-1.aws.neon.tech/neondb?sslmode=require
```

---

## Workflow Examples

### Initial Setup

First time setting up the database:

```bash
# 1. Export existing local skills to database
uv run skill-fleet export-to-db

# 2. Verify skills were imported
uv run skill-fleet list

# Or query database directly:
# SELECT COUNT(*) FROM skills;
```

### Daily Development

Working with skills locally:

```bash
# 1. Edit skills locally
vim skills/python/async/SKILL.md

# 2. Export changes to database
uv run skill-fleet export-to-db

# 3. Verify in database
uv run skill-fleet list --filter python
```

### Database-First Workflow

Creating skills via API/database:

```bash
# 1. Create skill via API (e.g., background job)
curl -X POST http://localhost:8000/api/v2/skills \
  -H "Content-Type: application/json" \
  -d '{"task_description": "Create skill for Docker"}'

# 2. Import new skill to local files
uv run skill-fleet import-from-db --status draft

# 3. Review and edit locally
vim skills/development/languages/docker/SKILL.md

# 4. Re-export changes
uv run skill-fleet export-to-db
```

### Team Collaboration

Multiple developers working on same codebase:

```bash
# Developer A: Exports changes
uv run skill-fleet export-to-db

# Developer B: Imports latest from database
uv run skill-fleet import-from-db

# Both stay in sync via database
```

---

## Conflict Resolution

### Export Conflicts

When exporting to database:
- **New skills**: Created in database
- **Existing skills**: Updated with current content
- **Use `--force`**: Overwrites database with local version

### Import Conflicts

When importing from database:
- **New files**: Created on local filesystem
- **Existing files**: Overwritten with database version
- **Use `--dry-run`**: Preview what will be overwritten

### Sync Conflicts

During bidirectional sync:
- Export happens first (local → database)
- Import happens second (database → local)
- Last write wins for each skill
- Review with `--dry-run` first

---

## Troubleshooting

### "DATABASE_URL not set"

**Problem**: Environment variable not configured

**Solution**:
```bash
# Check .env file
cat .env | grep DATABASE_URL

# Or export manually
export DATABASE_URL="postgresql://..."
```

### "Skills directory not found"

**Problem**: Skills directory doesn't exist or is empty

**Solution**:
```bash
# Check if directory exists
ls -la .skills/

# Or specify correct path
uv run skill-fleet export-to-db --skills-dir skills/
```

### "Duplicate key value violates unique constraint"

**Problem**: Skill already exists in database

**Solution**:
```bash
# Use force flag to update existing
uv run skill-fleet export-to-db --force
```

### Import creates wrong directory structure

**Problem**: Database skill paths don't match local structure

**Solution**:
- Check skill paths in database
- Ensure taxonomy categories are seeded
- Use correct path format: `development/languages/python`

---

## Data Integrity

### What Gets Synced

**Export to Database (Local → DB):**
- ✅ Skill name and description
- ✅ YAML frontmatter metadata
- ✅ Skill content (markdown)
- ✅ Keywords and tags
- ✅ Capabilities
- ✅ Taxonomy categorization
- ✅ Skill files (if present)
- ✅ Dependencies and references

**Import from Database (DB → Local):**
- ✅ All above fields
- ✅ Skill version
- ✅ Status (draft/active)
- ✅ Type and weight enums
- ✅ Load priority

### What Doesn't Get Synced

- ❌ Usage analytics (kept in database)
- ❌ Job history (kept in database)
- ❌ Validation reports (kept in database)
- ❌ HITL interactions (kept in database)

---

## Advanced Usage

### Filtering Imports

```bash
# Import only specific category
# (Currently requires direct skill-path filter)
uv run skill-fleet import-from-db --skill-path "development/frameworks/*"
```

### Custom Taxonomy Mapping

```bash
# Edit scripts/import_skills.py to customize taxonomy inference
# The infer_taxonomy() method determines category from path
```

### Batch Operations

```bash
# Export in dry-run mode to preview
uv run skill-fleet export-to-db --dry-run > export.log

# Review log, then apply
uv run skill-fleet export-to-db
```

---

## Database Queries

### Check Sync Status

```sql
-- Skills in database
SELECT COUNT(*) FROM skills;

-- Skills by status
SELECT status, COUNT(*) 
FROM skills 
GROUP BY status;

-- Skills by taxonomy
SELECT 
    tc.path,
    tc.name,
    COUNT(s.skill_id) as skill_count
FROM taxonomy_categories tc
LEFT JOIN skill_categories sc ON tc.category_id = sc.category_id
LEFT JOIN skills s ON sc.skill_id = s.skill_id
WHERE tc.level > 0
GROUP BY tc.path, tc.name
ORDER BY skill_count DESC;
```

### Find Orphaned Skills

```sql
-- Skills not in any taxonomy category
SELECT s.skill_id, s.name, s.skill_path
FROM skills s
LEFT JOIN skill_categories sc ON s.skill_id = sc.skill_id
WHERE sc.category_id IS NULL;
```

---

## Next Steps

After setting up database sync:

1. **Automate sync**: Add to CI/CD pipeline
2. **Set up API**: Start FastAPI server for background jobs
3. **Monitor usage**: Use analytics to track skill access
4. **Validate skills**: Ensure compliance with agentskills.io spec
5. **Optimize queries**: Add indexes for frequently used filters

---

**Related Documentation:**
- [CLI Reference](cli-reference.md)
- [API Reference](api-reference.md)
- [agentskills.io Compliance](agentskills-compliance.md)
- [Background Jobs](BACKGROUND_JOBS.md)


============================================================
END FILE: docs/architecture/DATABASE_SYNC.md
============================================================

============================================================
FILE: docs/architecture/DOMAIN_LAYER.md
============================================================

# Domain Layer Architecture

**Last Updated**: 2026-01-25

## Overview

The Domain Layer implements Domain-Driven Design (DDD) patterns to separate core business logic from infrastructure and API concerns. It provides a rich domain model with entities, value objects, specifications, and domain services.

`★ Insight ─────────────────────────────────────`
The domain layer is the heart of the application, independent of frameworks and databases. By using DDD patterns like Specifications and Domain Events, we can express complex business rules explicitly and test them in isolation without external dependencies.
`─────────────────────────────────────────────────`

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                       API Layer                              │
│                   (FastAPI Routes)                           │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                    Service Layer                             │
│            (Application Services, Orchestration)             │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                   Domain Layer                               │
│  ┌─────────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │   Domain Models │  │ Specifications│  │Domain Services│  │
│  │  (Entities,     │  │  (Business    │  │ (Business     │  │
│  │   Value Objects)│  │   Rules)     │  │  Logic)      │  │
│  └─────────────────┘  └──────────────┘  └──────────────┘  │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│               Infrastructure Layer                           │
│         (Repositories, Database, External APIs)              │
└─────────────────────────────────────────────────────────────┘
```

## Domain Models

### Entities

#### Skill

The core entity representing a skill in the taxonomy.

```python
from skill_fleet.domain import Skill, SkillMetadata, TaxonomyPath

# Create a skill
skill = Skill(
    metadata=SkillMetadata(
        skill_id="python-async-await",
        name="python-async-await",
        description="Proficiency with Python's async/await syntax",
        version="1.0.0",
        type=SkillType.GUIDE,
        weight=SkillWeight.MEDIUM,
        taxonomy_path="python/async-await",
    ),
    content="# Python Async/Await\n\n...",
)

# Access properties
skill_id = skill.skill_id  # From metadata
path = skill.taxonomy_path  # Returns TaxonomyPath value object
is_ready = skill.is_always_loaded()  # Domain behavior
```

**Key Properties**:
- `metadata`: SkillMetadata (name, description, type, etc.)
- `content`: Markdown content
- `extra_files`: Additional files (assets, examples)
- `path`: File system location (infrastructure concern)

**Domain Behaviors**:
- `has_capability(capability)`: Check if skill has a capability
- `has_dependency(skill_id)`: Check if skill depends on another
- `is_always_loaded()`: Check if skill should be auto-loaded

#### Job

Entity representing a background skill creation job.

```python
from skill_fleet.domain import Job, JobStatus

# Create a job
job = Job(
    job_id="abc-123",
    task_description="Create a Redis caching skill",
    user_id="user_456",
    status=JobStatus.PENDING,
)

# Domain behaviors
if job.is_running():
    print("Job is in progress")

if job.is_terminal():
    if job.status == JobStatus.COMPLETED:
        print(f"Success: {job.result}")
    else:
        print(f"Failed: {job.error}")

# Update progress
job.update_progress("generation", "Creating skill content...")

# Mark as completed
job.mark_completed(result=skill_creation_result)
```

**Status Lifecycle**:
```
PENDING → RUNNING → PENDING_HITL → RUNNING → COMPLETED
                        ↓
                      FAILED
```

### Value Objects

#### TaxonomyPath

Immutable value object representing a path in the skill taxonomy.

```python
from skill_fleet.domain import TaxonomyPath

# Create a path (validates and sanitizes)
path = TaxonomyPath("python/async-await")

# Path operations
parent = path.parent()  # TaxonomyPath("python")
child = path.child("basics")  # TaxonomyPath("python/async-await/basics")
depth = path.depth()  # 2

# String representation
str(path)  # "python/async-await"
```

**Validation**:
- Path cannot be empty
- Sanitized to prevent directory traversal attacks
- Uses kebab-case formatting

#### SkillMetadata

Value object containing skill metadata.

```python
from skill_fleet.domain import SkillMetadata, SkillType, SkillWeight, LoadPriority

metadata = SkillMetadata(
    skill_id="python-decorators",
    name="python-decorators",
    description="Ability to design and implement Python decorators",
    version="1.0.0",
    type=SkillType.GUIDE,
    weight=SkillWeight.MEDIUM,
    load_priority=LoadPriority.ON_DEMAND,
    dependencies=["python-functions", "python-closures"],
    capabilities=["code-generation", "code-review"],
)
```

### Enums

```python
from skill_fleet.domain import SkillType, SkillWeight, LoadPriority, JobStatus

# Skill Type
SkillType.GUIDE             # Educational content
SkillType.TOOL_INTEGRATION  # External tool integration
SkillType.WORKFLOW          # Multi-step process
SkillType.REFERENCE         # Reference material
SkillType.MEMORY_BLOCK      # Knowledge base

# Skill Weight (contribution/importance)
SkillWeight.LIGHT    # Small, focused skill
SkillWeight.MEDIUM   # Standard skill
SkillWeight.HEAVY    # Large, comprehensive skill

# Load Priority
LoadPriority.ALWAYS_LOADED  # Load at startup
LoadPriority.ON_DEMAND      # Load when needed
LoadPriority.LAZY           # Lazy loading

# Job Status
JobStatus.PENDING       # Queued
JobStatus.RUNNING       # In progress
JobStatus.PENDING_HITL  # Awaiting human input
JobStatus.COMPLETED     # Finished successfully
JobStatus.FAILED        # Failed with error
```

## Specifications

The Specification pattern encapsulates business rules as composable predicates.

### Base Specification

```python
from skill_fleet.domain import Specification

