<!-- Chunk 797: bytes 2683330-2688635, type=class -->
class CustomIntentHandler(IntentHandler):
    """Handle custom intent type."""

    def can_handle(self, message: str) -> bool:
        return message.startswith("/custom")

    async def handle(self, message: str, context: dict):
        # Your custom logic
        return {
            "type": "response",
            "data": f"Custom handling: {message}"
        }

# Register custom handler
assistant.register_handler(CustomIntentHandler())
```

## Message History

### ConversationMessage

```python
from skill_fleet.core.services import ConversationMessage, MessageRole

# User message
user_msg = ConversationMessage(
    role=MessageRole.USER,
    content="Create a skill",
    metadata={"timestamp": "2026-01-25T10:00:00Z"}
)

# Assistant message
assistant_msg = ConversationMessage(
    role=MessageRole.ASSISTANT,
    content="I'll create that skill for you",
    metadata={"confidence": 0.95}
)

# System message
system_msg = ConversationMessage(
    role=MessageRole.SYSTEM,
    content="Skill creation started"
)
```

### Role Types

```python
from skill_fleet.core.services import MessageRole

MessageRole.USER      # User input
MessageRole.ASSISTANT # AI response
MessageRole.SYSTEM    # System notifications
```

## State Machine

### State Transitions

```
┌──────────┐  message   ┌──────────┐  complete   ┌───────────┐
│  IDLE    │───────────►│  ACTIVE  │─────────────►│ COMPLETED │
└──────────┘            └──────────┘              └───────────┘
     ▲                       │                       │
     │                       │ input                 │
     │         ┌─────────────┴─────────────┐        │
     │         ▼                           ▼        │
     │  ┌──────────────┐            ┌──────────┐   │
     └──│ AWAITING_INPUT│            │  ERROR   │◄──┘
        └──────────────┘            └──────────┘
```

### State Management

```python
from skill_fleet.core.services import ConversationSession, ConversationState

session = ConversationSession(session_id="test", user_id="user")

# Initial state
assert session.state == ConversationState.IDLE

# Start conversation
session.start_conversation()
assert session.state == ConversationState.ACTIVE

# Request input
session.await_input()
assert session.state == ConversationState.AWAITING_INPUT

# Process input
session.process_input("user response")
assert session.state == ConversationState.ACTIVE

# Complete
session.complete()
assert session.state == ConversationState.COMPLETED

# Error handling
session.set_error("Something went wrong")
assert session.state == ConversationState.ERROR
```

## Context Management

### Session Context

```python
# Context persists across turns
context = {
    "user_id": "user-123",
    "preferences": {
        "detail_level": "advanced",
        "include_examples": True,
    },
    "active_job": "job-abc-123",
    "related_skills": ["python-async", "python-decorators"],
}

session = ConversationSession(
    session_id="sess-1",
    user_id="user-123",
    context=context,
)

# Access context
user_id = session.context["user_id"]
job_id = session.context.get("active_job")

# Update context
session.context["turn_count"] = session.message_count
```

## Integration with Workflow

### Chat to Skill Creation

```python
from skill_fleet.core.dspy import SkillCreationProgram
from skill_fleet.core.services import ConversationSession

# 1. User starts chat
session = ConversationSession(session_id="chat-1", user_id="user")

# 2. Detect create intent
message = "Create a Redis caching skill"
intent = detect_intent(message)  # CreateSkillIntent

# 3. Route to skill creation workflow
if intent == "create_skill":
    program = SkillCreationProgram()
    result = await program.aforward(
        task_description="Redis caching skill",
        user_context={"user_id": "user"},
        taxonomy_structure="{}",
        existing_skills="[]",
        hitl_callback=hitl_callback,
        progress_callback=progress_callback,
    )

    # 4. Update session with result
    session.add_result(result)
    session.complete()
```

## Best Practices

### 1. Use Streaming for Real-Time Experience

```python
# ✅ Good: Streaming for real-time feedback
async for event in assistant.forward_streaming(message, context):
    if event['type'] == 'thinking':
        show_thinking(event['data'])
    elif event['type'] == 'response':
        append_response(event['data'])

# ❌ Avoid: Blocking for long-running tasks
result = await assistant.forward(message, context)  # No feedback until complete
```

### 2. Manage Session Lifecycle

```python
# ✅ Good: Explicit session management
session = await get_or_create_session(session_id)
try:
    result = await process_conversation(session, message)
finally:
    await save_session(session)

# ❌ Avoid: Losing session state
result = await process_message(message)  # No session context
```

### 3. Handle Errors Gracefully

```python
# ✅ Good: Error handling with recovery
try:
    async for event in assistant.forward_streaming(message, context):
        yield event
except Exception as e:
    yield {"type": "error", "data": str(e)}
    session.set_error(str(e))
```

## Testing

### Unit Testing Conversation

```python
import pytest
from skill_fleet.core.services import (
    ConversationSession,
    ConversationMessage,
    MessageRole,
)

