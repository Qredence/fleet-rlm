<!-- Chunk 860: bytes 3054129-3057788, type=class -->
class AnalyticsService(BaseService):
    """Service for analytics and metrics."""

    async def get_skill_usage_stats(
        self,
        skill_id: str,
        time_range: str = "7d"
    ) -> dict:
        """
        Get usage statistics for a skill.

        Args:
            skill_id: Skill identifier
            time_range: Time range for stats (1d, 7d, 30d)

        Returns:
            Dictionary with usage statistics
        """
        # Validate input
        skill = await self.skill_repository.get(skill_id)
        if not skill:
            raise ValidationError(f"Skill not found: {skill_id}")

        # Business logic
        stats = await self._calculate_stats(skill_id, time_range)

        # Return result
        return {
            "skill_id": skill_id,
            "time_range": time_range,
            "usage_count": stats["count"],
            "last_used": stats["last_used"],
        }
```

### Step 3: Export from Services Package

```python
# src/skill_fleet/services/__init__.py
from .analytics import AnalyticsService

__all__ = [
    "BaseService",
    "AnalyticsService",
    # ... other exports
]
```

---

## Adding Service Methods

### Method Patterns

#### 1. Simple Query Method

```python
async def get_skill_count(self) -> int:
    """Get total number of skills."""
    return await self.skill_repository.count()
```

#### 2. Validation + Business Logic Method

```python
async def promote_skill(self, skill_id: str) -> Skill:
    """Promote a skill to published status."""
    # Get skill
    skill = await self.skill_repository.get(skill_id)
    if not skill:
        raise NotFoundException("Skill", skill_id)

    # Use specification for validation
    from skill_fleet.domain import SkillIsReadyForPublication
    if not SkillIsReadyForPublication().is_satisfied_by(skill):
        raise ValidationError("Skill is not ready for publication")

    # Business logic
    skill.mark_as_published()
    await self.skill_repository.save(skill)

    return skill
```

#### 3. Orchestrating Multiple Domain Objects

```python
async def create_skill_with_dependencies(
    self,
    main_skill_data: dict,
    dependencies: list[str]
) -> Skill:
    """Create a skill with dependency resolution."""
    # Validate dependencies exist
    for dep_id in dependencies:
        dep = await self.skill_repository.get(dep_id)
        if not dep:
            raise ValidationError(f"Dependency not found: {dep_id}")

    # Create main skill
    skill = Skill(
        metadata=SkillMetadata(**main_skill_data),
        dependencies=dependencies,
    )

    # Save
    await self.skill_repository.save(skill)

    return skill
```

#### 4. Async Job Orchestration

```python
async def execute_skill_creation_workflow(
    self,
    task_description: str,
    user_id: str
) -> Job:
    """Execute the full skill creation workflow."""
    # Create job
    job = Job(
        task_description=task_description,
        user_id=user_id,
        status=JobStatus.PENDING,
    )
    await self.job_repository.save(job)

    # Execute workflow (async)
    try:
        job.status = JobStatus.RUNNING
        await self.job_repository.save(job)

        # Phase 1: Understanding
        result = await self._phase1_understand(job)

        # Phase 2: Generation
        result = await self._phase2_generate(job, result)

        # Phase 3: Validation
        result = await self._phase3_validate(job, result)

        job.mark_completed(result)
    except Exception as e:
        job.mark_failed(str(e))

    await self.job_repository.save(job)
    return job
```

---

## Dependency Injection

### Constructor Injection

```python
