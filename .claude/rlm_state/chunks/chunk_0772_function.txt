<!-- Chunk 772: bytes 2633739-2638546, type=function -->
def get_job_stats() -> dict[str, Any]:
    """Get statistics about all jobs."""
    total = len(JOBS)
    by_status = {}

    for job in JOBS.values():
        status = job.status
        by_status[status] = by_status.get(status, 0) + 1

    return {
        "total": total,
        "by_status": by_status,
        "pending_hitl": by_status.get("pending_hitl", 0),
    }
```

### Metrics Endpoint

```python
@app.get("/jobs/stats")
async def job_stats():
    """Get job statistics."""
    stats = get_job_stats()

    # Calculate completion rate
    completed = stats["by_status"].get("completed", 0)
    failed = stats["by_status"].get("failed", 0)
    total_finished = completed + failed

    completion_rate = completed / total_finished if total_finished > 0 else 0

    return {
        **stats,
        "completion_rate": f"{completion_rate:.1%}",
    }
```

---

## Best Practices

1. **Always Poll**: Don't assume jobs complete quickly
2. **Handle Timeouts**: Set appropriate timeouts for HITL
3. **Cleanup**: Remove old jobs to prevent memory leaks
4. **Logging**: Log job state transitions for debugging
5. **Error Handling**: Always handle exceptions in background tasks
6. **Persistence**: Use Redis/database for production deployments

---

## See Also

- **[API Overview](index.md)** - Architecture and setup
- **[Endpoints Documentation](endpoints.md)** - HITL endpoints
- **[HITL System](../hitl/)** - Human-in-the-Loop details


============================================================
END FILE: docs/api/jobs.md
============================================================

============================================================
FILE: docs/api/middleware.md
============================================================

# API Middleware & Error Handling

**Last Updated**: 2026-01-12

## Overview

This document covers the middleware components and error handling strategies used in the Skills Fleet API.

`★ Insight ─────────────────────────────────────`
Middleware provides cross-cutting concerns like CORS, authentication, logging, and error handling. Centralizing these concerns ensures consistent behavior across all endpoints.
`─────────────────────────────────────────────────`

## CORS Middleware

Cross-Origin Resource Sharing (CORS) allows web browsers to make requests to the API from different origins.

### Configuration

**Location**: `src/skill_fleet/api/app.py`

```python
from fastapi.middleware.cors import CORSMiddleware

cors_origins_raw = os.environ.get("SKILL_FLEET_CORS_ORIGINS", "*")
cors_origins = [origin.strip() for origin in cors_origins_raw.split(",") if origin.strip()]

app.add_middleware(
    CORSMiddleware,
    allow_origins=cors_origins,
    allow_credentials=cors_origins != ["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)
```

### Environment Variable

```bash
# Allow specific origins
export SKILL_FLEET_CORS_ORIGINS="https://example.com,https://app.example.com"

# Allow all origins (not recommended for production)
export SKILL_FLEET_CORS_ORIGINS="*"
```

### Security Considerations

| Setting | Development | Production |
|---------|-------------|------------|
| `allow_origins` | `["*"]` | Specific origins |
| `allow_credentials` | `True` | `True` if needed |
| `allow_methods` | `["*"]` | Specific methods |
| `allow_headers` | `["*"]` | Specific headers |

**Production Recommendation:**
```bash
export SKILL_FLEET_CORS_ORIGINS="https://your-frontend.com"
```

---

## Error Handling

### Global Exception Handler

FastAPI provides automatic exception handling. You can customize with:

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

app = FastAPI()

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """Global exception handler for unhandled errors."""
    logger.error(f"Unhandled exception: {exc}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={
            "detail": "Internal server error",
            "error_type": type(exc).__name__,
        }
    )
```

### HTTPException

For expected errors, use `HTTPException`:

```python
from fastapi import HTTPException

@app.get("/skills/{skill_id}")
async def get_skill(skill_id: str):
    skill = load_skill(skill_id)
    if skill is None:
        raise HTTPException(
            status_code=404,
            detail=f"Skill not found: {skill_id}"
        )
    return skill
```

### Validation Errors

Pydantic validation errors are handled automatically:

```json
{
    "detail": [
        {
            "loc": ["body", "task_description"],
            "msg": "field required",
            "type": "value_error.missing"
        }
    ]
}
```

### Custom Exception Handlers

Create handlers for specific exception types:

```python
