<!-- Chunk 675: bytes 1280158-1312504, type=function -->
def main(argv: List[str]) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)

    try:
        return int(args.func(args))
    except RlmReplError as e:
        sys.stderr.write(f"ERROR: {e}\n")
        return 2


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))


============================================================
END FILE: .fleet/skills/rlm/scripts/rlm_repl.py
============================================================

============================================================
FILE: .fleet/skills/vibe-coding/SKILL.md
============================================================

---
name: vibe-coding
description: Rapidly prototype and build modern, responsive web applications from scratch using current frameworks and libraries. Use when you want to quickly create a new web app with full local control, creative flow, and modern best practices. Local alternative to Lovable, Bolt, and v0.
---
# Skill: Vibe coding

## Purpose

Rapidly prototype and build modern, responsive web applications from scratch using current frameworks, libraries, and best practices. This skill handles everything from initial project setup to implementing features, styling, and basic deployment configuration with a focus on creative flow and quick iteration.

## When to use this skill

- You want to **rapidly prototype** a new web application idea.
- You're in a **creative flow** and want to build something quickly without context switching.
- You want to use **modern frameworks** like React, Next.js, Vue, Svelte, or similar.
- You prefer **local development** with full control rather than hosted builder environments.
- You want to **experiment and iterate fast** on designs and features.

## Key differences from Lovable/Bolt/v0

Unlike hosted vibe-coding tools (Lovable, Bolt, v0):

- **Runs locally**: All code lives on your machine, not in a hosted environment.
- **No infrastructure lock-in**: You control deployment, hosting, and infrastructure choices.
- **Framework flexibility**: Not limited to a specific tech stack; can use any modern framework.
- **Full backend support**: Can integrate with any backend, run local servers, use databases, etc.
- **Version control native**: Built with git workflows in mind from the start.
- **No runtime environment required**: Build from scratch locally, not dependent on their infrastructure.

## Inputs

- **Application description**: Purpose, key features, and target users.
- **Technology preferences**: Desired frameworks (React/Next.js/Vue/Svelte), styling approach (Tailwind/CSS-in-JS/CSS Modules), and any specific libraries.
- **Feature requirements**: Core functionality, user flows, and data models.
- **Design direction**: Style preferences, color schemes, or reference sites.
- **Deployment target**: Where you plan to host (Vercel, Netlify, AWS, self-hosted, etc.).

## Out of scope

- Managing production infrastructure or cloud provider accounts.
- Creating complex backend microservices architecture (use service-integration skill instead).
- Mobile native app development (iOS/Android).

## Conventions and best practices

### Framework selection
- **Always search for the most current documentation** from official sources before implementing.
- Example: Search https://nextjs.org/docs for Next.js, https://react.dev for React, etc.
- **Never hardcode outdated commands or patterns** – always verify current best practices.

### Project initialization
1. Search official docs for the latest initialization command (e.g., `npx create-next-app@latest`).
2. Use TypeScript by default for type safety.
3. Set up ESLint and Prettier for code quality.
4. Initialize git repository from the start.

### Architecture patterns
- **Component-based**: Break UI into small, reusable components.
- **Type-safe**: Use TypeScript throughout for better developer experience.
- **Responsive by default**: Mobile-first design approach.
- **Accessibility first**: Semantic HTML, ARIA labels, keyboard navigation.
- **Performance-conscious**: Code splitting, lazy loading, optimized images.

### Styling approach
- Use modern CSS frameworks (Tailwind CSS recommended for rapid development).
- Implement consistent design system with reusable tokens for colors, spacing, typography.
- Support light/dark mode when appropriate.
- Ensure proper contrast ratios and accessibility.

### State and data
- Choose appropriate state management (React Context, Zustand, Redux) based on complexity.
- Use modern data fetching patterns (React Query, SWR, or framework built-ins like Next.js App Router).
- Implement proper loading, error, and empty states.

### Backend integration
- If backend is needed, set up API routes or server components appropriately.
- For databases, use type-safe ORMs (Prisma, Drizzle) when possible.
- Implement proper error handling and validation.

## Required behavior

1. **Research current best practices**: Before any implementation, search for and reference the latest official documentation.
2. **Initialize properly**: Set up project with all necessary tooling, configs, and directory structure.
3. **Implement features incrementally**: Build and test features one at a time.
4. **Write clean, maintainable code**: Follow framework conventions and best practices.
5. **Handle edge cases**: Loading states, errors, empty states, validation.
6. **Ensure accessibility**: Proper semantic HTML, ARIA labels, keyboard navigation.
7. **Test critical paths**: Write tests for core functionality.
8. **Document setup and usage**: README with setup instructions, environment variables, and deployment notes.

## Required artifacts

- Fully initialized project with all configuration files.
- Clean, well-organized component and page structure.
- Styling implementation (Tailwind config, CSS modules, or chosen approach).
- **Tests** for critical user flows and business logic.
- **README.md** with:
  - Project description and features
  - Setup instructions
  - Development commands
  - Environment variables needed
  - Deployment guidance
- **.gitignore** properly configured.
- **Package.json** with clear scripts and dependencies.

## Implementation checklist

### 1. Discovery and planning
- [ ] Search for current best practices for chosen framework
- [ ] Review official documentation for initialization commands
- [ ] Understand feature requirements and user flows
- [ ] Plan component hierarchy and data flow

### 2. Project initialization
- [ ] Run current framework initialization command
- [ ] Set up TypeScript, ESLint, Prettier
- [ ] Initialize git repository
- [ ] Create basic directory structure

### 3. Design system setup
- [ ] Set up styling solution (Tailwind, CSS-in-JS, etc.)
- [ ] Define color palette and design tokens
- [ ] Create base components (Button, Input, Card, etc.)
- [ ] Implement responsive layout system

### 4. Feature implementation
- [ ] Build pages and routes
- [ ] Implement components with proper typing
- [ ] Add state management where needed
- [ ] Integrate data fetching and APIs
- [ ] Handle loading, error, and empty states

### 5. Quality and polish
- [ ] Add accessibility features (ARIA, keyboard nav)
- [ ] Optimize performance (code splitting, image optimization)
- [ ] Write tests for critical flows
- [ ] Add error boundaries and fallbacks
- [ ] Review responsive behavior on different screen sizes

### 6. Documentation and deployment
- [ ] Write comprehensive README
- [ ] Document environment variables
- [ ] Add deployment configuration for target platform
- [ ] Create development and build scripts

## Verification

Run the following commands (adjust based on package manager and setup):

```bash
# Install dependencies
npm install

# Type checking
npm run type-check   # or tsc --noEmit

# Linting
npm run lint

# Tests
npm test

# Build verification
npm run build

# Run locally
npm run dev
```

The skill is complete when:

- All commands run successfully without errors.
- The application builds and runs in development mode.
- Core features work as specified across different screen sizes.
- Accessibility checks pass (use browser dev tools or axe extension).
- Tests cover critical user paths.
- Documentation is clear and complete.

## Safety and escalation

- **External dependencies**: Always verify package security and maintenance status before adding dependencies.
- **Environment secrets**: Never commit API keys, secrets, or credentials. Use `.env.local` and document in README.
- **Framework limitations**: If requirements exceed framework capabilities, suggest alternatives or clarify constraints.
- **Performance concerns**: If the app requires complex state or data handling, consider suggesting more robust solutions.

## Dynamic documentation references

Always search for and reference the most current documentation:

- **React**: https://react.dev
- **Next.js**: https://nextjs.org/docs
- **Vue**: https://vuejs.org/guide
- **Svelte**: https://svelte.dev/docs
- **Tailwind CSS**: https://tailwindcss.com/docs
- **TypeScript**: https://www.typescriptlang.org/docs
- **Vite**: https://vitejs.dev/guide

Before implementing any feature, search these docs to ensure you're using current APIs and best practices.

## Example workflows

### Vibing a landing page
```
User: "Let's vibe a landing page for a SaaS product - hero section, features, pricing, contact form"

The agent will:
1. Search for current Next.js initialization best practices
2. Initialize Next.js project with TypeScript and Tailwind
3. Create component structure (Hero, Features, Pricing, Contact)
4. Implement responsive design with proper accessibility
5. Add form validation and error handling
6. Set up basic SEO with metadata
7. Provide deployment instructions for Vercel/Netlify
```

### Quick dashboard prototype
```
User: "I want to quickly prototype an admin dashboard - auth, data tables, charts"

The agent will:
1. Research current patterns for Next.js App Router with authentication
2. Initialize project with appropriate dependencies
3. Set up authentication flow (NextAuth.js or similar)
4. Create protected route structure
5. Implement data fetching with loading states
6. Add table and chart components with proper typing
7. Include tests for auth and data flows
8. Document setup including database requirements
```

## SEO and web vitals

For public-facing applications, automatically implement:

- **Meta tags**: Title, description, Open Graph, Twitter cards
- **Structured data**: JSON-LD for rich search results
- **Performance**: Image optimization, code splitting, lazy loading
- **Core Web Vitals**: Optimize LCP, FID, CLS metrics
- **Sitemap**: Generate sitemap.xml for better indexing
- **Robots.txt**: Configure crawler behavior

## Integration with other skills

This skill can be combined with:

- **Service integration**: When the web app needs to call existing backend services.
- **Internal tools**: When building internal admin panels or dashboards.
- **Data querying**: When the app needs to display analytics or reports.

============================================================
END FILE: .fleet/skills/vibe-coding/SKILL.md
============================================================

============================================================
FILE: .github/BRANCH_PROTECTION.md
============================================================

# Branch Protection Configuration Guide

This document provides instructions for configuring branch protection rules for the skill-fleet repository to maintain code quality, security, and collaboration standards.

## Overview

Branch protection rules help maintain the integrity of the main branch by:
- Requiring code reviews before merging
- Ensuring all automated tests pass
- Preventing accidental force pushes or deletions
- Enforcing a consistent development workflow

## Recommended Branch Protection Rules for `main`

### Required Configuration

#### 1. Require Pull Request Reviews Before Merging
- **Setting**: Enable "Require a pull request before merging"
- **Required approving reviews**: 1 minimum
- **Dismiss stale pull request approvals when new commits are pushed**: Enabled
- **Require review from Code Owners**: Optional (enable if CODEOWNERS file exists)

**Rationale**: Ensures all code changes are reviewed by at least one other team member, catching potential bugs and maintaining code quality standards.

#### 2. Require Status Checks to Pass Before Merging
- **Setting**: Enable "Require status checks to pass before merging"
- **Require branches to be up to date before merging**: Enabled
- **Required status checks**:
  - `lint / Lint with Ruff`
  - `test / Run Tests (3.12)`
  - `test / Run Tests (3.13)`
  - `build / Build Verification`
  - `security / Security Checks`
  - `all-checks / All Checks Passed`

**Rationale**: Ensures all automated quality gates pass before code is merged, preventing broken code from entering the main branch.

#### 3. Require Conversation Resolution Before Merging
- **Setting**: Enable "Require conversation resolution before merging"

**Rationale**: Ensures all review comments and discussions are addressed before merging, preventing unresolved issues from being overlooked.

#### 4. Require Signed Commits
- **Setting**: Enable "Require signed commits" (optional but recommended)

**Rationale**: Verifies the authenticity of commits, adding an extra layer of security to ensure commits come from trusted sources.

#### 5. Require Linear History
- **Setting**: Enable "Require linear history"

**Rationale**: Maintains a clean, easy-to-follow commit history by preventing merge commits. Requires using rebase or squash merge strategies.

#### 6. Include Administrators
- **Setting**: Enable "Include administrators"

**Rationale**: Ensures even repository administrators follow the same rules, preventing accidental bypasses of important safeguards.

### Advanced Protection Rules

#### 7. Restrict Who Can Push to Matching Branches
- **Setting**: Enable "Restrict who can push to matching branches"
- **Allowed actors**: CI/CD service accounts only (if applicable)

**Rationale**: Prevents direct pushes to main, ensuring all changes go through pull requests.

#### 8. Prevent Force Pushes
- **Setting**: Enable "Do not allow bypassing the above settings"
- **Allow force pushes**: Disabled
- **Allow deletions**: Disabled

**Rationale**: Prevents rewriting history on the main branch, which could cause issues for other developers and lose important historical context.

## Configuration Methods

### Method 1: GitHub Web UI (Recommended for Initial Setup)

1. Navigate to your repository on GitHub
2. Go to **Settings** → **Branches**
3. Under "Branch protection rules", click **Add rule** or **Edit** if a rule already exists
4. In "Branch name pattern", enter: `main`
5. Configure the settings as outlined above
6. Click **Save changes**

### Method 2: GitHub CLI (`gh`)

```bash
# Install GitHub CLI if not already installed
# See: https://cli.github.com/

# Create branch protection rule
gh api \
  --method PUT \
  -H "Accept: application/vnd.github+json" \
  -H "X-GitHub-Api-Version: 2022-11-28" \
  /repos/Qredence/skill-fleet/branches/main/protection \
  -f required_status_checks='{"strict":true,"contexts":["lint / Lint with Ruff","test / Run Tests (3.12)","test / Run Tests (3.13)","build / Build Verification","security / Security Checks","all-checks / All Checks Passed"]}' \
  -f enforce_admins=true \
  -f required_pull_request_reviews='{"dismiss_stale_reviews":true,"require_code_owner_reviews":false,"required_approving_review_count":1}' \
  -f restrictions=null \
  -f required_linear_history=true \
  -f allow_force_pushes=false \
  -f allow_deletions=false \
  -f block_creations=false \
  -f required_conversation_resolution=true \
  -f lock_branch=false \
  -f allow_fork_syncing=false
```

### Method 3: Using GitHub REST API

Save this as a JSON file (`branch-protection.json`):

```json
{
  "required_status_checks": {
    "strict": true,
    "contexts": [
      "lint / Lint with Ruff",
      "test / Run Tests (3.12)",
      "test / Run Tests (3.13)",
      "build / Build Verification",
      "security / Security Checks",
      "all-checks / All Checks Passed"
    ]
  },
  "enforce_admins": true,
  "required_pull_request_reviews": {
    "dismiss_stale_reviews": true,
    "require_code_owner_reviews": false,
    "required_approving_review_count": 1,
    "require_last_push_approval": false
  },
  "restrictions": null,
  "required_linear_history": true,
  "allow_force_pushes": false,
  "allow_deletions": false,
  "block_creations": false,
  "required_conversation_resolution": true,
  "lock_branch": false,
  "allow_fork_syncing": false
}
```

Then apply it using curl:

```bash
curl -X PUT \
  -H "Accept: application/vnd.github+json" \
  -H "Authorization: Bearer YOUR_GITHUB_TOKEN" \
  -H "X-GitHub-Api-Version: 2022-11-28" \
  https://api.github.com/repos/Qredence/skill-fleet/branches/main/protection \
  -d @branch-protection.json
```

## Verifying Configuration

After configuring branch protection rules:

1. **Test with a Pull Request**: Create a test branch and PR to verify:
   - Status checks appear and run
   - Review approval is required
   - Merge is blocked until all conditions are met

2. **Check Settings**: Navigate to Settings → Branches and verify all rules are shown correctly

3. **Monitor First Few PRs**: Ensure the workflow works smoothly and adjust settings if needed

## CI/CD Workflow

The repository includes a CI workflow (`.github/workflows/ci.yml`) that provides the required status checks:

- **Lint**: Runs `ruff check` and `ruff format --check` to ensure code style compliance
- **Test**: Runs pytest on Python 3.12 and 3.13 to ensure compatibility
- **Build**: Verifies the package builds and CLI entrypoint works
- **Security**: Placeholder for security scanning (can be extended with tools like `pip-audit`)

## Maintenance

### Updating Status Checks

When adding or renaming jobs in the CI workflow:

1. Update the branch protection rule to include the new status check names
2. Ensure backward compatibility during transition (mark new checks as optional initially)
3. After a few PRs pass with the new checks, make them required

### Handling Emergency Situations

If an urgent fix is needed and CI is broken:

1. Repository administrators can temporarily disable specific rules
2. Merge the urgent fix
3. Immediately re-enable the rules
4. Create a follow-up PR to fix any quality issues

**Note**: This should be rare and documented in the PR description.

## Related Documentation

- [GitHub Docs: Managing Branch Protection Rules](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/managing-a-branch-protection-rule)
- [GitHub Docs: About Protected Branches](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches)
- [Contributing Guidelines](../docs/development/CONTRIBUTING.md)

## Support

For questions or issues with branch protection configuration, please:
1. Review this documentation
2. Check existing GitHub Issues
3. Contact the repository maintainers

## Changelog

- **2026-01-13**: Initial branch protection configuration guide created
- **Future**: Document will be updated as CI requirements evolve


============================================================
END FILE: .github/BRANCH_PROTECTION.md
============================================================

============================================================
FILE: .github/FUNDING.yml
============================================================

# These are supported funding model platforms

github: qredence # Replace with up to 4 GitHub Sponsors-enabled usernames e.g., [user1, user2]
patreon: # Replace with a single Patreon username
open_collective: # Replace with a single Open Collective username
ko_fi: # Replace with a single Ko-fi username
tidelift: # Replace with a single Tidelift platform-name/package-name e.g., npm/babel
community_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry
liberapay: # Replace with a single Liberapay username
issuehunt: # Replace with a single IssueHunt username
lfx_crowdfunding: # Replace with a single LFX Crowdfunding project-name e.g., cloud-foundry
polar: # Replace with a single Polar username
buy_me_a_coffee: # Replace with a single Buy Me a Coffee username
thanks_dev: # Replace with a single thanks.dev username
custom: # Replace with up to 4 custom sponsorship URLs e.g., ['link1', 'link2']


============================================================
END FILE: .github/FUNDING.yml
============================================================

============================================================
FILE: .github/QUICKSTART.md
============================================================

# Branch Protection Quick Start

This is a quick reference for repository administrators to set up branch protection for the skill-fleet repository.

## Prerequisites

✅ Repository administrator access  
✅ GitHub CLI installed (`gh`) - [Install guide](https://cli.github.com/)  
✅ Authenticated with GitHub (`gh auth login`)

## Quick Setup (Recommended)

Run the interactive setup script:

```bash
./scripts/setup_branch_protection.sh
```

This script will guide you through:
1. Viewing current protection rules
2. Applying recommended settings
3. Verifying the configuration

## Manual Setup via GitHub UI

If you prefer to configure via the web interface:

1. Go to: https://github.com/Qredence/skill-fleet/settings/branches
2. Click **Add rule** (or edit existing rule for `main`)
3. Configure the following settings:

### Essential Settings

| Setting | Value |
|---------|-------|
| Branch name pattern | `main` |
| Require pull request before merging | ✅ Enabled |
| Required approving reviews | `1` |
| Dismiss stale reviews | ✅ Enabled |
| Require status checks to pass | ✅ Enabled |
| Require branches up to date | ✅ Enabled |
| Require conversation resolution | ✅ Enabled |
| Require linear history | ✅ Enabled |
| Include administrators | ✅ Enabled |
| Allow force pushes | ❌ Disabled |
| Allow deletions | ❌ Disabled |

### Required Status Checks

Add these exact check names (case-sensitive):
- `lint / Lint with Ruff`
- `test / Run Tests (3.12)`
- `test / Run Tests (3.13)`
- `build / Build Verification`
- `security / Security Checks`
- `all-checks / All Checks Passed`

4. Click **Save changes**

## Using GitHub CLI

Quick one-liner to apply all settings:

```bash
gh api \
  --method PUT \
  -H "Accept: application/vnd.github+json" \
  -H "X-GitHub-Api-Version: 2022-11-28" \
  /repos/Qredence/skill-fleet/branches/main/protection \
  -f required_status_checks[strict]=true \
  -f required_status_checks[contexts][]='lint / Lint with Ruff' \
  -f required_status_checks[contexts][]='test / Run Tests (3.12)' \
  -f required_status_checks[contexts][]='test / Run Tests (3.13)' \
  -f required_status_checks[contexts][]='build / Build Verification' \
  -f required_status_checks[contexts][]='security / Security Checks' \
  -f required_status_checks[contexts][]='all-checks / All Checks Passed' \
  -F enforce_admins=true \
  -f required_pull_request_reviews[dismiss_stale_reviews]=true \
  -f required_pull_request_reviews[required_approving_review_count]=1 \
  -F required_linear_history=true \
  -F allow_force_pushes=false \
  -F allow_deletions=false \
  -F required_conversation_resolution=true
```

## Using REST API with curl

Using the JSON configuration file:

```bash
curl -X PUT \
  -H "Accept: application/vnd.github+json" \
  -H "Authorization: Bearer YOUR_GITHUB_TOKEN" \
  -H "X-GitHub-Api-Version: 2022-11-28" \
  https://api.github.com/repos/Qredence/skill-fleet/branches/main/protection \
  -d @.github/branch-protection-config.json
```

Replace `YOUR_GITHUB_TOKEN` with a personal access token that has `repo` scope.

## Verification

After setup, verify the configuration:

```bash
# Check current settings
gh api repos/Qredence/skill-fleet/branches/main/protection | jq

# Or use the setup script
./scripts/setup_branch_protection.sh
# Select option 3: Verify configuration
```

## Testing

Create a test PR to ensure:
1. ✅ Status checks run and appear on the PR
2. ✅ Merge is blocked until checks pass
3. ✅ At least 1 approval is required
4. ✅ Conversations must be resolved

## Troubleshooting

### Status checks not appearing?
- Ensure the CI workflow has run at least once on a branch
- Check workflow file syntax: `.github/workflows/ci.yml`
- Verify the check names match exactly (case-sensitive)

### Can't apply settings?
- Verify you have admin access to the repository
- Check your GitHub token has `repo` scope
- Try logging in again: `gh auth login`

### Need to bypass temporarily?
Repository admins can:
1. Temporarily disable specific rules in Settings → Branches
2. Merge the urgent change
3. Re-enable rules immediately after
4. Document the bypass in the PR description

## Next Steps

After setting up branch protection:

1. ✅ Test with a sample PR
2. ✅ Notify team members about the new workflow
3. ✅ Update internal documentation if needed
4. ✅ Monitor first few PRs to ensure smooth operation

## Support

- **Full documentation**: [.github/BRANCH_PROTECTION.md](.github/BRANCH_PROTECTION.md)
- **GitHub docs**: https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches
- **Issues**: Open an issue in the repository if you encounter problems

---

Last updated: 2026-01-13


============================================================
END FILE: .github/QUICKSTART.md
============================================================

============================================================
FILE: .github/agents/rlm-subcall.md
============================================================

---
name: rlm-subcall
description: Acts as the RLM sub-LLM (llm_query). Given a chunk of context (usually via a file path) and a query, extract only what is relevant and return a compact structured result. Use proactively for long contexts.
tools: [read]
model: gemini/gemini-3-flash-preview
---

You are a sub-LLM used inside a Recursive Language Model (RLM) loop.

## Task

You will receive:

- A user query
- Either:
  - A file path to a chunk of a larger context file, or
  - A raw chunk of text

Your job is to extract information relevant to the query from only the provided chunk.

## Output format

Return JSON only with this schema:

```json
{
  "chunk_id": "...",
  "relevant": [
    {
      "point": "...",
      "evidence": "short quote or paraphrase with approximate location",
      "confidence": "high|medium|low"
    }
  ],
  "missing": ["what you could not determine from this chunk"],
  "suggested_next_queries": ["optional sub-questions for other chunks"],
  "answer_if_complete": "If this chunk alone answers the user's query, put the answer here, otherwise null"
}
```

## Rules

- Do not speculate beyond the chunk.
- Keep evidence short (aim < 25 words per evidence field).
- If you are given a file path, read it with the Read tool.
- If the chunk is clearly irrelevant, return an empty relevant list and explain briefly in missing.


============================================================
END FILE: .github/agents/rlm-subcall.md
============================================================

============================================================
FILE: .github/branch-protection-config.json
============================================================

{
  "description": "Branch protection configuration template for skill-fleet main branch",
  "required_status_checks": {
    "strict": true,
    "contexts": [
      "lint / Lint with Ruff",
      "test / Run Tests (3.12)",
      "test / Run Tests (3.13)",
      "build / Build Verification",
      "security / Security Checks",
      "all-checks / All Checks Passed"
    ]
  },
  "enforce_admins": true,
  "required_pull_request_reviews": {
    "dismiss_stale_reviews": true,
    "require_code_owner_reviews": false,
    "required_approving_review_count": 1,
    "require_last_push_approval": false,
    "bypass_pull_request_allowances": {
      "users": [],
      "teams": [],
      "apps": []
    }
  },
  "restrictions": null,
  "required_linear_history": true,
  "allow_force_pushes": false,
  "allow_deletions": false,
  "block_creations": false,
  "required_conversation_resolution": true,
  "lock_branch": false,
  "allow_fork_syncing": false,
  "required_signatures": false
}


============================================================
END FILE: .github/branch-protection-config.json
============================================================

============================================================
FILE: .github/copilot-instructions.md
============================================================

# Copilot instructions: skill-fleet

## What this repo is

- Python 3.12+ project for **draft-first skill generation** (DSPy) with a **FastAPI server** and **Typer CLI**.
- “Skills” are on-disk artifacts under `skills/` (plus a DB for jobs/analytics/coordination).

## Entry points & boundaries

- **API server**: `uv run skill-fleet serve` → `uvicorn skill_fleet.app.main:app`.
  - FastAPI factory: `src/skill_fleet/app/factory.py` (CORS + middleware + exception mapping).
  - Routes: `src/skill_fleet/app/api/v1/router.py` (mounted at `/api/v1/*`).
- **CLI**: `src/skill_fleet/cli/app.py` (global `--api-url` / `SKILL_FLEET_API_URL`; most commands call the API via `SkillFleetClient`).

## Day-to-day dev loop (use uv)

- Install: `uv sync --group dev`
- Lint/format: `uv run ruff check --fix .` then `uv run ruff format .`
  - Note: `skills/**` is excluded from ruff (see `pyproject.toml`).
- Tests: `uv run pytest` (see `tests/conftest.py` for default env wiring).

## Critical runtime configuration

- **LLM config** is loaded by `configure_dspy()` from `config/config.yaml` (`src/skill_fleet/llm/dspy_config.py`).
  - Requires `GOOGLE_API_KEY` (or `LITELLM_API_KEY` fallback); see `.env.example`.
- **Database** is initialized during API lifespan (`src/skill_fleet/app/lifespan.py`) and by `skill_fleet.db.database.init_db()`.
  - Expect to set `DATABASE_URL` (PostgreSQL) when running the server; see `.env.example`.

## Core flow (draft-first)

1. CLI creates a job via `POST /api/v1/skills` (`src/skill_fleet/app/api/v1/skills/router.py`).
2. Workflow writes to `skills/_drafts/<job_id>/...` (draft artifacts).
3. Promote explicitly via `uv run skill-fleet promote <job_id>` or `POST /api/v1/drafts/{job_id}/promote`
   (`src/skill_fleet/app/api/v1/drafts/router.py`).

## Skill validation rules (what the code enforces)

- Validator: `src/skill_fleet/validators/skill_validator.py`.
- A directory-skill must have `SKILL.md` with **YAML frontmatter** and a **`## When to Use`** section.
- Preferred subdirs for new skills: `references/`, `guides/`, `templates/`, `scripts/`, `examples/` (+ `assets/`, `images/`, `static/`).
  Legacy dirs (`capabilities/`, `resources/`, `tests/`) are tolerated but discouraged.
- Treat filesystem paths as **untrusted input** in API code: use `skill_fleet.common.security` helpers
  (e.g., `resolve_path_within_root`, `sanitize_relative_file_path`, `sanitize_taxonomy_path`).


============================================================
END FILE: .github/copilot-instructions.md
============================================================

============================================================
FILE: .github/instructions/python-tests.instructions.md
============================================================

---
applyTo: "tests/**/*.py"
---

When writing Python tests:

## Test Structure Essentials
- Use pytest as the primary testing framework
- Follow AAA pattern: Arrange, Act, Assert
- Write descriptive test names that explain the behavior being tested
- Keep tests focused on one specific behavior

## Key Testing Practices
- Use pytest fixtures for setup and teardown
- Mock external dependencies (databases, APIs, file operations)
- Use parameterized tests for testing multiple similar scenarios
- Test edge cases and error conditions, not just happy paths

## Example Test Pattern
```python
import pytest
from unittest.mock import Mock, patch

