<!-- Chunk 270: bytes 336780-342296, type=class -->
class ConcurrencyAnalyzer(ast.NodeVisitor):
    """Analyze concurrency issues in async Python code."""

    def __init__(self, filepath: str):
        self.filepath = filepath
        self.issues: list[dict[str, Any]] = []
        self.current_class: str | None = None
        self.current_function: str | None = None
        self.is_async_context = False
        self.class_attributes: set[str] = set()
        self.instance_mutations: list[dict[str, Any]] = []

    def visit_ClassDef(self, node: ast.ClassDef) -> None:
        """Track class definitions and their attributes."""
        old_class = self.current_class
        old_attrs = self.class_attributes.copy()

        self.current_class = node.name
        self.class_attributes = set()

        # Find __init__ and track assigned attributes
        for item in node.body:
            if isinstance(item, ast.FunctionDef) and item.name == "__init__":
                self._extract_init_attributes(item)

        self.generic_visit(node)

        self.current_class = old_class
        self.class_attributes = old_attrs

    def _extract_init_attributes(self, init_node: ast.FunctionDef) -> None:
        """Extract self.attr assignments from __init__."""
        for node in ast.walk(init_node):
            if isinstance(node, ast.Assign):
                for target in node.targets:
                    if (isinstance(target, ast.Attribute) and
                        isinstance(target.value, ast.Name) and
                        target.value.id == "self"):
                        self.class_attributes.add(target.attr)

    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> None:
        """Visit async function definitions."""
        old_func = self.current_function
        old_async = self.is_async_context

        self.current_function = node.name
        self.is_async_context = True

        self.generic_visit(node)

        self.current_function = old_func
        self.is_async_context = old_async

    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:
        """Visit sync function definitions."""
        old_func = self.current_function
        old_async = self.is_async_context

        self.current_function = node.name
        self.is_async_context = False

        self.generic_visit(node)

        self.current_function = old_func
        self.is_async_context = old_async

    def visit_Assign(self, node: ast.Assign) -> None:
        """Detect self.attr = X assignments in async context."""
        if not self.is_async_context or not self.current_class:
            self.generic_visit(node)
            return

        for target in node.targets:
            if (isinstance(target, ast.Attribute) and
                isinstance(target.value, ast.Name) and
                target.value.id == "self"):

                attr_name = target.attr
                # Skip private attributes that are likely intentional state
                if attr_name.startswith("_") and not attr_name.startswith("__"):
                    # Still flag if it looks like shared state
                    if any(kw in attr_name.lower() for kw in ["client", "session", "config", "agent"]):
                        self._add_mutation_issue(node, attr_name, "shared_state_mutation")
                else:
                    self._add_mutation_issue(node, attr_name, "instance_mutation_in_async")

        self.generic_visit(node)

    def visit_AugAssign(self, node: ast.AugAssign) -> None:
        """Detect self.attr += X in async context."""
        if not self.is_async_context or not self.current_class:
            self.generic_visit(node)
            return

        if (isinstance(node.target, ast.Attribute) and
            isinstance(node.target.value, ast.Name) and
            node.target.value.id == "self"):

            attr_name = node.target.attr
            self._add_mutation_issue(node, attr_name, "augmented_mutation_in_async")

        self.generic_visit(node)

    def _add_mutation_issue(self, node: ast.AST, attr_name: str, issue_type: str) -> None:
        """Add a mutation issue to the list."""
        severity = "warning"
        if any(kw in attr_name.lower() for kw in ["client", "session", "model", "agent", "config"]):
            severity = "critical"

        messages = {
            "instance_mutation_in_async": (
                f"Mutating `self.{attr_name}` in async method `{self.current_function}` "
                f"of class `{self.current_class}`. This can cause race conditions if "
                f"multiple requests share the same instance."
            ),
            "shared_state_mutation": (
                f"Mutating potentially shared state `self.{attr_name}` in async method "
                f"`{self.current_function}`. If this class is a singleton or shared across "
                f"requests, concurrent modifications can cause data corruption."
            ),
            "augmented_mutation_in_async": (
                f"Augmented assignment to `self.{attr_name}` in async method "
                f"`{self.current_function}`. This is not atomic and can cause race conditions."
            ),
        }

        self.issues.append({
            "type": issue_type,
            "severity": severity,
            "line": node.lineno,
            "class": self.current_class,
            "function": self.current_function,
            "attribute": attr_name,
            "message": messages.get(issue_type, f"Concurrency issue with self.{attr_name}"),
        })


