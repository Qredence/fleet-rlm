<!-- Chunk 658: bytes 1041565-1191565, type=size -->
def main():
    parser = argparse.ArgumentParser(description="Quick DSPy optimization")
    parser.add_argument(
        "--trainset",
        default="config/training/trainset_v4.json",
        help="Path to training set JSON",
    )
    parser.add_argument(
        "--optimizer",
        choices=["gepa", "miprov2"],
        default="gepa",
        help="Optimizer to use (default: gepa for speed)",
    )
    parser.add_argument(
        "--auto",
        choices=["light", "medium", "heavy"],
        default="medium",
        help="MIPROv2 auto level (default: medium)",
    )
    parser.add_argument(
        "--output",
        default="config/optimized/quick_optimized.pkl",
        help="Output path for optimized program",
    )
    parser.add_argument(
        "--test-split",
        type=float,
        default=0.2,
        help="Test set split ratio (default: 0.2)",
    )
    
    args = parser.parse_args()
    
    print("=" * 60)
    print("Quick DSPy Optimization")
    print("=" * 60)
    print(f"Trainset: {args.trainset}")
    print(f"Optimizer: {args.optimizer}")
    if args.optimizer == "miprov2":
        print(f"Auto level: {args.auto}")
    print(f"Output: {args.output}")
    print("=" * 60)
    
    # Configure DSPy
    logger.info("Configuring DSPy with Gemini 3 Flash...")
    lm = get_lm("gemini-3-flash-preview", temperature=1.0)
    dspy.configure(lm=lm)
    
    # Load data
    examples = load_trainset(args.trainset)
    
    # Split train/test
    split_idx = int(len(examples) * (1 - args.test_split))
    trainset = examples[:split_idx]
    testset = examples[split_idx:]
    
    logger.info(f"Split: {len(trainset)} train, {len(testset)} test")
    
    # Create program
    program = create_simple_program()
    
    # Baseline evaluation
    logger.info("Running baseline evaluation...")
    
    from dspy.evaluate import Evaluate
    evaluator = Evaluate(devset=testset, metric=comprehensive_metric)
    baseline_score = evaluator(program)
    
    logger.info(f"Baseline score: {baseline_score:.3f}")
    
    # Run optimization
    logger.info(f"\nRunning {args.optimizer} optimization...")
    
    if args.optimizer == "gepa":
        optimizer = dspy.GEPA(
            metric=comprehensive_metric,
            num_candidates=5,
            num_iters=2,
        )
        optimized = optimizer.compile(program, trainset=trainset)
    
    else:  # miprov2
        optimizer = dspy.MIPROv2(
            metric=comprehensive_metric,
            auto=args.auto,
            num_threads=8,
        )
        optimized = optimizer.compile(
            program,
            trainset=trainset,
            max_bootstrapped_demos=2,
            max_labeled_demos=2,
            num_candidate_programs=8,
        )
    
    # Evaluate optimized
    logger.info("Evaluating optimized program...")
    optimized_score = evaluator(optimized)
    
    # Results
    improvement = optimized_score - baseline_score
    
    print("\n" + "=" * 60)
    print("Results")
    print("=" * 60)
    print(f"Baseline:  {baseline_score:.3f}")
    print(f"Optimized: {optimized_score:.3f}")
    print(f"Improvement: {improvement:+.3f} ({improvement/baseline_score*100:+.1f}%)")
    print("=" * 60)
    
    # Save
    output_path = Path(args.output)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    import pickle
    with open(output_path, "wb") as f:
        pickle.dump(optimized, f)
    
    logger.info(f"\n✅ Saved optimized program to {output_path}")
    
    # Save results
    results_path = output_path.with_suffix(".json")
    results = {
        "optimizer": args.optimizer,
        "auto": args.auto if args.optimizer == "miprov2" else None,
        "trainset_size": len(trainset),
        "testset_size": len(testset),
        "baseline_score": baseline_score,
        "optimized_score": optimized_score,
        "improvement": improvement,
        "improvement_pct": improvement / baseline_score * 100 if baseline_score > 0 else 0,
    }
    
    with open(results_path, "w") as f:
        json.dump(results, f, indent=2)
    
    logger.info(f"✅ Saved results to {results_path}")


if __name__ == "__main__":
    main()


============================================================
END FILE: .fleet/skills/dspy-optimization-workflow/scripts/quick_optimize.py
============================================================

============================================================
FILE: .fleet/skills/fastapi-stack-development/SKILL.md
============================================================

---
name: FastAPI Stack Development
description: Comprehensive guidance for FastAPI, Typer, and SQLModel development including patterns, best practices, API design, CLI development, database integration, testing, and common workflows. Use this skill when building applications with any of these frameworks.
---

# FastAPI Stack Development Skill

This skill provides guidance for the FastAPI ecosystem: **FastAPI** (web APIs), **Typer** (CLI tools), and **SQLModel** (database models). All three frameworks share common patterns and work seamlessly together.

## When to Use This Skill

Load this skill when you are:
- Building FastAPI applications and REST APIs
- Creating Typer CLI tools and utilities
- Designing SQLModel database schemas and queries
- Developing applications combining these technologies
- Refactoring or debugging FastAPI stack code
- Setting up new projects with this stack

Unload this skill when you're done with FastAPI/CLI/DB work to free up context.

## FastAPI Core Concepts

### Application Structure
- Organize routes into routers by domain or feature
- Use dependencies for shared logic (auth, DB sessions, config)
- Separate business logic from route handlers (service layer)
- Keep `main.py` minimal - import and include routers

### Pydantic Models & Validation
- Use Pydantic models for request/response bodies
- Leverage field validators for complex validation
- Separate request models from response models
- Use `Field()` for metadata (examples, constraints, descriptions)
- Consider using `BaseModel` vs `SQLModel` appropriately

### Dependency Injection
- Use `Depends()` for injectable components
- Create reusable dependencies (auth, caching, rate limiting)
- Use `yield` for resource cleanup (DB sessions, files)
- Cache dependencies with `use_cache=True` (default) or `use_cache=False`

### Async/Await & Performance
- Use `async def` for I/O-bound operations (DB queries, HTTP requests)
- Use `def` for CPU-bound operations or when not async-ready
- Database: Use `AsyncSession` for async drivers (asyncpg, aiomysql)
- Background tasks with `BackgroundTasks` for fire-and-forget operations

### Middleware & Security
- Add middleware for CORS, logging, compression
- Implement security: OAuth2 scopes, API keys, JWT
- Use `fastapi.security` utilities for auth schemes
- Validate origins in production for CORS

## Typer CLI Development

### Command Structure
- Use `typer.Typer()` for the main app instance
- Create subcommands with `@app.command()` or separate apps with `app.add_typer()`
- Use `app.callback()` for global options and setup
- Group related commands logically

### Arguments & Options
- Use arguments for required positional inputs
- Use options for optional parameters with defaults
- Leverage rich types (Path, File, enums) for automatic validation
- Use `rich` integration for formatted output (tables, panels, progress)

### Testing CLI
- Use `CliRunner` from `typer.testing` for unit tests
- Test happy paths, error cases, and validation
- Mock external dependencies (API calls, DB operations)

### Integration with FastAPI
- Share Pydantic models between API and CLI
- Use CLI for admin tasks (seed DB, migrations, diagnostics)
- Reuse service layer logic between endpoints and commands

## SQLModel Database Patterns

### Model Design
- Use `SQLModel` for tables that map to database
- Use `Field()` for DB constraints (primary_key, index, unique)
- Define relationships with back_populates
- Use `Field(default=None)` for nullable columns
- Separate read/write models with `Field(exclude=True)` or separate classes

### Session Management
- Use `sessionmaker` for DB session factory
- Async: Use `async_sessionmaker` with `AsyncSession`
- Use `yield` in dependencies for automatic cleanup
- Always commit or rollback explicitly

### Query Patterns
- Use `select(Model).where(Model.field == value)` for filtering
- Chain `.where()` conditions with `&` and `|`
- Use `.limit()` and `.offset()` for pagination
- Eager load relationships with `.selectinload()` or `.joinedload()`
- Use `.exec()` for queries, `.scalar_one_or_none()` for single results

### Migrations
- Use Alembic for schema migrations
- Generate migration with `alembic revision --autogenerate`
- Review generated migrations before applying
- Test migrations on a staging database first

## Integration Patterns

### FastAPI + SQLModel
- Create DB dependency that yields a session
- Pass session to service layer, not route handlers
- Use `response_model=` to document output types
- Return Pydantic models directly from endpoints

### Typer + FastAPI
- Share models between `models/` directory
- CLI commands can import FastAPI services
- Use CLI for health checks, data imports, admin tasks

### Pydantic Model Reuse
- Create base models in `models/base.py`
- Use inheritance for request/response variants
- Keep models in `models/` separate from routes
- Consider using `TypeAdapter` for validation outside APIs

### Configuration Management
- Use `pydantic-settings` for environment-based config
- Share config instance across FastAPI and Typer
- Validate config at startup with Pydantic
- Document environment variables in README

## Project Structure

### Recommended Layout
```
project/
├── alembic/              # Database migrations
├── app/
│   ├── __init__.py
│   ├── main.py          # FastAPI app instance
│   ├── cli.py           # Typer CLI app
│   ├── config.py        # Pydantic settings
│   ├── models/          # SQLModel models
│   ├── schemas/         # Request/response models
│   ├── api/             # FastAPI routers
│   ├── services/        # Business logic
│   ├── db/              # Database utilities
│   └── utils/           # Shared utilities
├── tests/
└── requirements.txt     # or pyproject.toml
```

### Separation of Concerns
- Routes: HTTP request/response handling only
- Services: Business logic and orchestration
- Models: Data structures and database schemas
- Utils: Pure functions and helpers

### Test Organization
- Mirror source structure in `tests/`
- Unit tests for services and utilities
- Integration tests for API endpoints
- Use `pytest` and `httpx.AsyncClient` for FastAPI testing

## Common Workflows

### Setting Up a New Project
1. Create virtual environment and install dependencies
2. Initialize FastAPI app in `main.py`
3. Set up `pydantic-settings` in `config.py`
4. Create SQLModel models in `models/`
5. Configure Alembic for migrations
6. Create Typer CLI in `cli.py`
7. Set up test fixtures and tests

### Adding Authentication
1. Install `python-jose` and `passlib` for JWT
2. Create auth dependency with `Depends()`
3. Add login endpoint that returns JWT token
4. Protect routes with `Depends(get_current_user)`
5. Add optional OAuth2 scopes for fine-grained access

### Creating Admin CLI Commands
1. Add command in `cli.py` with `@app.command()`
2. Import models and services from `app/`
3. Add rich output for better UX
4. Add tests with `CliRunner`
5. Document in `--help` text

### Database Migrations
1. Create Alembic config with `alembic init`
2. Set `sqlalchemy.url` in `alembic.ini`
3. Generate migration with `autogenerate`
4. Review and edit migration script
5. Apply with `alembic upgrade head`
6. Add rollback with `alembic downgrade -1`

### Testing Strategies
- Unit tests: Mock DB and external services
- Integration tests: Use test database, real sessions
- FastAPI: Use `httpx.AsyncClient` with test app
- Typer: Use `CliRunner` with test runner
- Use pytest fixtures for common setup (DB, client, auth)

## Best Practices

### Type Hints Across Frameworks
- Always annotate function signatures
- Use `typing.Optional` for nullable fields
- Use `typing.List[Model]` or `list[Model]` for collections
- Leverage Pydantic for runtime type checking
- Run `mypy` or `pyright` for static type checking

### Validation & Error Handling
- Use Pydantic for request validation (automatic)
- Return `HTTPException` for expected errors
- Use custom exception handlers for consistent responses
- Log errors with context (request ID, user ID, params)
- Never expose stack traces in production

### Documentation
- API: OpenAPI/Swagger at `/docs` auto-generated
- Add `description=` to endpoints for better docs
- Add examples to Pydantic fields
- CLI: Use `help=` on arguments and options
- Keep README up-to-date with setup and usage

### Async vs Sync Patterns
- Database: Prefer `AsyncSession` with async drivers
- External APIs: Use `httpx.AsyncClient`
- File I/O: Use `aiofiles` for async operations
- CPU-bound: Use `run_in_executor()` if needed

### Performance Optimization
- Use response compression middleware
- Cache expensive operations with `functools.lru_cache` or Redis
- Use database indexes properly
- Eager load relationships to avoid N+1 queries
- Implement rate limiting on public endpoints

### Security Considerations
- Validate all inputs (Pydantic handles this)
- Sanitize user input for queries (SQLModel parameterized)
- Use HTTPS in production
- Implement rate limiting on auth endpoints
- Regularly update dependencies
- Use secrets management for API keys and passwords

## Progressive Disclosure

When working with this skill:
1. Start with SKILL.md - this gives you the core concepts and patterns
2. Only load additional reference docs when you hit a specific problem
3. Focus on the relevant section (FastAPI, Typer, or SQLModel) based on your current task
4. Refer back to project structure and best practices when refactoring

## Reference Resources

- [FastAPI Official Documentation](https://fastapi.tiangolo.com/)
- [Typer Documentation](https://typer.tiangolo.com/)
- [SQLModel Documentation](https://sqlmodel.tiangolo.com/)
- [Pydantic Documentation](https://docs.pydantic.dev/)
- [Alembic Documentation](https://alembic.sqlalchemy.org/)


============================================================
END FILE: .fleet/skills/fastapi-stack-development/SKILL.md
============================================================

============================================================
FILE: .fleet/skills/frontend-ui-integration/SKILL.md
============================================================

---
name: frontend-ui-integration
description: Implement or extend a user-facing workflow in a web application, integrating with existing backend APIs. Use when the feature is primarily a UI/UX change backed by existing APIs, affects only the web frontend, and requires following design system, routing, and testing conventions.
---
# Skill: Frontend UI integration

## Purpose

Implement or extend a user-facing workflow in our primary web application, integrating with **existing backend APIs** and following our **design system, routing, and testing conventions**.

## When to use this skill

- The feature is primarily a **UI/UX change** backed by one or more existing APIs.
- The backend contracts, auth model, and core business rules **already exist**.
- The change affects **only** the web frontend (no schema or service ownership changes).

## Inputs

- **Feature description**: short narrative of the user flow and outcomes.
- **Relevant APIs**: endpoints, request/response types, and links to source definitions.
- **Target routes/components**: paths, component names, or feature modules.
- **Design references**: Figma links or existing screens to mirror.
- **Guardrails**: performance limits, accessibility requirements, and any security constraints.

## Out of scope

- Creating new backend services or changing persistent data models.
- Modifying authentication/authorization flows.
- Introducing new frontend frameworks or design systems.

## Conventions

- **Framework**: React with TypeScript.
- **Routing**: use the existing router and route layout patterns.
- **Styling**: use the in-house design system components (Buttons, Inputs, Modals, Toasts, etc.).
- **State management**: prefer the existing state libraries (e.g., React Query, Redux, Zustand) and follow established patterns.

## Required behavior

1. Implement the UI changes with **strong typing** for all props and API responses.
2. Handle loading, empty, error, and success states using existing primitives.
3. Ensure the UI is **keyboard accessible** and screen-reader friendly.
4. Respect feature flags and rollout mechanisms where applicable.

## Required artifacts

- Updated components and hooks in the appropriate feature module.
- **Unit tests** for core presentation logic.
- **Integration or component tests** for the new flow (e.g., React Testing Library, Cypress, Playwright) where the repo already uses them.
- Minimal **CHANGELOG or PR description text** summarizing the behavior change (to be placed in the PR, not this file).

## Implementation checklist

1. Locate the relevant feature module and existing components.
2. Confirm the backend APIs and types, updating shared TypeScript types if needed.
3. Implement the UI, wiring in API calls via the existing data layer.
4. Add or update tests to cover the new behavior and edge cases.
5. Run the required validation commands (see below).

## Verification

Run the following (adjust commands to match the project):

- `pnpm lint`
- `pnpm test -- --runInBand --watch=false`
- `pnpm typecheck` (if configured separately)

The skill is complete when:

- All tests, linters, and type checks pass.
- The new UI behaves as specified across normal, error, and boundary cases.
- No unrelated files or modules are modified.

## Safety and escalation

- If the requested change requires backend contract changes, **stop** and request a backend-focused task instead.
- If design references conflict with existing accessibility standards, favor accessibility and highlight the discrepancy in the PR description.

============================================================
END FILE: .fleet/skills/frontend-ui-integration/SKILL.md
============================================================

============================================================
FILE: .fleet/skills/neon-db/add-neon-docs/SKILL.md
============================================================

---
name: add-neon-docs
description: Use this skill when the user asks to add documentation, add docs, add references, or install documentation about Neon. Adds Neon best practices reference links to project AI documentation (CLAUDE.md, AGENTS.md, or Cursor rules). Does not install packages or modify code.
allowed-tools: ["read_file", "write", "bash", "AskUserQuestion"]
---

# Add Neon Knowledge References to Project

This skill adds reference links to Neon documentation and best practices in your project's AI documentation file, enabling AI assistants to quickly access Neon-specific patterns and guidelines without cluttering your project with large documentation files.

## How It Works

This skill follows a simple workflow:

1. **Load metadata** - Read skill information from `skill-knowledge-map.json`
2. **Detect documentation file** - Find `CLAUDE.md`, `AGENTS.md`, or Cursor rules files
3. **Ask permission** - Show what will be added and where
4. **Add references** - Insert URLs in a "Resources & References" section
5. **Report completion** - Confirm successful installation

For detailed workflow steps, see `install-knowledge.md`.

## Parameters

### SKILL_NAME Parameter

Optional. Specifies which skill documentation to install (e.g., `"neon-drizzle"`). If not provided, you'll be prompted to choose from available skills defined in `skill-knowledge-map.json`.

## Usage Examples

**Called from another skill:**
```markdown
Execute the add-neon-docs skill with SKILL_NAME="neon-drizzle"
```

**Called directly by user:**
- "Add neon drizzle knowledge to my project"
- "Install neon serverless documentation"
- "Set up Neon best practices for my AI assistant"

## What Gets Added

References are added to a "Resources & References" section in your AI documentation file:

```markdown
## Resources & References

- **Neon and Drizzle ORM best practices**: https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/neon-drizzle.mdc
- **Serverless connection patterns**: https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/neon-serverless.mdc
```

### Target Files (in priority order):
- `CLAUDE.md` - Most common for Claude Code projects
- `AGENTS.md` - Custom AI documentation files
- `.cursor/README.md` or `.cursor/rules.md` - Cursor IDE projects
- Creates `CLAUDE.md` if none exist

### Behavior:
- Existing "Resources & References" sections: New links are appended
- No existing section: Section is created at end of file
- No documentation file: `CLAUDE.md` is created with references

## Related Skills

- **neon-drizzle** - Sets up Drizzle ORM, then offers this skill
- **neon-serverless** - Sets up connections, then offers this skill
- **neon-toolkit** - Sets up ephemeral databases, then offers this skill

## Workflow Reference

For complete implementation details:
- **Workflow**: `install-knowledge.md` - Step-by-step agent workflow with error handling
- **Metadata**: `skill-knowledge-map.json` - Skill definitions and reference URLs

---

## Workflow Implementation

Now I'll execute the installation workflow for you.

**Parameter received**: SKILL_NAME = ${SKILL_NAME || "not provided - will ask user"}

Execute `install-knowledge.md` with the specified SKILL_NAME.


============================================================
END FILE: .fleet/skills/neon-db/add-neon-docs/SKILL.md
============================================================

============================================================
FILE: .fleet/skills/neon-db/add-neon-docs/install-knowledge.md
============================================================

# Install Neon Knowledge to Project - Agent Workflow

**When to use**: When the user wants to add Neon's best practices reference links to their project's AI documentation.

**Required parameter**: `SKILL_NAME` (e.g., "neon-drizzle", "neon-serverless", "neon-toolkit")

---

> **IMPORTANT - Working Directory Context**
>
> This skill reads metadata from its own skill directory (`skill-knowledge-map.json`), but **ALL project file operations** (reading/writing `CLAUDE.md`, `AGENTS.md`, etc.) **MUST happen in the current working directory**.
>
> - ✅ Read skill metadata from skill directory (absolute paths provided by system)
> - ✅ Read/write project files using **relative paths only** (e.g., `CLAUDE.md`, `.cursor/rules.md`)
> - ❌ Never construct project file paths using absolute paths or the skill's base directory

---

## Step 1: Load Skill Metadata

Read the skill metadata file to get the reference URLs.

The metadata file is bundled with this skill at:
```
skill-knowledge-map.json
```

Use the Read tool to read the local file, then parse the JSON content.

Extract the metadata for the current `SKILL_NAME` from the JSON.

Store this information - you'll need:
- `displayName`: Human-readable skill name
- `files`: Array of .mdc files (each with `url`, `filename`, `description`)

If the skill is not found in metadata, inform the user and exit.

---

## Step 2: Detect AI Documentation File

Use your existing tools to detect where to add the reference links in the **current working directory**. **This is a read-only check - no files are created yet.**

Check in this priority order:

### 2.1 Check for CLAUDE.md (most common)

Use the Glob tool to search for `CLAUDE.md` in the current working directory:
```
pattern: "CLAUDE.md"
```

**If found**: Target is `CLAUDE.md` file

### 2.2 Check for AGENTS.md (custom AI docs)

Use the Glob tool to search for `AGENTS.md`:
```
pattern: "AGENTS.md"
```

**If found**: Target is `AGENTS.md` file

### 2.3 Check for Cursor rules file

Use the Glob tool to search for Cursor rules files:
```
pattern: ".cursor/README.md"
pattern: ".cursor/rules.md"
```

**If found**: Target is `.cursor/README.md` or `.cursor/rules.md`

### 2.4 No file found
If none of the above exist, set target as: "Will create `CLAUDE.md`"

**Store the detection result** for use in Step 3.

---

## Step 3: Present Plan and STOP for User Confirmation

**STOP HERE.** Do not proceed to Step 4 until the user explicitly confirms.

Now that you know WHAT to add (from Step 1) and WHERE to add it (from Step 2), present this plan to the user in natural language:

---

I've prepared to add **${displayName}** best practices references to your project.

**Target location:** ${detected_location or "Will create CLAUDE.md"}

**References to add:**
${list each file with a bullet point showing the description and URL}

This helps your AI assistant reference Neon best practices automatically in future conversations without cluttering your project with large documentation files.

Would you like me to proceed with adding these references?

---

**Wait for explicit user confirmation** (e.g., "yes", "go ahead", "proceed") before continuing to Step 4.

If the user declines or asks to skip, thank them and exit the workflow gracefully.

---

## Step 4: Add Reference Links

### 4.1 Build the reference content

For each file in the metadata, create a reference line:

```markdown
- **${description}**: ${url}
```

Combine all references into a section:

```markdown
## Resources & References

- **${file1.description}**: ${file1.url}
- **${file2.description}**: ${file2.url}
```

### 4.2 Check if "Resources & References" section exists

Read the target file and check if it already has a "## Resources & References" section.

**If section exists:**
- Use the Edit tool to append new references to that section
- Add the new links after existing content in that section
- Ensure proper spacing (blank line between entries)

**If section doesn't exist:**
- Append the entire section to the end of the file
- Add two blank lines before the section for proper spacing

**If target file doesn't exist yet:**
- Use the Write tool to create a new file with:
  ```markdown
  # Project AI Documentation

  ## Resources & References

  - **${file.description}**: ${file.url}
  ```

### 4.3 Perform the edit/write

**IMPORTANT**: Use relative paths only when calling Write/Edit tools.

Examples:
- ✅ Correct: `file_path: "CLAUDE.md"`
- ✅ Correct: `file_path: ".cursor/rules.md"`
- ❌ Wrong: `file_path: "/absolute/path/to/CLAUDE.md"`

Execute the appropriate tool operation based on the above conditions.

### 4.4 Confirm installation

Log: `✓ Added ${displayName} reference links to ${target_location}`

---

## Step 5: Report Completion

Build a completion message:

```markdown
✅ Reference links added successfully!

Location: ${target_location}

References added:
${list each reference with title and URL}

---

Your AI assistant can now reference these Neon best practices in future conversations by following the URLs. The documentation includes:
- Connection patterns and configuration
- Best practices and gotchas
- Code examples and templates
- Common patterns and solutions

${if target is CLAUDE.md:}
Note: I'll automatically reference these resources when you ask about ${SKILL_NAME} topics.
${end if}

${if target is Cursor:}
Note: Cursor can access these resources when working on related code.
${end if}
```

---

## Error Handling

### If metadata file cannot be read
- Log a clear error message
- Suggest checking internet connection
- Exit workflow

### If write permissions denied
- Inform user about permission issue
- Suggest running with appropriate permissions
- Provide manual instructions for adding links

### If target file is locked or unavailable
- Inform user of the issue
- Suggest closing editors or checking file permissions
- Provide the reference links for manual addition

---

## Testing This Workflow

As Claude, you can test this workflow by:

1. Reading the metadata file
2. Detecting the current project's documentation file
3. Simulating user responses (or asking real questions)
4. Adding references to test locations

Verify:
- [ ] Metadata loads correctly
- [ ] File detection works for multiple project types
- [ ] Permission prompt is clear
- [ ] References are added in the correct format
- [ ] Existing "Resources & References" sections are preserved
- [ ] New sections are created when needed
- [ ] Error messages are clear

---

## For Skill Developers

To use this workflow in your skill, add at the end of your guide or skill:

```markdown
## Add Best Practices References?

Setup is complete! Would you like me to add ${SKILL_NAME} best practices reference links to your project?

This helps your AI assistant (me!) remember where to find Neon patterns for future conversations.

${Execute workflow: skills/add-neon-docs/install-knowledge.md with SKILL_NAME="${skill-name}"}
```

Or explicitly call it:

```markdown
I'll now add reference links to help you in future conversations.

${Read and execute: skills/add-neon-docs/install-knowledge.md}
${Set SKILL_NAME = "neon-drizzle"}
```


============================================================
END FILE: .fleet/skills/neon-db/add-neon-docs/install-knowledge.md
============================================================

============================================================
FILE: .fleet/skills/neon-db/add-neon-docs/skill-knowledge-map.json
============================================================

{
  "neon-drizzle": {
    "displayName": "Neon + Drizzle ORM",
    "files": [
      {
        "url": "https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/neon-drizzle.mdc",
        "filename": "neon-drizzle.mdc",
        "required": true,
        "description": "Comprehensive guide for using Neon with Drizzle ORM"
      },
      {
        "url": "https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/neon-serverless.mdc",
        "filename": "neon-serverless.mdc",
        "required": false,
        "description": "Optional: Serverless connection patterns"
      }
    ],
    "completionMessage": "Your AI assistant now has Neon + Drizzle best practices!"
  },
  "neon-serverless": {
    "displayName": "Neon Serverless Connections",
    "files": [
      {
        "url": "https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/neon-serverless.mdc",
        "filename": "neon-serverless.mdc",
        "required": true,
        "description": "Serverless database connection patterns"
      }
    ],
    "completionMessage": "Your AI assistant now has Neon serverless best practices!"
  },
  "neon-toolkit": {
    "displayName": "Neon Toolkit (Ephemeral DBs)",
    "files": [
      {
        "url": "https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/neon-toolkit.mdc",
        "filename": "neon-toolkit.mdc",
        "required": true,
        "description": "Creating ephemeral databases for testing"
      }
    ],
    "completionMessage": "Your AI assistant can now help with ephemeral databases!"
  },
  "neon-auth": {
    "displayName": "Neon Auth",
    "files": [
      {
        "url": "https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/neon-auth.mdc",
        "filename": "neon-auth.mdc",
        "required": true,
        "description": "Authentication with Neon Auth using @neondatabase/auth"
      }
    ],
    "completionMessage": "Your AI assistant now understands Neon Auth patterns!"
  },
  "neon-js": {
    "displayName": "Neon JS SDK",
    "files": [
      {
        "url": "https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/neon-js.mdc",
        "filename": "neon-js.mdc",
        "required": true,
        "description": "Full Neon JS SDK with Auth and Data API"
      },
      {
        "url": "https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/neon-auth.mdc",
        "filename": "neon-auth.mdc",
        "required": false,
        "description": "Optional: Detailed auth patterns"
      }
    ],
    "completionMessage": "Your AI assistant now has Neon JS SDK best practices!"
  }
}


============================================================
END FILE: .fleet/skills/neon-db/add-neon-docs/skill-knowledge-map.json
============================================================

============================================================
FILE: .fleet/skills/neon-db/neon-auth/SKILL.md
============================================================

---
name: neon-auth
description: Sets up Neon Auth for your application. Configures authentication, creates auth routes, and generates UI components. Use when adding authentication to Next.js, React SPA, or Node.js projects.
allowed-tools: ["bash", "write", "read_file"]
---

# Neon Auth Integration

Add authentication to your application.

## When to Use This Skill

- Adding authentication to a new or existing project
- Implementing sign-in, sign-up, and session management
- Configuring social authentication (Google, GitHub)

**Package**: `@neondatabase/auth` (auth only, smaller bundle)

**Need database queries too?** Use the `neon-js` skill instead for `@neondatabase/neon-js` with unified auth + data API.

## Code Generation Rules

When generating TypeScript/JavaScript code, follow these rules:

**Complete reference:** See [Code Generation Rules](https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/references/code-generation-rules.md) for:
- Import path handling (path aliases vs relative imports)
- Neon package imports (subpath exports, adapter patterns)
- CSS import strategy (Tailwind detection, single import method)
- File structure patterns

**Key points:**
- Check `tsconfig.json` for path aliases before generating imports
- Use relative imports if unsure or no aliases exist
- `BetterAuthReactAdapter` MUST be imported from `auth/react/adapters` subpath
- Adapters are factory functions - call them with `()`
- Choose ONE CSS import method (Tailwind or CSS, not both)

## Available Guides

Each guide is a complete, self-contained walkthrough with numbered phases:

- **`guides/nextjs-setup.md`** - Complete Next.js App Router setup guide
- **`guides/react-spa-setup.md`** - Detailed React SPA guide with react-router-dom integration

I'll automatically detect your context (package manager, framework, existing setup) and select the appropriate guide based on your request.

For troubleshooting, see the [Troubleshooting Guide](https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/references/neon-auth-troubleshooting.md) in references.

## Quick Examples

Tell me what you're building - I'll handle the rest:

- "Add authentication to my Next.js app" -> Loads setup guide, sets up auth routes
- "Set up sign-in with Google" -> Configures social auth provider
- "Debug my auth session not persisting" -> Loads troubleshooting guide

## Reference Documentation

**Primary Resource:** See [neon-auth.mdc](https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/neon-auth.mdc) for comprehensive guidelines including:
- All authentication methods (email/password, social, magic link)
- Session data structure
- UI components reference
- Error handling

**Framework-Specific Setup (choose your framework):**
- [Setup - Next.js](https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/references/neon-auth-setup-nextjs.md)
- [Setup - React SPA](https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/references/neon-auth-setup-react-spa.md)
- [Setup - Node.js](https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/references/neon-auth-setup-nodejs.md)

**Framework-Specific UI (choose your framework):**
- [UI - Next.js](https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/references/neon-auth-ui-nextjs.md)
- [UI - React SPA](https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/references/neon-auth-ui-react-spa.md)

**Shared References:**
- [Common Mistakes](https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/references/neon-auth-common-mistakes.md) - Import paths, adapter patterns, CSS
- [Troubleshooting Guide](https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/references/neon-auth-troubleshooting.md) - Error solutions
- [Code Generation Rules](https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/references/code-generation-rules.md) - Import and CSS strategies
- [Auth Adapters Guide](https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/references/neon-js-adapters.md) - Adapter comparison
- [Import Reference](https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/references/neon-js-imports.md) - Complete import paths

## Templates

- `templates/nextjs-api-route.ts` - API route handler for Next.js
- `templates/auth-client.ts` - Client-side auth configuration

## Related Skills

- **neon-js** - Full SDK with auth + database queries (use if you need PostgREST-style data access)
- **neon-drizzle** - Drizzle ORM setup (for database queries)
- **neon-serverless** - Direct database connections
- **add-neon-docs** - Add Neon best practices to your project (run after setup)

---

## Workflow

I will:
1. Detect your project context automatically (Next.js, React SPA, Node.js)
2. Select and load the appropriate guide
3. Follow the guide's phases sequentially
4. Track progress using the guide's workflow checklist
5. Load reference files only when needed
6. Offer to add Neon best practices to your project docs

Ready to get started? Just describe what you're building!


============================================================
END FILE: .fleet/skills/neon-db/neon-auth/SKILL.md
============================================================

============================================================
FILE: .fleet/skills/neon-db/neon-auth/guides/nextjs-setup.md
============================================================

# Next.js Auth Setup

> **Complete Walkthrough**: This is a self-contained, step-by-step guide with its own numbered phases (Phase 1-8).
> Follow each phase in order for a full Neon Auth setup in Next.js App Router.

Complete guide for setting up Neon Auth with Next.js App Router.

### Important:
- Remember to run the neon-plugin:add-neon-docs skill with the parameter SKILL_NAME="neon-auth" after completing the guide.

## Table of Contents

- [Next.js Auth Setup](#nextjs-auth-setup)
    - [Important:](#important)
  - [Table of Contents](#table-of-contents)
  - [Workflow Checklist](#workflow-checklist)
  - [Phase 1: Context Detection](#phase-1-context-detection)
  - [Phase 2: Installation](#phase-2-installation)
  - [Phase 3: Environment Configuration](#phase-3-environment-configuration)
  - [Phase 4: API Route Setup](#phase-4-api-route-setup)
  - [Phase 5: Auth Client Configuration](#phase-5-auth-client-configuration)
  - [Phase 6: UI Provider Setup (Optional)](#phase-6-ui-provider-setup-optional)
    - [6.1. Import CSS](#61-import-css)
    - [6.2. Create Auth Provider](#62-create-auth-provider)
    - [6.3. Wrap App in Provider](#63-wrap-app-in-provider)
    - [6.4. Add Navbar with Session Info](#64-add-navbar-with-session-info)
  - [Phase 7: Auth Pages Setup (Optional)](#phase-7-auth-pages-setup-optional)
  - [Phase 8: Validation \& Testing](#phase-8-validation--testing)
    - [8.1. Manual Testing Checklist](#81-manual-testing-checklist)
  - [Phase 9: Add Best Practices References](#phase-9-add-best-practices-references)
  - [Setup Complete!](#setup-complete)

---

## Workflow Checklist

When following this guide, I will track these high-level tasks:

- [ ] Detect project context (package manager, Next.js version, existing auth)
- [ ] Install @neondatabase/auth package
- [ ] Configure environment variables (auth URL)
- [ ] Create API route handler at /api/auth/[...path]
- [ ] Set up auth client for client components
- [ ] (Optional) Set up UI provider with pre-built components
- [ ] (Optional) Create auth pages (/auth/sign-in, etc.)
- [ ] Validate setup and test authentication flow
- [ ] Add Neon Auth best practices to project docs

---

## Phase 1: Context Detection

Auto-detect project context:

**Check Package Manager:**
```bash
ls package-lock.json  # -> npm
ls bun.lockb          # -> bun
ls pnpm-lock.yaml     # -> pnpm
ls yarn.lock          # -> yarn
```

**Check Next.js Version:**
```bash
grep '"next"' package.json
```
Ensure Next.js 13+ with App Router (pages in `app/` directory).

**Check Existing Setup:**
```bash
ls app/api/auth        # Auth routes exist?
ls lib/auth            # Auth client exists?
grep '@neondatabase' package.json  # Already installed?
```

**Check for Tailwind:**
```bash
ls tailwind.config.js tailwind.config.ts 2>/dev/null
```

**Check Environment Files:**
```bash
ls .env .env.local
```

## Phase 2: Installation

Based on detection, install the auth package:

```bash
[package-manager] add @neondatabase/auth
```

Replace `[package-manager]` with your detected package manager (npm install, pnpm add, yarn add, bun add).

## Phase 3: Environment Configuration

**Outcome**: A working `.env.local` file with the Neon Auth URL.

Create or update `.env.local`:

```bash
# Neon Auth URL - get this from your Neon dashboard
# Format: https://ep-xxx.neonauth.c-2.us-east-2.aws.neon.build/dbname/auth
NEON_AUTH_BASE_URL=your-neon-auth-url
NEXT_PUBLIC_NEON_AUTH_URL=your-neon-auth-url
```

**Where to find your Auth URL:**
1. Go to your Neon project dashboard
2. Navigate to the "Auth" tab
3. Copy the Auth URL

**Important:** Both variables are needed:
- `NEON_AUTH_BASE_URL` - Used by server-side API routes
- `NEXT_PUBLIC_NEON_AUTH_URL` - Used by client-side components (prefixed with NEXT_PUBLIC_)

Add to `.gitignore` if not already present:
```
.env.local
```

## Phase 4: API Route Setup

Create the API route handler for authentication endpoints:

**Create file:** `app/api/auth/[...path]/route.ts`

```typescript
import { authApiHandler } from "@neondatabase/auth/next";

export const { GET, POST } = authApiHandler();
```

This creates endpoints for:
- `/api/auth/sign-in` - Sign in
- `/api/auth/sign-up` - Sign up
- `/api/auth/sign-out` - Sign out
- `/api/auth/session` - Get session
- And other auth-related endpoints

## Phase 5: Auth Client Configuration

Create the auth client for use in client components:

**Create file:** `lib/auth/client.ts`

```typescript
import { createAuthClient } from "@neondatabase/auth/next";

export const authClient = createAuthClient();
```

**Usage in components:**

```typescript
"use client";

import { authClient } from "@/lib/auth/client";

function AuthStatus() {
  const session = authClient.useSession();

  if (session.isPending) return <div>Loading...</div>;
  if (!session.data) return <SignInButton />;

  return (
    <div>
      <p>Hello, {session.data.user.name}</p>
      <button onClick={() => authClient.signOut()}>Sign Out</button>
    </div>
  );
}

function SignInButton() {
  return (
    <button onClick={() => authClient.signIn.email({
      email: "user@example.com",
      password: "password"
    })}>
      Sign In
    </button>
  );
}
```

## Phase 6: UI Provider Setup (Optional)

Skip this phase if you're building custom auth forms. Use this if you want pre-built UI components.

### 6.1. Import CSS

Auth UI **automatically inherits your app's existing theme**. If you have CSS variables like `--primary`, `--background`, etc. defined (from Tailwind, shadcn/ui, or custom CSS), auth components use them with no configuration.

Import order doesn't matter - auth styles are in `@layer neon-auth`, so your styles always win.

**If using Tailwind (tailwind.config.{js,ts} exists):**

Add to your global CSS file (e.g., `app/globals.css`):
```css
@import '@neondatabase/auth/ui/tailwind';
```

**If NOT using Tailwind:**

Add to `app/layout.tsx`:
```typescript
import "@neondatabase/auth/ui/css";
```

**Warning:** Never import both - causes 94KB of duplicate styles.

**Auth-specific customization:** To customize auth components differently from your main app, use `--neon-*` prefix variables. See the [theming guide](https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/references/neon-js-theming.md) for details.

### 6.2. Create Auth Provider

**Create file:** `app/auth-provider.tsx`

```typescript
"use client";

import { NeonAuthUIProvider } from "@neondatabase/auth/react/ui";
import { authClient } from "@/lib/auth/client";
import { useRouter } from "next/navigation";
import Link from "next/link";

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const router = useRouter();
  return (
    <NeonAuthUIProvider
      authClient={authClient}
      navigate={router.push}
      replace={router.replace}
      onSessionChange={() => router.refresh()}
      Link={Link}
    >
      {children}
    </NeonAuthUIProvider>
  );
}
```

**To add social login buttons**, add the `social` prop:
```typescript
<NeonAuthUIProvider
  authClient={authClient}
  navigate={router.push}
  replace={router.replace}
  onSessionChange={() => router.refresh()}
  Link={Link}
  social={{
    // TWO configs required: 1) Enable providers in Neon Console, 2) List them here
    providers: ["google", "github"]
  }}
>
  {children}
</NeonAuthUIProvider>
```

### 6.3. Wrap App in Provider

**Update:** `app/layout.tsx`

```typescript
import { AuthProvider } from "./auth-provider";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <AuthProvider>{children}</AuthProvider>
      </body>
    </html>
  );
}
```

### 6.4. Add Navbar with Session Info

Create a navbar component that shows the user's session status:

**Create file:** `components/navbar.tsx`

```typescript
"use client";

import { UserButton, SignedIn, SignedOut } from "@neondatabase/auth/react/ui";
import Link from "next/link";

export function Navbar() {
  return (
    <nav className="flex items-center justify-between p-4 border-b">
      <Link href="/">My App</Link>
      <div className="flex items-center gap-4">
        <SignedOut>
          <Link href="/auth/sign-in">Sign In</Link>
        </SignedOut>
        <SignedIn>
          <UserButton />
        </SignedIn>
      </div>
    </nav>
  );
}
```

**Add to layout:** Update `app/layout.tsx` to include the navbar:

```typescript
import { AuthProvider } from "./auth-provider";
import { Navbar } from "@/components/navbar";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <AuthProvider>
          <Navbar />
          {children}
        </AuthProvider>
      </body>
    </html>
  );
}
```

**Components explained:**
- `<SignedOut>` - Only renders children when user is NOT authenticated
- `<SignedIn>` - Only renders children when user IS authenticated
- `<UserButton />` - Displays user avatar with dropdown menu (sign out, account settings)

## Phase 7: Auth Pages Setup (Optional)

Skip this phase if you're using custom auth forms. Use this for pre-built auth pages.

**Create file:** `app/auth/[path]/page.tsx`

```typescript
import { AuthView } from "@neondatabase/auth/react/ui";
import { authViewPaths } from "@neondatabase/auth/react/ui/server";

export const dynamicParams = false;

export function generateStaticParams() {
  return Object.values(authViewPaths).map((path) => ({ path }));
}

export default async function AuthPage({
  params,
}: {
  params: Promise<{ path: string }>;
}) {
  const { path } = await params;
  return <AuthView pathname={path} />;
}
```

This creates routes for:
- `/auth/sign-in` - Sign in page
- `/auth/sign-up` - Sign up page
- `/auth/forgot-password` - Password reset request
- `/auth/reset-password` - Password reset form
- `/auth/magic-link` - Magic link sign in
- `/auth/two-factor` - Two-factor authentication
- `/auth/callback` - OAuth callback
- `/auth/sign-out` - Sign out page

## Phase 8: Validation & Testing

### 8.1. Manual Testing Checklist

- [ ] Start development server: `npm run dev`
- [ ] Navigate to `/auth/sign-up` (if using pre-built pages)
- [ ] Create a test account
- [ ] Sign out
- [ ] Sign back in
- [ ] Verify session persists across page refresh
- [ ] Check browser console for errors

**Common Issues:**
- "Module not found" - Check import paths match subpath exports
- Session not persisting - Verify API route is correctly configured
- CSS not loading - Check you imported CSS in layout (only one method)

For detailed error resolution, see:
- [Troubleshooting Guide](https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/references/neon-auth-troubleshooting.md)
- [Common Mistakes](https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/references/neon-auth-common-mistakes.md)

## Phase 9: Add Best Practices References

Before executing the add-neon-docs skill, provide a summary of everything that has been done:

"Neon Auth integration is complete! Now adding documentation references..."

Then execute the neon-plugin:add-neon-docs skill with the parameter SKILL_NAME="neon-auth"

This will add reference links to Neon Auth best practices documentation in your project's AI documentation file.

---

## Setup Complete!

Your Neon Auth integration is ready to use.

**What's working:**
- Authentication API routes at `/api/auth/*`
- Client-side auth hooks via `authClient.useSession()`
- (If configured) Pre-built UI components and auth pages

**Next steps:**
- Add protected routes using session checks
- Customize UI theme (see neon-auth.mdc for theming)
- Set up social OAuth providers in Neon dashboard


============================================================
END FILE: .fleet/skills/neon-db/neon-auth/guides/nextjs-setup.md
============================================================

============================================================
FILE: .fleet/skills/neon-db/neon-auth/guides/react-spa-setup.md
============================================================

# React SPA Auth Setup

Complete guide for setting up Neon Auth with React SPAs (Vite, Create React App) using react-router-dom.

## Table of Contents

- [React SPA Auth Setup](#react-spa-auth-setup)
  - [Table of Contents](#table-of-contents)
  - [Phase 1: Auth Client](#phase-1-auth-client)
  - [Phase 2: UI Setup (Optional)](#phase-2-ui-setup-optional)
    - [2a. Install react-router-dom](#2a-install-react-router-dom)
    - [2b. Import CSS](#2b-import-css)
    - [2c. CSS Variables Reference](#2c-css-variables-reference)
    - [2d. Update main.tsx with BrowserRouter](#2d-update-maintsx-with-browserrouter)
    - [2e. Create Auth Provider](#2e-create-auth-provider)
    - [2f. Add Routes to App.tsx](#2f-add-routes-to-apptsx)
  - [Phase 3: Account Settings (Optional)](#phase-3-account-settings-optional)
    - [Add account routes to App.tsx](#add-account-routes-to-apptsx)
  - [Phase 4: Validation](#phase-4-validation)
  - [Complete App.tsx Example](#complete-apptsx-example)

---

## Phase 1: Auth Client

Create `src/lib/auth-client.ts`:

**For `@neondatabase/auth`:**
```typescript
import { createAuthClient } from "@neondatabase/auth";
import { BetterAuthReactAdapter } from "@neondatabase/auth/react/adapters";

export const authClient = createAuthClient(
  import.meta.env.VITE_NEON_AUTH_URL,
  { adapter: BetterAuthReactAdapter() }
);
```

**For `@neondatabase/neon-js`:**
```typescript
import { createClient } from "@neondatabase/neon-js";
import { BetterAuthReactAdapter } from "@neondatabase/neon-js/auth/react/adapters";

export const client = createClient({
  auth: {
    adapter: BetterAuthReactAdapter(),
    url: import.meta.env.VITE_NEON_AUTH_URL,
  },
  dataApi: {
    url: import.meta.env.VITE_NEON_DATA_API_URL,
  },
});

// For convenience, export auth separately
export const authClient = client.auth;
```

**Critical:**
- `BetterAuthReactAdapter` must be imported from the `/react/adapters` subpath
- The adapter must be called as a function: `BetterAuthReactAdapter()`

---

## Phase 2: UI Setup (Optional)

Ask: "Want to add pre-built auth UI components? (sign-in, sign-up forms, user button, account settings)"

**If yes, continue with sub-steps below.**

### 2a. Install react-router-dom

```bash
npm install react-router-dom
```

UI components are included in the main package, you only need react-router-dom for navigation.

### 2b. Import CSS

Auth UI **automatically inherits your app's existing theme**. If you have CSS variables like `--primary`, `--background`, etc. defined (from Tailwind, shadcn/ui, or custom CSS), auth components use them with no configuration.

Import order doesn't matter - auth styles are in `@layer neon-auth`, so your styles always win.

**Choose ONE import method.** Never import both - it causes duplicate styles.

**If NOT using Tailwind** - Add to `src/main.tsx` or entry point:

For `@neondatabase/auth`:
```typescript
import '@neondatabase/auth/ui/css';
```

For `@neondatabase/neon-js`:
```typescript
import '@neondatabase/neon-js/ui/css';
```

**If using Tailwind CSS v4** - Add to main CSS file (e.g., index.css):

For `@neondatabase/auth`:
```css
@import 'tailwindcss';
@import '@neondatabase/auth/ui/tailwind';
```

For `@neondatabase/neon-js`:
```css
@import 'tailwindcss';
@import '@neondatabase/neon-js/ui/tailwind';
```

### 2c. CSS Variables Reference

Auth UI automatically inherits these variables if you have them defined. Use them in custom components for consistency:

| Variable | Purpose |
|----------|---------|
| `--background`, `--foreground` | Page background/text |
| `--card`, `--card-foreground` | Card surfaces |
| `--primary`, `--primary-foreground` | Primary buttons/actions |
| `--muted`, `--muted-foreground` | Muted/subtle elements |
| `--border`, `--ring` | Borders and focus rings |
| `--radius` | Border radius |

**Auth-specific customization:** To customize auth components differently from your main app, use `--neon-*` prefix:

```css
:root {
  --primary: oklch(0.55 0.25 250);       /* Your app's blue */
  --neon-primary: oklch(0.55 0.18 145);  /* Auth uses green */
}
```

**Example - Custom Navbar Styling:**

```css
/* ✅ Correct - uses CSS variables, supports dark mode automatically */
.navbar {
  background: var(--background);
  border-bottom: 1px solid var(--border);
  color: var(--foreground);
}

/* ❌ Wrong - hardcoded colors won't match theme or support dark mode */
.navbar {
  background: #fff;
  border-bottom: 1px solid #e5e5e5;
  color: #111;
}
```

**Dark mode:** Add the `dark` class to `<html>` or `<body>`. All CSS variable values automatically adjust.

**Complete theming guide:** See [UI Theming Guide](https://raw.githubusercontent.com/neondatabase-labs/ai-rules/main/references/neon-js-theming.md)

### 2d. Update main.tsx with BrowserRouter

For `@neondatabase/auth`:
```tsx
import { createRoot } from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import '@neondatabase/auth/ui/css'; // if not using Tailwind
import App from './App';
import { Providers } from './providers';

createRoot(document.getElementById('root')!).render(
  <BrowserRouter>
    <Providers>
      <App />
    </Providers>
  </BrowserRouter>
);
```

For `@neondatabase/neon-js`:
```tsx
import { createRoot } from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import '@neondatabase/neon-js/ui/css'; // if not using Tailwind
import App from './App';
import { Providers } from './providers';

createRoot(document.getElementById('root')!).render(
  <BrowserRouter>
    <Providers>
      <App />
    </Providers>
  </BrowserRouter>
);
```

### 2e. Create Auth Provider

Create `src/providers.tsx`:

For `@neondatabase/auth`:
```tsx
import { NeonAuthUIProvider } from '@neondatabase/auth/react/ui';
import { useNavigate, Link as RouterLink } from 'react-router-dom';
import { authClient } from './lib/auth-client';
import type { ReactNode } from 'react';

// Adapter for react-router-dom Link
function Link({ href, ...props }: { href: string } & React.AnchorHTMLAttributes<HTMLAnchorElement>) {
  return <RouterLink to={href} {...props} />;
}

export function Providers({ children }: { children: ReactNode }) {
  const navigate = useNavigate();

  return (
    <NeonAuthUIProvider
      authClient={authClient}
      navigate={(path) => navigate(path)}
      replace={(path) => navigate(path, { replace: true })}
      onSessionChange={() => {
        // Optional: refresh data or invalidate cache
      }}
      Link={Link}
      social={{
        // TWO configs required: 1) Enable providers in Neon Console, 2) List them here
        providers: ['google', 'github']
      }}
    >
      {children}
    </NeonAuthUIProvider>
  );
}
```

For `@neondatabase/neon-js`:
```tsx
import { NeonAuthUIProvider } from '@neondatabase/neon-js/auth/react/ui';
import { useNavigate, Link as RouterLink } from 'react-router-dom';
import { authClient } from './lib/auth-client';
import type { ReactNode } from 'react';

// Adapter for react-router-dom Link
function Link({ href, ...props }: { href: string } & React.AnchorHTMLAttributes<HTMLAnchorElement>) {
  return <RouterLink to={href} {...props} />;
}

export function Providers({ children }: { children: ReactNode }) {
  const navigate = useNavigate();

  return (
    <NeonAuthUIProvider
      authClient={authClient}
      navigate={(path) => navigate(path)}
      replace={(path) => navigate(path, { replace: true })}
      onSessionChange={() => {
        // Optional: refresh data or invalidate cache
      }}
      Link={Link}
      social={{
        // TWO configs required: 1) Enable providers in Neon Console, 2) List them here
        providers: ['google', 'github']
      }}
    >
      {children}
    </NeonAuthUIProvider>
  );
}
```

**Provider props explained:**
- `navigate`: Function to navigate to a new route
- `replace`: Function to replace current route (for redirects)
- `onSessionChange`: Callback when auth state changes (useful for cache invalidation)
- `Link`: Adapter component for react-router-dom's Link
- `social`: Display social login buttons. Requires TWO configurations: enable in Console + add this prop

### 2f. Add Routes to App.tsx

For `@neondatabase/auth`:
```tsx
import { Routes, Route, useParams } from 'react-router-dom';
import { AuthView, UserButton, SignedIn, SignedOut } from '@neondatabase/auth/react/ui';

// Auth page - handles /auth/sign-in, /auth/sign-up, etc.
function AuthPage() {
  const { pathname } = useParams();
  return (
    <div className="flex min-h-screen items-center justify-center">
      <AuthView pathname={pathname} />
    </div>
  );
}

// Simple navbar example
function Navbar() {
  return (
    <nav className="flex items-center justify-between p-4 border-b">
      <a href="/">My App</a>
      <div className="flex items-center gap-4">
        <SignedOut>
          <a href="/auth/sign-in">Sign In</a>
        </SignedOut>
        <SignedIn>
          <UserButton />
        </SignedIn>
      </div>
    </nav>
  );
}

function HomePage() {
  return <div>Welcome to My App!</div>;
}

export default function App() {
  return (
    <>
      <Navbar />
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/auth/:pathname" element={<AuthPage />} />
      </Routes>
    </>
  );
}
```

For `@neondatabase/neon-js`:
```tsx
import { Routes, Route, useParams } from 'react-router-dom';
import { AuthView, UserButton, SignedIn, SignedOut } from '@neondatabase/neon-js/auth/react/ui';

// Auth page - handles /auth/sign-in, /auth/sign-up, etc.
function AuthPage() {
  const { pathname } = useParams();
  return (
    <div className="flex min-h-screen items-center justify-center">
      <AuthView pathname={pathname} />
    </div>
  );
}

// Simple navbar example
function Navbar() {
  return (
    <nav className="flex items-center justify-between p-4 border-b">
      <a href="/">My App</a>
      <div className="flex items-center gap-4">
        <SignedOut>
          <a href="/auth/sign-in">Sign In</a>
        </SignedOut>
        <SignedIn>
          <UserButton />
        </SignedIn>
      </div>
    </nav>
  );
}

function HomePage() {
  return <div>Welcome to My App!</div>;
}

export default function App() {
  return (
    <>
      <Navbar />
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/auth/:pathname" element={<AuthPage />} />
      </Routes>
    </>
  );
}
```

**Auth routes created:**
- `/auth/sign-in` - Sign in page
- `/auth/sign-up` - Sign up page
- `/auth/forgot-password` - Password reset request
- `/auth/reset-password` - Set new password
- `/auth/sign-out` - Sign out
- `/auth/callback` - OAuth callback (internal)

---

## Phase 3: Account Settings (Optional)

Ask: "Want to add account settings pages where users can manage their profile?"

**If yes:**

### Add account routes to App.tsx

For `@neondatabase/auth`:
```tsx
import { AccountView } from '@neondatabase/auth/react/ui';

// Account settings page
function AccountPage() {
  const { pathname } = useParams();
  return (
    <div className="container mx-auto py-8">
      <AccountView pathname={pathname} />
    </div>
  );
}

// Add to your Routes
<Route path="/account/:pathname" element={<AccountPage />} />
```

For `@neondatabase/neon-js`:
```tsx
import { AccountView } from '@neondatabase/neon-js/auth/react/ui';

// Account settings page
function AccountPage() {
  const { pathname } = useParams();
  return (
    <div className="container mx-auto py-8">
      <AccountView pathname={pathname} />
    </div>
  );
}

// Add to your Routes
<Route path="/account/:pathname" element={<AccountPage />} />
```

**Account routes created:**
- `/account/settings` - Profile settings (name, avatar, email)
- `/account/security` - Password, sessions, 2FA
- `/account/sessions` - Active sessions management

---

## Phase 4: Validation

After setup completes, guide user through testing:

- [ ] Start development server: `npm run dev`
- [ ] Navigate to `/auth/sign-up`
- [ ] Create a test account
- [ ] Sign out
- [ ] Sign back in
- [ ] Verify session persists across page refresh
- [ ] Check browser console for errors

**Common Issues:**
- "Module not found" - Check import paths match subpath exports
- Session not persisting - Verify auth client is configured correctly
- CSS not loading - Check you imported CSS (only one method)

---

## Complete App.tsx Example

Here's a complete example with all routes:

```tsx
import { Routes, Route, useParams } from 'react-router-dom';
import { 
  AuthView, 
  AccountView,
  UserButton, 
  SignedIn, 
  SignedOut 
} from '@neondatabase/auth/react/ui';

function AuthPage() {
  const { pathname } = useParams();
  return (
    <div className="flex min-h-screen items-center justify-center">
      <AuthView pathname={pathname} />
    </div>
  );
}

function AccountPage() {
  const { pathname } = useParams();
  return (
    <div className="container mx-auto py-8">
      <AccountView pathname={pathname} />
    </div>
  );
}

function Navbar() {
  return (
    <nav className="flex items-center justify-between p-4 border-b">
      <a href="/">My App</a>
      <div className="flex items-center gap-4">
        <SignedOut>
          <a href="/auth/sign-in">Sign In</a>
        </SignedOut>
        <SignedIn>
          <UserButton />
        </SignedIn>
      </div>
    </nav>
  );
}

function HomePage() {
  return (
    <div className="container mx-auto py-8">
      <h1>Welcome to My App!</h1>
      <SignedIn>
        <p>You are signed in.</p>
      </SignedIn>
      <SignedOut>
        <p>Please sign in to continue.</p>
      </SignedOut>
    </div>
  );
}

export default function App() {
  return (
    <>
      <Navbar />
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/auth/:pathname" element={<AuthPage />} />
        <Route path="/account/:pathname" element={<AccountPage />} />
      </Routes>
    </>
  );
}
```

---

**Guide Version**: 1.0.0
**Last Updated**: 2025-12-09


============================================================
END FILE: .fleet/skills/neon-db/neon-auth/guides/react-spa-setup.md
============================================================

============================================================
FILE: .fleet/skills/neon-db/neon-drizzle/SKILL.md
============================================================

---
name: neon-drizzle
description: Creates a fully functional Drizzle ORM setup with a provisioned Neon database. Installs dependencies, provisions database credentials, configures connections, generates schemas, and runs migrations. Results in working code that can immediately connect to and query the database. Use when creating new projects with Drizzle, adding ORM to existing applications, or modifying database schemas.
allowed-tools: ["bash", "write", "read_file"]
---

# Neon Drizzle Integration

Comprehensive Drizzle ORM setup for Neon databases with guided workflows.

## When to Use This Skill

- Setting up Drizzle in a new project (Next.js, Vite, Express, etc.)
- Integrating Drizzle into an existing application
- Creating or modifying database schemas
- Troubleshooting migration issues

## Code Generation Rules

When generating TypeScript/JavaScript code:
- BEFORE generating import statements, check tsconfig.json for path aliases (compilerOptions.paths)
- If path aliases exist (e.g., "@/*": ["./src/*"]), use them (e.g., import { x } from '@/lib/utils')
- If NO path aliases exist or unsure, ALWAYS use relative imports (e.g., import { x } from '../../../lib/utils')
- Verify imports match the project's configuration
- Default to relative imports - they always work regardless of configuration

## Available Guides

Each guide is a complete, self-contained walkthrough with numbered phases:

- **`guides/new-project.md`** - Full setup from scratch (see: Table of Contents)
- **`guides/existing-project.md`** - Add Drizzle to running apps (see: Table of Contents)
- **`guides/schema-only.md`** - Schema creation and modification (see: Table of Contents)
- **`guides/troubleshooting.md`** - Debug common issues (organized by error type)

I'll automatically detect your context (package manager, framework, deployment target) and select the appropriate guide based on your request.

## Quick Examples

Tell me what you're building - I'll handle the rest:

- "Setup Drizzle for my Next.js blog on Vercel" → Auto-detects Vercel + Next.js → HTTP adapter
- "Add Drizzle to my Express API" → Auto-detects Node.js server → WebSocket adapter
- "Create a users table with auth fields" → Loads schema guide → Generates schema

## Reference Documentation

For deeper technical details (loaded on-demand):

- `references/adapters.md` - HTTP vs WebSocket decision guide
- `references/migrations.md` - Migration patterns and troubleshooting
- `references/query-patterns.md` - Example queries and best practices

## Templates & Scripts

- `templates/schema-example.ts` - Multi-table schema with relations
- `templates/drizzle-config.ts` - Configuration examples
- `scripts/generate-schema.ts` - Automated migration generation
- `scripts/run-migration.ts` - Programmatic migration runner

## Related Skills

- **neon-auth** - Add authentication
- **neon-js** - Full SDK with auth + PostgREST-style data API
- **neon-serverless** - Connection setup without ORM
- **neon-toolkit** - Ephemeral databases for testing
- **add-neon-docs** - Add Neon best practices to your project (run after setup)

---

## Workflow

I will:
1. Detect your project context automatically
2. Select and load the appropriate guide
3. Follow the guide's phases sequentially
4. Track progress using the guide's workflow checklist
5. Load reference files only when needed
6. Offer to add Neon best practices to your project docs

Ready to get started? Just describe what you're building!


============================================================
END FILE: .fleet/skills/neon-db/neon-drizzle/SKILL.md
============================================================

============================================================
FILE: .fleet/skills/neon-db/neon-drizzle/guides/existing-project.md
============================================================

# Existing Project Integration

> **Complete Walkthrough**: This is a self-contained, step-by-step guide with its own numbered phases (Phase 1-8).
> Follow each phase in order to safely add Drizzle to your existing application.

Guide for adding Drizzle ORM to an existing application with Neon.

### Important:
- Remember to run the neon-plugin:add-neon-docs skill with the parameter SKILL_NAME="neon-drizzle" after completing the guide.

## Table of Contents

- [Workflow Checklist](#workflow-checklist)
- [Phase 1: Pre-Integration Check](#phase-1-pre-integration-check)
- [Phase 2: Incremental Installation](#phase-2-incremental-installation)
- [Phase 3: Configuration](#phase-3-configuration)
- [Phase 4: Schema Strategy](#phase-4-schema-strategy)
- [Phase 5: Migration Handling](#phase-5-migration-handling)
- [Phase 6: Coexistence Patterns](#phase-6-coexistence-patterns)
- [Phase 7: Verification](#phase-7-verification)
- [Phase 8: Add Best Practices References](#phase-8-add-best-practices-references)

---

## Workflow Checklist

When following this guide, I will track these high-level tasks:

- [ ] Pre-integration check (detect existing ORMs, database schema, environment)
- [ ] Install Drizzle dependencies without disrupting existing setup
- [ ] Create isolated Drizzle configuration (separate from existing code)
- [ ] Choose and implement schema strategy (new tables vs mirroring existing)
- [ ] Handle migrations safely based on schema strategy
- [ ] Set up coexistence patterns and gradual migration approach
- [ ] Verify Drizzle integration without breaking existing functionality
- [ ] Add Neon Drizzle best practices to project docs

---

## Phase 1: Pre-Integration Check

Before adding Drizzle, check for conflicts:

### 1.1. Check for Other ORMs

```bash
grep -E '"(prisma|typeorm|sequelize|mongoose)"' package.json
```

**If found:**
- Consider migration strategy (coexistence vs replacement)
- Document which tables use which ORM
- Plan gradual migration if needed

### 1.2. Check Database Schema

Connect to your database and verify existing tables:
```bash
psql $DATABASE_URL -c "\dt"
```

**Important:** Note existing tables - Drizzle should not conflict with them.

### 1.3. Check Environment Setup

```bash
ls .env .env.local .env.production
grep DATABASE_URL .env*
```

**If DATABASE_URL exists:**
- Verify connection string format is compatible with Neon (`postgresql://...`)
- If it's a different database provider, you'll need to migrate or provision a Neon database

**If DATABASE_URL does NOT exist:**
Follow the database provisioning steps from `guides/new-project.md` Phase 3.1:
1. List the projects using the neon MCP Server to check existing projects
2. Create a new project using the neon MCP Server if needed
3. Get the connection string using the neon MCP Server
4. Write to appropriate environment file (.env.local for Next.js, .env for others)
5. Add environment file to .gitignore

## Phase 2: Incremental Installation

Add Drizzle without disrupting existing setup:

### 2.1. Install Dependencies

**For Vercel/Edge:**
```bash
[package-manager] add drizzle-orm @neondatabase/serverless
[package-manager] add -D drizzle-kit dotenv
```

**For Node.js:**
```bash
[package-manager] add drizzle-orm @neondatabase/serverless ws
[package-manager] add -D drizzle-kit dotenv @types/ws
```

### 2.2. Create Isolated Drizzle Directory

Keep Drizzle separate from existing code:
```bash
mkdir -p src/drizzle
```

Structure:
```
src/drizzle/
├── index.ts      # Connection
├── schema.ts     # New schemas only
└── migrations/   # Drizzle migrations
```

## Phase 3: Configuration

### 3.1. Create Drizzle Config

Create `drizzle.config.ts` with explicit environment loading:

**CRITICAL:** The `config({ path: '...' })` must match your environment file name.

**For Next.js (using .env.local):**
```typescript
import { defineConfig } from 'drizzle-kit';
import { config } from 'dotenv';

// Load .env.local explicitly
config({ path: '.env.local' });

export default defineConfig({
  schema: './src/drizzle/schema.ts',
  out: './src/drizzle/migrations',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});
```

**For other projects (using .env):**
```typescript
import { defineConfig } from 'drizzle-kit';
import { config } from 'dotenv';

// Load .env explicitly
config({ path: '.env' });

export default defineConfig({
  schema: './src/drizzle/schema.ts',
  out: './src/drizzle/migrations',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});
```

**Notes:**
- Point schema and migrations to `src/drizzle/` to avoid conflicts with existing code
- Explicit dotenv path prevents "url: undefined" errors during migrations

### 3.2. Create Connection

`src/drizzle/index.ts` - Choose adapter based on environment (see `references/adapters.md`):

**HTTP (Vercel/Edge):**
```typescript
import { drizzle } from 'drizzle-orm/neon-http';
import { neon } from '@neondatabase/serverless';

const sql = neon(process.env.DATABASE_URL!);
export const drizzleDb = drizzle(sql);
```

**WebSocket (Node.js):**
```typescript
import { drizzle } from 'drizzle-orm/neon-serverless';
import { Pool, neonConfig } from '@neondatabase/serverless';
import ws from 'ws';

neonConfig.webSocketConstructor = ws;
const pool = new Pool({ connectionString: process.env.DATABASE_URL! });
export const drizzleDb = drizzle(pool);
```

**Important:** Name export as `drizzleDb` to avoid conflicts with existing `db` exports.

## Phase 4: Schema Strategy

Choose integration approach:

### 4.1. Option A: New Tables Only

Create schemas for new features only, leave existing tables alone:

`src/drizzle/schema.ts`:
```typescript
import { pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';

export const newFeatureTable = pgTable('new_feature', {
  id: serial('id').primaryKey(),
  data: text('data').notNull(),
  createdAt: timestamp('created_at').defaultNow(),
});
```

**Pros:**
- No migration of existing data
- Zero risk to current functionality
- Gradual adoption

**Cons:**
- Mixed query patterns (Drizzle + existing ORM)
- Two connection patterns in codebase

### 4.2. Option B: Mirror Existing Tables

Define schemas for existing tables to gradually migrate queries:

```typescript
import { pgTable, serial, varchar, timestamp } from 'drizzle-orm/pg-core';

export const existingUsers = pgTable('users', {
  id: serial('id').primaryKey(),
  email: varchar('email', { length: 255 }).notNull(),
  name: varchar('name', { length: 255 }),
  createdAt: timestamp('created_at'),
});
```

**Pros:**
- Can query existing data with Drizzle
- Gradually replace old ORM queries
- Type-safe access to existing tables

**Cons:**
- Must match existing schema exactly
- Requires careful migration strategy

### 4.3. Recommended: Hybrid Approach

1. Start with Option A (new tables only)
2. Once comfortable, add schemas for frequently-queried existing tables (Option B)
3. Gradually migrate queries from old ORM to Drizzle
4. Eventually remove old ORM

## Phase 5: Migration Handling

### 5.1. For New Tables

Generate and run migrations normally:
```bash
[package-manager] drizzle-kit generate
export DATABASE_URL="$(grep DATABASE_URL .env.local | cut -d '=' -f2)" && \
[package-manager] drizzle-kit migrate
```

### 5.2. For Existing Tables

**Do NOT run migrations** - tables already exist!

Instead, use Drizzle schemas for querying only:
```typescript
import { drizzleDb } from './drizzle';
import { existingUsers } from './drizzle/schema';

const users = await drizzleDb.select().from(existingUsers);
```

### 5.3. Mixed Scenario

If you have both new and existing tables:
1. Define all schemas in `schema.ts`
2. Run `drizzle-kit generate`
3. **Manually edit** generated migration to remove SQL for existing tables
4. Apply migration

See `references/migrations.md` for advanced patterns.

### 5.4. Add Migration Scripts

Add these convenience scripts to your `package.json`:

```json
{
  "scripts": {
    "db:generate": "drizzle-kit generate",
    "db:migrate": "drizzle-kit migrate",
    "db:push": "drizzle-kit push",
    "db:studio": "drizzle-kit studio"
  }
}
```

**Usage:**
```bash
npm run db:generate  # Generate migrations from schema changes
npm run db:migrate   # Apply pending migrations
npm run db:push      # Push schema directly (dev only)
npm run db:studio    # Open Drizzle Studio
```

**Note:** Replace `npm run` with your package manager's equivalent (`pnpm`, `yarn`, `bun`).

## Phase 6: Coexistence Patterns

### 6.1. Naming Conventions

Keep clear separation:
```typescript
import { db as prismaDb } from './lib/prisma';
import { drizzleDb } from './drizzle';

const prismaUsers = await prismaDb.user.findMany();
const drizzleFeatures = await drizzleDb.select().from(newFeatureTable);
```

### 6.2. Gradual Migration

**Step 1:** New features use Drizzle
```typescript
async function createFeature(data: NewFeatureInput) {
  return drizzleDb.insert(newFeatureTable).values(data).returning();
}
```

**Step 2:** Migrate read queries (safe, no data changes)
```typescript
async function getUsers() {
  return drizzleDb.select().from(existingUsers);
}
```

**Step 3:** Migrate write queries (after thorough testing)
```typescript
async function updateUser(id: number, data: UserUpdate) {
  return drizzleDb.update(existingUsers)
    .set(data)
    .where(eq(existingUsers.id, id));
}
```

**Step 4:** Remove old ORM once all queries migrated

## Phase 7: Verification

Test integration without breaking existing functionality:

### 7.1. Test New Tables

```typescript
import { drizzleDb } from './drizzle';
import { newFeatureTable } from './drizzle/schema';

const result = await drizzleDb.insert(newFeatureTable)
  .values({ data: 'test' })
  .returning();

console.log('New table works:', result);
```

### 7.2. Test Existing Tables (if mirrored)

```typescript
import { drizzleDb } from './drizzle';
import { existingUsers } from './drizzle/schema';

const users = await drizzleDb.select().from(existingUsers);
console.log('Existing table accessible:', users);
```

### 7.3. Verify Old ORM Still Works

```typescript
import { db as oldDb } from './lib/your-orm';

const oldQuery = await oldDb.users.findMany();
console.log('Old ORM still works:', oldQuery);
```

## Phase 8: Add Best Practices References

Before executing the add-neon-docs skill, provide a summary of everything that has been done:

"✅ ... Drizzle integration is complete! Now adding documentation references..."

Then execute the neon-plugin:add-neon-docs skill with the parameter SKILL_NAME="neon-drizzle"

This will add reference links to Neon + Drizzle best practices documentation in your project's AI documentation file, helping AI assistants provide better guidance in future conversations.

---

## ✅ Integration Complete!

Your Drizzle integration with the existing project is ready to use.



============================================================
END FILE: .fleet/skills/neon-db/neon-drizzle/guides/existing-project.md
============================================================

============================================================
FILE: .fleet/skills/neon-db/neon-drizzle/guides/new-project.md
============================================================

# New Project Setup

> **Complete Walkthrough**: This is a self-contained, step-by-step guide with its own numbered phases (Phase 1-6).
> Follow each phase in order for a full Drizzle + Neon setup from scratch.

Complete guide for setting up Drizzle ORM with Neon from scratch.

> **Note on Placeholders**: Throughout this guide, `[package-manager]` is used as a placeholder. Replace it with your package manager command: `npm`, `pnpm`, `yarn`, or `bun`.

### Important:
- Remember to run the neon-plugin:add-neon-docs skill with the parameter SKILL_NAME="neon-drizzle" after completing the guide.

## Table of Contents

- [New Project Setup](#new-project-setup)
    - [Important:](#important)
  - [Table of Contents](#table-of-contents)
  - [Workflow Checklist](#workflow-checklist)
  - [Phase 1: Context Detection](#phase-1-context-detection)
  - [Phase 2: Installation](#phase-2-installation)
  - [Phase 3: Configuration](#phase-3-configuration)
    - [3.1. Neon Database Provisioning \& Environment File](#31-neon-database-provisioning--environment-file)
    - [3.2. Drizzle Config](#32-drizzle-config)
    - [3.3. Database Connection](#33-database-connection)
  - [Phase 4: Schema Generation](#phase-4-schema-generation)
    - [4.1. Common Patterns](#41-common-patterns)
  - [Phase 5: Migrations](#phase-5-migrations)
    - [5.1. Generate Migration](#51-generate-migration)
    - [5.2. Apply Migration](#52-apply-migration)
    - [5.3. Add Migration Scripts](#53-add-migration-scripts)
    - [5.4. If Migration Fails](#54-if-migration-fails)
  - [Phase 6: Add Best Practices References](#phase-6-add-best-practices-references)
  - [✅ Setup Complete!](#-setup-complete)

---

## Workflow Checklist

When following this guide, I will track these high-level tasks:

- [ ] Detect project context (package manager, framework, existing setup)
- [ ] Install Drizzle dependencies based on deployment target
- [ ] Provision Neon database (list projects, create if needed, get connection string)
- [ ] Write connection string to environment file and verify
- [ ] Create Drizzle configuration files (drizzle.config.ts, db connection)
- [ ] Generate schema based on app type
- [ ] Run and verify migrations
- [ ] Add Neon Drizzle best practices to project docs

---

## Phase 1: Context Detection

Auto-detect project context:

**Check Package Manager:**
```bash
ls package-lock.json  # → npm
ls bun.lockb          # → bun
ls pnpm-lock.yaml     # → pnpm
ls yarn.lock          # → yarn
```

**Check Framework:**
```bash
grep '"next"' package.json      # → Next.js
grep '"express"' package.json   # → Express
grep '"vite"' package.json      # → Vite
```

**Check Existing Setup:**
```bash
ls drizzle.config.ts   # Already configured?
ls src/db/schema.ts    # Schema exists?
```

**Check Environment Files:**
```bash
ls .env .env.local .env.production
```

## Phase 2: Installation

Based on detection, install dependencies:

**For Vercel/Edge Environments (Next.js, Vite on Vercel):**
```bash
[package-manager] add drizzle-orm @neondatabase/serverless
[package-manager] add -D drizzle-kit dotenv @vercel/node
```

**For Node.js Servers (Express, Fastify, standard Node):**
```bash
[package-manager] add drizzle-orm @neondatabase/serverless ws
[package-manager] add -D drizzle-kit dotenv @types/ws
```

## Phase 3: Configuration

Create configuration files in dependency order:

### 3.1. Neon Database Provisioning & Environment File

**Outcome**: A working `.env` or `.env.local` file with a real Neon connection string that the application can use immediately.

Use MCP tools to list or create a Neon project and get its connection string. Write the actual credentials to the environment file (`.env.local` for Next.js, `.env` for other projects). Add the file to `.gitignore`.

**Environment file format:**
```bash
DATABASE_URL=postgresql://user:password@host/database?sslmode=require
```

### 3.2. Drizzle Config

Create `drizzle.config.ts` with explicit environment loading:

**CRITICAL:** The `config({ path: '...' })` line must match the environment file from Step 3.1.

**For Next.js (using .env.local):**
```typescript
import { defineConfig } from 'drizzle-kit';
import { config } from 'dotenv';

// Load .env.local explicitly
config({ path: '.env.local' });

export default defineConfig({
  schema: './src/db/schema.ts',
  out: './src/db/migrations',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});
```

**For other projects (using .env):**
```typescript
import { defineConfig } from 'drizzle-kit';
import { config } from 'dotenv';

// Load .env explicitly
config({ path: '.env' });

export default defineConfig({
  schema: './src/db/schema.ts',
  out: './src/db/migrations',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});
```

**Why this matters:**
- Without explicit `config({ path: '...' })`, drizzle-kit may not load environment variables
- This prevents "url: undefined" errors during migrations
- The path must match your environment file name from Phase 3.1

### 3.3. Database Connection

Create `src/db/index.ts` with appropriate adapter (see `references/adapters.md` for decision guide):

**For Vercel/Edge:**
```typescript
import { drizzle } from 'drizzle-orm/neon-http';
import { neon } from '@neondatabase/serverless';

const sql = neon(process.env.DATABASE_URL!);
export const db = drizzle(sql);
```

**For Node.js:**
```typescript
import { drizzle } from 'drizzle-orm/neon-serverless';
import { Pool, neonConfig } from '@neondatabase/serverless';
import ws from 'ws';

neonConfig.webSocketConstructor = ws;
const pool = new Pool({ connectionString: process.env.DATABASE_URL! });
export const db = drizzle(pool);
```

See `templates/db-http.ts` and `templates/db-websocket.ts` for complete examples.

## Phase 4: Schema Generation

Based on app type, create appropriate schema:

### 4.1. Common Patterns

**Todo App:**
```typescript
import { pgTable, serial, text, boolean, timestamp, varchar } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  email: varchar('email', { length: 255 }).notNull().unique(),
  name: varchar('name', { length: 255 }).notNull(),
  createdAt: timestamp('created_at').defaultNow(),
});

export const todos = pgTable('todos', {
  id: serial('id').primaryKey(),
  userId: serial('user_id').notNull().references(() => users.id),
  title: text('title').notNull(),
  completed: boolean('completed').default(false),
  createdAt: timestamp('created_at').defaultNow(),
});
```

**Blog App:**
```typescript
import { pgTable, serial, text, timestamp, varchar, index } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  email: varchar('email', { length: 255 }).notNull().unique(),
  name: varchar('name', { length: 255 }).notNull(),
  createdAt: timestamp('created_at').defaultNow(),
});

export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  userId: serial('user_id').notNull().references(() => users.id),
  title: text('title').notNull(),
  content: text('content').notNull(),
  createdAt: timestamp('created_at').defaultNow(),
}, (table) => ({
  userIdIdx: index('posts_user_id_idx').on(table.userId),
}));

export const usersRelations = relations(users, ({ many }) => ({
  posts: many(posts),
}));

export const postsRelations = relations(posts, ({ one }) => ({
  author: one(users, {
    fields: [posts.userId],
    references: [users.id],
  }),
}));
```

See `templates/schema-example.ts` for more complex examples.

## Phase 5: Migrations

Run migrations with proper error handling:

### 5.1. Generate Migration

```bash
[package-manager] drizzle-kit generate
```

This creates SQL files in `src/db/migrations/`.

### 5.2. Apply Migration

**Recommended approach (explicit env loading):**
```bash
export DATABASE_URL="$(grep DATABASE_URL .env.local | cut -d '=' -f2)" && \
[package-manager] drizzle-kit migrate
```

**Why this works:** Ensures `DATABASE_URL` is available, preventing "url: undefined" errors.

### 5.3. Add Migration Scripts

Add these convenience scripts to your `package.json`:

```json
{
  "scripts": {
    "db:generate": "drizzle-kit generate",
    "db:migrate": "drizzle-kit migrate",
    "db:push": "drizzle-kit push",
    "db:studio": "drizzle-kit studio"
  }
}
```

**Usage:**
```bash
npm run db:generate  # Generate migrations from schema changes
npm run db:migrate   # Apply pending migrations
npm run db:push      # Push schema directly (dev only)
npm run db:studio    # Open Drizzle Studio
```

**Note:** Replace `npm run` with your package manager's equivalent (`pnpm`, `yarn`, `bun`).

### 5.4. If Migration Fails

See `guides/troubleshooting.md` for common issues and fixes.

Also reference `references/migrations.md` for deep dive on migration patterns.

## Phase 6: Add Best Practices References

Before executing the add-neon-docs skill, provide a summary of everything that has been done:

"✅ ... Drizzle integration is complete! Now adding documentation references..."

Then execute the neon-plugin:add-neon-docs skill with the parameter SKILL_NAME="neon-drizzle"

This will add reference links to Neon + Drizzle best practices documentation in your project's AI documentation file, helping AI assistants provide better guidance in future conversations.

## ✅ Setup Complete!

Your Drizzle + Neon integration is ready to use.



============================================================
END FILE: .fleet/skills/neon-db/neon-drizzle/guides/new-project.md
============================================================

============================================================
FILE: .fleet/skills/neon-db/neon-drizzle/guides/schema-only.md
============================================================

# Schema Creation and Modification

> **Complete Walkthrough**: This is a self-contained, step-by-step guide with its own numbered phases (Phase 1-6).
> Follow each phase in order for schema design, modification, and migration workflows.

Guide for creating or modifying database schemas with Drizzle.

## Table of Contents

- [Workflow Checklist](#workflow-checklist)
- [Phase 1: Schema Design Patterns](#phase-1-schema-design-patterns)
- [Phase 2: Common Schema Patterns](#phase-2-common-schema-patterns)
- [Phase 3: Schema Modifications](#phase-3-schema-modifications)
- [Phase 4: Indexes and Constraints](#phase-4-indexes-and-constraints)
- [Phase 5: Generate and Apply Changes](#phase-5-generate-and-apply-changes)
- [Phase 6: Advanced Patterns](#phase-6-advanced-patterns)
- [Common Issues](#common-issues)
- [Next Steps](#next-steps)

---

## Workflow Checklist

When following this guide, I will track these high-level tasks:

- [ ] Design schema using appropriate patterns (tables, relationships, types)
- [ ] Apply common schema patterns (auth, soft deletes, enums, JSON)
- [ ] Implement schema modifications (add/rename/drop columns, change types)
- [ ] Add indexes and constraints for performance and data integrity
- [ ] Generate and apply migrations
- [ ] Verify changes and test with queries

---

## Phase 1: Schema Design Patterns

### 1.1. Basic Table Structure

```typescript
import { pgTable, serial, text, varchar, timestamp, boolean } from 'drizzle-orm/pg-core';

export const tableName = pgTable('table_name', {
  id: serial('id').primaryKey(),
  name: varchar('name', { length: 255 }).notNull(),
  description: text('description'),
  isActive: boolean('is_active').default(true),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});
```

**Key conventions:**
- Use `serial` for auto-incrementing IDs
- Use `varchar` for short strings (with length limit)
- Use `text` for long strings
- Use `timestamp` for dates/times
- Always add `createdAt` for audit trails

### 1.2. Relationships

**One-to-Many:**
```typescript
import { pgTable, serial, text, timestamp, index } from 'drizzle-orm/pg-core';

export const authors = pgTable('authors', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
});

export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  authorId: serial('author_id')
    .notNull()
    .references(() => authors.id),
  title: text('title').notNull(),
  content: text('content').notNull(),
}, (table) => ({
  authorIdIdx: index('posts_author_id_idx').on(table.authorId),
}));
```

**Important:** Always add index on foreign keys for query performance.

**Many-to-Many:**
```typescript
export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  title: text('title').notNull(),
});

export const tags = pgTable('tags', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
});

export const postsTags = pgTable('posts_tags', {
  postId: serial('post_id')
    .notNull()
    .references(() => posts.id),
  tagId: serial('tag_id')
    .notNull()
    .references(() => tags.id),
}, (table) => ({
  pk: index('posts_tags_pk').on(table.postId, table.tagId),
}));
```

### 1.3. Type-Safe Relations

Enable relational queries:
```typescript
import { relations } from 'drizzle-orm';

export const authorsRelations = relations(authors, ({ many }) => ({
  posts: many(posts),
}));

export const postsRelations = relations(posts, ({ one }) => ({
  author: one(authors, {
    fields: [posts.authorId],
    references: [authors.id],
  }),
}));
```

**Benefits:**
- Type-safe joins
- Automatic loading of related data
- No manual JOIN queries needed

## Phase 2: Common Schema Patterns

### 2.1. User Authentication

```typescript
import { pgTable, serial, varchar, timestamp, boolean } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  email: varchar('email', { length: 255 }).notNull().unique(),
  passwordHash: varchar('password_hash', { length: 255 }),
  name: varchar('name', { length: 255 }).notNull(),
  emailVerified: boolean('email_verified').default(false),
  createdAt: timestamp('created_at').defaultNow(),
  lastLoginAt: timestamp('last_login_at'),
});
```

### 2.2. Soft Deletes

```typescript
export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  title: text('title').notNull(),
  content: text('content').notNull(),
  deletedAt: timestamp('deleted_at'),
  createdAt: timestamp('created_at').defaultNow(),
});
```

Query with soft deletes:
```typescript
const activePosts = await db
  .select()
  .from(posts)
  .where(isNull(posts.deletedAt));
```

### 2.3. Enums

```typescript
import { pgEnum, pgTable, serial, text } from 'drizzle-orm/pg-core';

export const statusEnum = pgEnum('status', ['draft', 'published', 'archived']);

export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  title: text('title').notNull(),
  status: statusEnum('status').default('draft'),
});
```

### 2.4. JSON Fields

```typescript
import { pgTable, serial, jsonb } from 'drizzle-orm/pg-core';

export const products = pgTable('products', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  metadata: jsonb('metadata').$type<{
    color?: string;
    size?: string;
    tags?: string[];
  }>(),
});
```

## Phase 3: Schema Modifications

### 3.1. Adding Columns

**Step 1:** Update schema:
```typescript
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  email: varchar('email', { length: 255 }).notNull(),
  phoneNumber: varchar('phone_number', { length: 20 }), // NEW
});
```

**Step 2:** Generate migration:
```bash
[package-manager] drizzle-kit generate
```

**Step 3:** Apply migration:
```bash
export DATABASE_URL="$(grep DATABASE_URL .env.local | cut -d '=' -f2)" && \
[package-manager] drizzle-kit migrate
```

### 3.2. Renaming Columns

**Important:** Drizzle sees renames as drop + add. Manual migration required.

**Step 1:** Update schema:
```typescript
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  fullName: varchar('full_name', { length: 255 }), // was 'name'
});
```

**Step 2:** Generate migration (will create drop + add):
```bash
[package-manager] drizzle-kit generate
```

**Step 3:** Edit migration file manually:
```sql
-- Change from:
-- ALTER TABLE users DROP COLUMN name;
-- ALTER TABLE users ADD COLUMN full_name VARCHAR(255);

-- To:
ALTER TABLE users RENAME COLUMN name TO full_name;
```

**Step 4:** Apply migration:
```bash
[package-manager] drizzle-kit migrate
```

### 3.3. Dropping Columns

**Step 1:** Remove from schema:
```typescript
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  email: varchar('email', { length: 255 }).notNull(),
  // removed: phoneNumber
});
```

**Step 2:** Generate and apply:
```bash
[package-manager] drizzle-kit generate
[package-manager] drizzle-kit migrate
```

**Warning:** This permanently deletes data. Back up first!

### 3.4. Changing Column Types

**Step 1:** Update schema:
```typescript
export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  views: bigint('views', { mode: 'number' }), // was: integer
});
```

**Step 2:** Generate migration:
```bash
[package-manager] drizzle-kit generate
```

**Step 3:** Review generated SQL - may need data migration if incompatible types.

## Phase 4: Indexes and Constraints

### 4.1. Add Indexes

**Single column:**
```typescript
import { pgTable, serial, text, index } from 'drizzle-orm/pg-core';

export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  title: text('title').notNull(),
  authorId: serial('author_id').notNull(),
}, (table) => ({
  titleIdx: index('posts_title_idx').on(table.title),
  authorIdIdx: index('posts_author_id_idx').on(table.authorId),
}));
```

**Composite index:**
```typescript
export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  authorId: serial('author_id').notNull(),
  status: text('status').notNull(),
}, (table) => ({
  authorStatusIdx: index('posts_author_status_idx').on(table.authorId, table.status),
}));
```

### 4.2. Unique Constraints

**Single column:**
```typescript
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  email: varchar('email', { length: 255 }).notNull().unique(),
});
```

**Multiple columns:**
```typescript
import { pgTable, serial, text, unique } from 'drizzle-orm/pg-core';

export const postsTags = pgTable('posts_tags', {
  postId: serial('post_id').notNull(),
  tagId: serial('tag_id').notNull(),
}, (table) => ({
  unq: unique('posts_tags_unique').on(table.postId, table.tagId),
}));
```

### 4.3. Check Constraints

```typescript
import { pgTable, serial, integer, check } from 'drizzle-orm/pg-core';

export const products = pgTable('products', {
  id: serial('id').primaryKey(),
  price: integer('price').notNull(),
  discountedPrice: integer('discounted_price'),
}, (table) => ({
  priceCheck: check('price_check', 'price >= 0'),
  discountCheck: check('discount_check', 'discounted_price < price'),
}));
```

## Phase 5: Generate and Apply Changes

### 5.1. Generate Migration

After any schema changes:
```bash
[package-manager] drizzle-kit generate
```

Review generated SQL in `src/db/migrations/`.

### 5.2. Apply Migration

With proper environment loading:
```bash
export DATABASE_URL="$(grep DATABASE_URL .env.local | cut -d '=' -f2)" && \
[package-manager] drizzle-kit migrate
```

Or use the migration script:
```bash
[package-manager] tsx scripts/run-migration.ts
```

### 5.3. Verify Changes

**Check in database:**
```bash
psql $DATABASE_URL -c "\d table_name"
```

**Test with queries:**
```typescript
import { db } from './src/db';
import { tableName } from './src/db/schema';

const result = await db.select().from(tableName);
console.log('Schema works:', result);
```

## Phase 6: Advanced Patterns

For complex schemas, see:
- `templates/schema-example.ts` - Multi-table examples with relations
- `references/migrations.md` - Advanced migration patterns

## Common Issues

- **Migration conflicts:** See `guides/troubleshooting.md`
- **Relationship errors:** Ensure foreign keys reference correct columns
- **Type mismatches:** Match TypeScript types with SQL types carefully

## Next Steps

After schema creation:
1. Run migrations (see above)
2. Create queries (see `references/query-patterns.md`)
3. Add validation (use Zod or similar)
4. Test thoroughly before production


============================================================
END FILE: .fleet/skills/neon-db/neon-drizzle/guides/schema-only.md
============================================================

============================================================
FILE: .fleet/skills/neon-db/neon-drizzle/guides/troubleshooting.md
============================================================

# Troubleshooting Guide

> **Reference Guide**: This is organized by error type and solution, not sequential phases.
> Jump directly to the error you're experiencing for quick resolution.

Common issues and solutions for Drizzle ORM with Neon.

## Table of Contents

- [Migration Errors](#migration-errors)
- [Connection Errors](#connection-errors)
- [Adapter Issues](#adapter-issues)
- [Type Errors](#type-errors)
- [Query Errors](#query-errors)
- [Performance Issues](#performance-issues)
- [Environment Issues](#environment-issues)
- [Getting More Help](#getting-more-help)
- [Prevention Checklist](#prevention-checklist)

---

## Migration Errors

### Error: "url: undefined"

**Symptom:**
```
Error: url is undefined in dbCredentials
```

**Cause:** Environment variables not loaded during migration.

**Solutions:**

**Option 1: Explicit env loading**
```bash
export DATABASE_URL="$(grep DATABASE_URL .env.local | cut -d '=' -f2)" && \
[package-manager] drizzle-kit migrate
```

**Option 2: Update drizzle.config.ts**
```typescript
import { defineConfig } from 'drizzle-kit';
import { config } from 'dotenv';

config({ path: '.env.local' });

export default defineConfig({
  schema: './src/db/schema.ts',
  out: './src/db/migrations',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});
```

**Option 3: Use programmatic migration**
```typescript
import { migrate } from 'drizzle-orm/neon-http/migrator';
import { db } from './src/db';
import { config } from 'dotenv';

config({ path: '.env.local' });

await migrate(db, { migrationsFolder: './src/db/migrations' });
```

### Error: "Cannot find migrations folder"

**Symptom:**
```
Error: ENOENT: no such file or directory, scandir './src/db/migrations'
```

**Cause:** Migrations folder doesn't exist yet.

**Solution:**
```bash
mkdir -p src/db/migrations
[package-manager] drizzle-kit generate
```

### Error: "Column already exists"

**Symptom:**
```
Error: column "name" of relation "users" already exists
```

**Cause:** Trying to add a column that already exists in the database.

**Solutions:**

**Option 1: Skip migration (dev only)**
```bash
rm src/db/migrations/[latest-migration-file].sql
[package-manager] drizzle-kit generate
```

**Option 2: Drop and recreate table (dev only, DATA LOSS)**
```bash
psql $DATABASE_URL -c "DROP TABLE users CASCADE;"
[package-manager] drizzle-kit migrate
```

**Option 3: Manual migration (production)**
Edit the migration file to check if column exists:
```sql
ALTER TABLE users
  ADD COLUMN IF NOT EXISTS name VARCHAR(255);
```

### Error: "Migration already applied"

**Symptom:**
```
Error: migration has already been applied
```

**Cause:** Drizzle tracks applied migrations. Trying to reapply.

**Solution:**

Check migration journal:
```bash
cat src/db/migrations/meta/_journal.json
```

Remove duplicate entry or regenerate:
```bash
rm -rf src/db/migrations
mkdir src/db/migrations
[package-manager] drizzle-kit generate
```

**Warning:** Only do this in development!

## Connection Errors

### Error: "Connection refused"

**Symptom:**
```
Error: connect ECONNREFUSED
```

**Causes and Solutions:**

**1. Wrong DATABASE_URL format**

Check format:
```bash
echo $DATABASE_URL
```

Should be:
```
postgresql://user:password@host.neon.tech/dbname?sslmode=require
```

**2. Missing sslmode**

Add to DATABASE_URL:
```
?sslmode=require
```

**3. Firewall/network issue**

Test connectivity:
```bash
psql $DATABASE_URL -c "SELECT 1"
```

### Error: "WebSocket connection failed"

**Symptom:**
```
Error: WebSocket connection to 'wss://...' failed
```

**Cause:** Missing WebSocket constructor in Node.js.

**Solution:**

Add to your connection file:
```typescript
import { neonConfig } from '@neondatabase/serverless';
import ws from 'ws';

neonConfig.webSocketConstructor = ws;
```

Install ws if missing:
```bash
[package-manager] add ws
[package-manager] add -D @types/ws
```

### Error: "Too many connections"

**Symptom:**
```
Error: sorry, too many clients already
```

**Cause:** Connection pool exhausted.

**Solutions:**

**For HTTP adapter:** This shouldn't happen (stateless).

**For WebSocket adapter:** Implement connection pooling:
```typescript
import { Pool } from '@neondatabase/serverless';

const pool = new Pool({
  connectionString: process.env.DATABASE_URL!,
  max: 10, // Limit connections
});

export const db = drizzle(pool);
```

**Close connections properly:**
```typescript
process.on('SIGTERM', async () => {
  await pool.end();
  process.exit(0);
});
```

## Adapter Issues

### Wrong Adapter for Environment

**Symptom:** App works locally but fails in production (or vice versa).

**Cause:** Using wrong adapter for environment.

**Solutions:**

See `references/adapters.md` for decision guide.

**Quick reference:**
- Vercel/Cloudflare/Edge → HTTP adapter
- Node.js/Express/Long-lived → WebSocket adapter

**HTTP adapter:**
```typescript
import { drizzle } from 'drizzle-orm/neon-http';
import { neon } from '@neondatabase/serverless';

const sql = neon(process.env.DATABASE_URL!);
export const db = drizzle(sql);
```

**WebSocket adapter:**
```typescript
import { drizzle } from 'drizzle-orm/neon-serverless';
import { Pool, neonConfig } from '@neondatabase/serverless';
import ws from 'ws';

neonConfig.webSocketConstructor = ws;
const pool = new Pool({ connectionString: process.env.DATABASE_URL! });
export const db = drizzle(pool);
```

## Type Errors

### Error: "Type 'number' is not assignable to type 'string'"

**Symptom:**
```typescript
const user = await db.insert(users).values({
  id: 1, // Error here
  email: 'test@example.com',
});
```

**Cause:** Trying to manually set auto-increment ID.

**Solution:**

Remove `id` from insert (it's auto-generated):
```typescript
const user = await db.insert(users).values({
  email: 'test@example.com',
});
```

### Error: "Property 'xyz' does not exist"

**Symptom:**
```typescript
const user = await db.select().from(users);
console.log(user[0].nonExistentField); // Error
```

**Cause:** Column not defined in schema.

**Solution:**

Add column to schema:
```typescript
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  nonExistentField: text('non_existent_field'),
});
```

Then regenerate and apply migration.

## Query Errors

### Error: "relation does not exist"

**Symptom:**
```
Error: relation "users" does not exist
```

**Cause:** Table not created in database yet.

**Solution:**

Run migrations:
```bash
[package-manager] drizzle-kit generate
export DATABASE_URL="$(grep DATABASE_URL .env.local | cut -d '=' -f2)" && \
[package-manager] drizzle-kit migrate
```

### Error: "column does not exist"

**Symptom:**
```
Error: column "email" does not exist
```

**Causes:**

**1. Schema out of sync with database**

Regenerate and apply migrations:
```bash
[package-manager] drizzle-kit generate
[package-manager] drizzle-kit migrate
```

**2. Wrong table name in query**

Check schema definition vs query.

**3. Case sensitivity**

PostgreSQL is case-sensitive. Ensure column names match exactly.

### Error: "Cannot perform transactions with HTTP adapter"

**Symptom:**
```typescript
await db.transaction(async (tx) => {
  // Error: transactions not supported
});
```

**Cause:** HTTP adapter doesn't support transactions.

**Solutions:**

**Option 1: Switch to WebSocket adapter** (if environment allows)

See `references/adapters.md`.

**Option 2: Use batch operations**
```typescript
await db.batch([
  db.insert(users).values({ email: 'test1@example.com' }),
  db.insert(posts).values({ title: 'Test' }),
]);
```

**Option 3: Implement application-level rollback**

Not ideal, but possible for simple cases.

## Performance Issues

### Slow Queries

**Symptoms:** Queries taking seconds instead of milliseconds.

**Diagnose:**

**1. Missing indexes**

Check if foreign keys have indexes:
```typescript
export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  authorId: serial('author_id').notNull(),
}, (table) => ({
  authorIdIdx: index('posts_author_id_idx').on(table.authorId), // ADD THIS
}));
```

**2. N+1 queries**

Use relations instead of multiple queries:
```typescript
const postsWithAuthors = await db.query.posts.findMany({
  with: {
    author: true,
  },
});
```

**3. Selecting too much data**

Select only needed columns:
```typescript
const users = await db.select({
  id: users.id,
  email: users.email,
}).from(users);
```

### Connection Timeout

**Symptom:** Queries timeout in production.

**Solutions:**

**1. For Vercel:** Ensure using HTTP adapter (see `references/adapters.md`)

**2. For Node.js:** Implement connection pooling with retry:
```typescript
import { Pool } from '@neondatabase/serverless';

const pool = new Pool({
  connectionString: process.env.DATABASE_URL!,
  max: 10,
  connectionTimeoutMillis: 5000,
  idleTimeoutMillis: 30000,
});
```

**3. Add query timeout:**
```typescript
const result = await Promise.race([
  db.select().from(users),
  new Promise((_, reject) =>
    setTimeout(() => reject(new Error('Query timeout')), 5000)
  ),
]);
```

## Environment Issues

### Error: "DATABASE_URL is undefined"

**Symptom:** App can't find DATABASE_URL.

**Solutions:**

**1. Check env file exists:**
```bash
ls .env .env.local
```

**2. Verify var is set:**
```bash
grep DATABASE_URL .env.local
```

**3. Load env vars:**
```typescript
import { config } from 'dotenv';
config({ path: '.env.local' });
```

**4. For Next.js:** Use `NEXT_PUBLIC_` prefix if accessing client-side (NOT recommended for DATABASE_URL):
```
# Don't do this - security risk
NEXT_PUBLIC_DATABASE_URL="..."

# Do this - server-only
DATABASE_URL="..."
```

### Error: "Invalid connection string"

**Symptom:**
```
Error: invalid connection string
```

**Cause:** Malformed DATABASE_URL.

**Check format:**
```
postgresql://USER:PASSWORD@HOST:PORT/DATABASE?sslmode=require
```

**Common mistakes:**
- Missing `postgresql://` prefix
- Special characters in password not URL-encoded
- Missing `?sslmode=require`

**Fix special characters:**
```bash
# If password is "p@ss&word!"
# Encode to: p%40ss%26word%21
```

## Getting More Help

If your issue isn't listed here:

1. **Check adapter configuration:** `references/adapters.md`
2. **Review migration patterns:** `references/migrations.md`
3. **Check query syntax:** `references/query-patterns.md`
4. **Search Drizzle docs:** https://orm.drizzle.team/docs
5. **Check Neon docs:** https://neon.com/docs

## Prevention Checklist

Before deploying:

- [ ] Environment variables properly loaded
- [ ] Correct adapter for environment
- [ ] Migrations applied successfully
- [ ] Indexes on foreign keys
- [ ] Connection pooling configured (if Node.js)
- [ ] Error handling for database operations
- [ ] .env files in .gitignore
- [ ] Test queries work in production environment


============================================================
END FILE: .fleet/skills/neon-db/neon-drizzle/guides/troubleshooting.md
============================================================

============================================================
FILE: .fleet/skills/neon-db/neon-drizzle/references/adapters.md
============================================================

# Adapter Reference Guide

Complete guide for choosing between HTTP and WebSocket adapters.

## Table of Contents

- [Quick Decision Matrix](#quick-decision-matrix)
- [HTTP Adapter](#http-adapter-neondatabaseserverless-with-neon-http)
- [WebSocket Adapter](#websocket-adapter-neondatabaseserverless-with-neon-serverless)
- [Framework-Specific Recommendations](#framework-specific-recommendations)
- [Mixed Environments](#mixed-environments)
- [Feature Comparison Table](#feature-comparison-table)
- [Performance Considerations](#performance-considerations)
- [Troubleshooting](#troubleshooting)
- [Migration Between Adapters](#migration-between-adapters)
- [Choosing the Right Adapter](#choosing-the-right-adapter)
- [Related Resources](#related-resources)

---

## Quick Decision Matrix

| Environment | Adapter | Reason |
|-------------|---------|--------|
| Vercel | HTTP | Edge functions, stateless |
| Cloudflare Workers | HTTP | Edge runtime, no WebSocket |
| AWS Lambda | HTTP | Stateless, cold starts |
| Next.js (Vercel) | HTTP | App Router, Edge Runtime |
| Express/Fastify | WebSocket | Long-lived connections |
| Node.js server | WebSocket | Connection pooling |
| Bun server | WebSocket | Persistent runtime |

## HTTP Adapter (@neondatabase/serverless with neon-http)

### When to Use

✅ **Serverless/Edge environments:**
- Vercel Edge Functions
- Cloudflare Workers
- AWS Lambda
- Deno Deploy
- Next.js App Router (default)

✅ **Characteristics:**
- Stateless requests
- Cold starts
- Short execution time
- No persistent connections

### Setup

**Installation:**
```bash
npm add drizzle-orm @neondatabase/serverless
npm add -D drizzle-kit
```

**Connection:**
```typescript
import { drizzle } from 'drizzle-orm/neon-http';
import { neon } from '@neondatabase/serverless';

const sql = neon(process.env.DATABASE_URL!);
export const db = drizzle(sql);
```

**Complete example:** See `templates/db-http.ts`

### Pros

✅ **Perfect for serverless:**
- No connection management needed
- Works in edge environments
- Fast cold starts
- Auto-scales

✅ **Simple:**
- Minimal configuration
- No connection pooling complexity
- Stateless = predictable

### Cons

❌ **Limited features:**
- No transactions
- No prepared statements
- No streaming
- Higher latency per query

❌ **Not ideal for:**
- Batch operations
- Complex transactions
- High-frequency queries from same process

### Best Practices

**1. Use batch for multiple operations:**
```typescript
await db.batch([
  db.insert(users).values({ email: 'test@example.com' }),
  db.insert(posts).values({ title: 'Test' }),
]);
```

**2. Cache query results:**
```typescript
import { unstable_cache } from 'next/cache';

const getUsers = unstable_cache(
  async () => db.select().from(users),
  ['users'],
  { revalidate: 60 }
);
```

**3. Minimize round trips:**
```typescript
const usersWithPosts = await db.query.users.findMany({
  with: { posts: true },
});
```

## WebSocket Adapter (@neondatabase/serverless with neon-serverless)

### When to Use

✅ **Long-lived processes:**
- Express/Fastify servers
- Standard Node.js applications
- Background workers
- WebSocket servers
- Bun applications

✅ **Characteristics:**
- Persistent connections
- Long execution time
- Connection pooling
- Complex transactions

### Setup

**Installation:**
```bash
npm add drizzle-orm @neondatabase/serverless ws
npm add -D drizzle-kit @types/ws
```

**Connection:**
```typescript
import { drizzle } from 'drizzle-orm/neon-serverless';
import { Pool, neonConfig } from '@neondatabase/serverless';
import ws from 'ws';

neonConfig.webSocketConstructor = ws;

const pool = new Pool({
  connectionString: process.env.DATABASE_URL!,
  max: 10,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 5000,
});

export const db = drizzle(pool);
```

**Complete example:** See `templates/db-websocket.ts`

### Pros

✅ **Full features:**
- Transactions
- Prepared statements
- Streaming
- Lower latency (persistent connection)

✅ **Better for:**
- Multiple queries per request
- Complex business logic
- High-frequency operations

### Cons

❌ **More complex:**
- Connection pool management
- Need to handle connection errors
- Not available in edge environments

❌ **Resource considerations:**
- Connection limits
- Memory usage
- Cold start overhead

### Best Practices

**1. Configure connection pool:**
```typescript
const pool = new Pool({
  connectionString: process.env.DATABASE_URL!,
  max: 10,                    // Max connections
  idleTimeoutMillis: 30000,   // Close idle after 30s
  connectionTimeoutMillis: 5000, // Timeout after 5s
});
```

**2. Graceful shutdown:**
```typescript
process.on('SIGTERM', async () => {
  await pool.end();
  process.exit(0);
});

process.on('SIGINT', async () => {
  await pool.end();
  process.exit(0);
});
```

**3. Use transactions:**
```typescript
await db.transaction(async (tx) => {
  const user = await tx.insert(users)
    .values({ email: 'test@example.com' })
    .returning();

  await tx.insert(posts)
    .values({ userId: user[0].id, title: 'First post' });
});
```

**4. Handle connection errors:**
```typescript
pool.on('error', (err) => {
  console.error('Unexpected pool error:', err);
});

pool.on('connect', () => {
  console.log('Pool connection established');
});
```

## Framework-Specific Recommendations

### Next.js

**App Router (default):**
- Use HTTP adapter (Edge Runtime)
- Server Actions → HTTP
- Route Handlers → HTTP

**Pages Router:**
- API Routes → Either adapter works
- Recommend HTTP for consistency

**Example:**
```typescript
// app/actions/users.ts
'use server';

import { db } from '@/db'; // HTTP adapter
import { users } from '@/db/schema';

export async function createUser(email: string) {
  return db.insert(users).values({ email }).returning();
}
```

### Express

**Standard setup:**
- Use WebSocket adapter
- Configure connection pool
- Implement health checks

**Example:**
```typescript
import express from 'express';
import { db } from './db'; // WebSocket adapter
import { users } from './db/schema';

const app = express();

app.get('/health', async (req, res) => {
  try {
    await db.select().from(users).limit(1);
    res.json({ status: 'healthy' });
  } catch (err) {
    res.status(500).json({ status: 'unhealthy', error: err.message });
  }
});

app.listen(3000);
```

### Vite/React (SPA)

**Deployment matters:**

**If deploying to Vercel:**
- API routes → HTTP adapter
- Static files → No backend needed

**If deploying to Node.js server:**
- Backend API → WebSocket adapter
- Frontend → Fetch from API

### Bun

**Recommendation:**
- Use WebSocket adapter
- Bun has built-in WebSocket support
- No need for `ws` package

**Setup:**
```typescript
import { drizzle } from 'drizzle-orm/neon-serverless';
import { Pool } from '@neondatabase/serverless';

const pool = new Pool({ connectionString: process.env.DATABASE_URL! });
export const db = drizzle(pool);
```

## Mixed Environments

### Using Both Adapters

If you have both serverless and long-lived components:

**Structure:**
```
src/
├── db/
│   ├── http.ts        # HTTP adapter for serverless
│   ├── ws.ts          # WebSocket for servers
│   └── schema.ts      # Shared schema
```

**HTTP adapter:**
```typescript
// src/db/http.ts
import { drizzle } from 'drizzle-orm/neon-http';
import { neon } from '@neondatabase/serverless';

const sql = neon(process.env.DATABASE_URL!);
export const httpDb = drizzle(sql);
```

**WebSocket adapter:**
```typescript
// src/db/ws.ts
import { drizzle } from 'drizzle-orm/neon-serverless';
import { Pool, neonConfig } from '@neondatabase/serverless';
import ws from 'ws';

neonConfig.webSocketConstructor = ws;
const pool = new Pool({ connectionString: process.env.DATABASE_URL! });
export const wsDb = drizzle(pool);
```

**Usage:**
```typescript
// Vercel Edge Function
import { httpDb as db } from '@/db/http';

// Express route
import { wsDb as db } from '@/db/ws';
```

## Feature Comparison Table

| Feature | HTTP Adapter | WebSocket Adapter |
|---------|-------------|-------------------|
| Transactions | ❌ No | ✅ Yes |
| Prepared statements | ❌ No | ✅ Yes |
| Streaming results | ❌ No | ✅ Yes |
| Connection pooling | N/A (stateless) | ✅ Yes |
| Edge runtime | ✅ Yes | ❌ No |
| Cold start speed | ✅ Fast | ⚠️ Slower |
| Latency per query | ⚠️ Higher | ✅ Lower |
| Batch operations | ✅ Yes | ✅ Yes |
| Max connection limit | N/A | ⚠️ Applies |

## Performance Considerations

### HTTP Adapter Performance

**Optimize by:**
- Minimizing round trips
- Using batch operations
- Caching query results
- Pre-fetching related data

**Typical latency:**
- Single query: 50-200ms
- Batch operation: 100-300ms

### WebSocket Adapter Performance

**Optimize by:**
- Configuring pool size correctly
- Using transactions for related operations
- Implementing query caching
- Monitoring connection usage

**Typical latency:**
- First query (connection): 50-100ms
- Subsequent queries: 10-50ms

## Troubleshooting

### HTTP Adapter Issues

**Problem:** "fetch is not defined"
- **Solution:** Ensure running in environment with fetch API (Node 18+, edge runtime)

**Problem:** Slow queries
- **Solution:** Use batch operations, reduce round trips

### WebSocket Adapter Issues

**Problem:** "WebSocket is not defined"
- **Solution:** Add `neonConfig.webSocketConstructor = ws`

**Problem:** "Too many connections"
- **Solution:** Reduce pool `max` size, ensure connections are closed

**Problem:** Connection timeouts
- **Solution:** Increase `connectionTimeoutMillis`, implement retry logic

## Migration Between Adapters

### HTTP → WebSocket

**When:** Moving from serverless to dedicated server.

**Steps:**
1. Install ws: `npm add ws @types/ws`
2. Update connection file to WebSocket adapter
3. Update drizzle.config.ts if needed
4. Test transactions (now available)

### WebSocket → HTTP

**When:** Moving to serverless/edge deployment.

**Steps:**
1. Update connection file to HTTP adapter
2. Remove ws dependency
3. **Important:** Replace transactions with batch operations
4. Test thoroughly (feature differences)

## Choosing the Right Adapter

**Ask yourself:**

1. **Where am I deploying?**
   - Edge/Serverless → HTTP
   - Node.js server → WebSocket

2. **Do I need transactions?**
   - Yes → WebSocket
   - No → Either works

3. **What's my request pattern?**
   - Short, infrequent → HTTP
   - Long, frequent → WebSocket

4. **Am I optimizing for?**
   - Cold starts → HTTP
   - Latency → WebSocket

**When in doubt:** Start with HTTP (simpler), migrate to WebSocket if needed.

## Related Resources

- `guides/new-project.md` - Setup guides for both adapters
- `guides/troubleshooting.md` - Connection error solutions
- `templates/db-http.ts` - HTTP adapter template
- `templates/db-websocket.ts` - WebSocket adapter template


============================================================
END FILE: .fleet/skills/neon-db/neon-drizzle/references/adapters.md
============================================================

============================================================
FILE: .fleet/skills/neon-db/neon-drizzle/references/migrations.md
============================================================

# Migration Reference Guide

Complete guide for database migrations with Drizzle and Neon.

## Table of Contents

- [Migration Lifecycle](#migration-lifecycle)
- [Environment Loading Deep-Dive](#environment-loading-deep-dive)
- [Migration Patterns](#migration-patterns)
- [Advanced Patterns](#advanced-patterns)
- [Migration in CI/CD](#migration-in-cicd)
- [Common Migration Errors](#common-migration-errors)
- [Best Practices](#best-practices)
- [Related Resources](#related-resources)

---

## Migration Lifecycle

### 1. Schema Change

Update your schema file:
```typescript
// src/db/schema.ts
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  email: varchar('email', { length: 255 }).notNull(),
  phoneNumber: varchar('phone_number', { length: 20 }), // NEW
});
```

### 2. Generate Migration

Run drizzle-kit to generate SQL:
```bash
npm run drizzle-kit generate
```

**What this does:**
- Compares schema.ts with database
- Generates SQL in migrations folder
- Creates migration metadata

**Output:**
```
src/db/migrations/
├── 0000_initial.sql
├── 0001_add_phone_number.sql
└── meta/
    ├── _journal.json
    └── 0001_snapshot.json
```

### 3. Review Migration

**Always review** generated SQL before applying:
```sql
-- 0001_add_phone_number.sql
ALTER TABLE users ADD COLUMN phone_number VARCHAR(20);
```

### 4. Apply Migration

Execute migration against database:
```bash
npm run drizzle-kit migrate
```

**Or with explicit env loading:**
```bash
export DATABASE_URL="$(grep DATABASE_URL .env.local | cut -d '=' -f2)" && \
npm run drizzle-kit migrate
```

## Environment Loading Deep-Dive

### Why Environment Loading Matters

**Problem:** drizzle-kit runs as separate process, may not inherit env vars.

**Symptom:**
```
Error: url is undefined in dbCredentials
```

### Solution 1: Config File Loading (Recommended)

**drizzle.config.ts:**
```typescript
import { defineConfig } from 'drizzle-kit';
import { config } from 'dotenv';

config({ path: '.env.local' });

export default defineConfig({
  schema: './src/db/schema.ts',
  out: './src/db/migrations',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});
```

**Key:** `config({ path: '.env.local' })` loads before exporting config.

### Solution 2: Shell Export

**Bash/Zsh:**
```bash
export DATABASE_URL="$(grep DATABASE_URL .env.local | cut -d '=' -f2)" && \
npm run drizzle-kit migrate
```

**Fish:**
```fish
set -x DATABASE_URL (grep DATABASE_URL .env.local | cut -d '=' -f2)
npm run drizzle-kit migrate
```

**PowerShell:**
```powershell
$env:DATABASE_URL = (Select-String -Path .env.local -Pattern "DATABASE_URL").Line.Split("=")[1]
npm run drizzle-kit migrate
```

### Solution 3: NPM Scripts

**package.json:**
```json
{
  "scripts": {
    "db:generate": "drizzle-kit generate",
    "db:migrate": "dotenv -e .env.local -- drizzle-kit migrate",
    "db:push": "dotenv -e .env.local -- drizzle-kit push"
  }
}
```

**Install dotenv-cli:**
```bash
npm add -D dotenv-cli
```

### Solution 4: Programmatic Migration

**scripts/migrate.ts:**
```typescript
import { drizzle } from 'drizzle-orm/neon-http';
import { neon } from '@neondatabase/serverless';
import { migrate } from 'drizzle-orm/neon-http/migrator';
import { config } from 'dotenv';

config({ path: '.env.local' });

const sql = neon(process.env.DATABASE_URL!);
const db = drizzle(sql);

await migrate(db, { migrationsFolder: './src/db/migrations' });
console.log('Migrations complete');
```

**Run:**
```bash
tsx scripts/migrate.ts
```

## Migration Patterns

### Initial Setup

**First migration creates all tables:**
```sql
-- 0000_initial.sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) NOT NULL UNIQUE,
  name VARCHAR(255) NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE posts (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL REFERENCES users(id),
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX posts_user_id_idx ON posts(user_id);
```

### Adding Columns

**Schema:**
```typescript
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  email: varchar('email', { length: 255 }).notNull(),
  phoneNumber: varchar('phone_number', { length: 20 }), // NEW
});
```

**Generated:**
```sql
ALTER TABLE users ADD COLUMN phone_number VARCHAR(20);
```

### Dropping Columns

**Schema:**
```typescript
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  email: varchar('email', { length: 255 }).notNull(),
  // removed: phoneNumber
});
```

**Generated:**
```sql
ALTER TABLE users DROP COLUMN phone_number;
```

**Warning:** Data loss! Back up first.

### Renaming Columns

**Problem:** Drizzle sees rename as drop + add (data loss).

**Schema:**
```typescript
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  fullName: varchar('full_name', { length: 255 }), // was 'name'
});
```

**Generated (WRONG):**
```sql
ALTER TABLE users DROP COLUMN name;
ALTER TABLE users ADD COLUMN full_name VARCHAR(255);
```

**Solution:** Manually edit migration:
```sql
-- Change to:
ALTER TABLE users RENAME COLUMN name TO full_name;
```

### Changing Column Types

**Schema:**
```typescript
export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  views: bigint('views', { mode: 'number' }), // was integer
});
```

**Generated:**
```sql
ALTER TABLE posts ALTER COLUMN views TYPE BIGINT;
```

**Caution:** May require data migration if types incompatible.

### Adding Indexes

**Schema:**
```typescript
export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  title: text('title').notNull(),
}, (table) => ({
  titleIdx: index('posts_title_idx').on(table.title), // NEW
}));
```

**Generated:**
```sql
CREATE INDEX posts_title_idx ON posts(title);
```

### Adding Foreign Keys

**Schema:**
```typescript
export const comments = pgTable('comments', {
  id: serial('id').primaryKey(),
  postId: serial('post_id')
    .notNull()
    .references(() => posts.id), // NEW
  content: text('content').notNull(),
});
```

**Generated:**
```sql
ALTER TABLE comments
  ADD CONSTRAINT comments_post_id_fkey
  FOREIGN KEY (post_id) REFERENCES posts(id);
```

### Adding Constraints

**Unique:**
```typescript
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  email: varchar('email', { length: 255 }).notNull().unique(),
});
```

**Generated:**
```sql
ALTER TABLE users ADD CONSTRAINT users_email_unique UNIQUE (email);
```

**Check:**
```typescript
export const products = pgTable('products', {
  id: serial('id').primaryKey(),
  price: integer('price').notNull(),
}, (table) => ({
  priceCheck: check('price_check', 'price >= 0'),
}));
```

**Generated:**
```sql
ALTER TABLE products ADD CONSTRAINT price_check CHECK (price >= 0);
```

## Advanced Patterns

### Data Migrations

**Scenario:** Add column with computed value from existing data.

**Step 1:** Generate migration:
```bash
npm run drizzle-kit generate
```

**Step 2:** Edit migration to add data transformation:
```sql
-- Add column
ALTER TABLE users ADD COLUMN full_name VARCHAR(255);

-- Populate with data
UPDATE users SET full_name = first_name || ' ' || last_name;

-- Make not null after population
ALTER TABLE users ALTER COLUMN full_name SET NOT NULL;
```

### Conditional Migrations

**Add IF NOT EXISTS for idempotency:**
```sql
ALTER TABLE users
  ADD COLUMN IF NOT EXISTS phone_number VARCHAR(20);

CREATE INDEX IF NOT EXISTS posts_title_idx ON posts(title);
```

**Useful for:**
- Re-running migrations
- Partial deployments
- Development environments

### Multi-Step Migrations

**Scenario:** Rename with zero downtime.

**Migration 1 (Deploy this first):**
```sql
-- Add new column
ALTER TABLE users ADD COLUMN full_name VARCHAR(255);

-- Copy data
UPDATE users SET full_name = name;
```

**Application update:** Write to both `name` and `full_name`.

**Migration 2 (Deploy after apps updated):**
```sql
-- Make new column not null
ALTER TABLE users ALTER COLUMN full_name SET NOT NULL;

-- Drop old column
ALTER TABLE users DROP COLUMN name;
```

### Rollback Strategies

**Option 1: Down migrations (manual)**

Create reverse migration:
```sql
-- up.sql
ALTER TABLE users ADD COLUMN phone_number VARCHAR(20);

-- down.sql (create manually)
ALTER TABLE users DROP COLUMN phone_number;
```

**Option 2: Snapshot and restore**

**Before migration:**
```bash
pg_dump $DATABASE_URL > backup.sql
```

**If problems:**
```bash
psql $DATABASE_URL < backup.sql
```

**Option 3: Drizzle push (dev only)**

Reset to schema state:
```bash
npm run drizzle-kit push --force
```

**Warning:** Data loss in dev!

## Migration in CI/CD

### GitHub Actions Example

```yaml
name: Deploy

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Install dependencies
        run: npm ci

      - name: Run migrations
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
        run: npm run db:migrate

      - name: Deploy application
        run: npm run deploy
```

### Vercel Example

**vercel.json:**
```json
{
  "buildCommand": "npm run build && npm run db:migrate",
  "env": {
    "DATABASE_URL": "@database_url"
  }
}
```

**package.json:**
```json
{
  "scripts": {
    "build": "next build",
    "db:migrate": "drizzle-kit migrate"
  }
}
```

### Safety Checks

**Pre-migration script:**
```typescript
// scripts/pre-migrate.ts
import { drizzle } from 'drizzle-orm/neon-http';
import { neon } from '@neondatabase/serverless';

const sql = neon(process.env.DATABASE_URL!);
const db = drizzle(sql);

async function preMigrationChecks() {
  try {
    await sql`SELECT 1`;
    console.log('✅ Database connection successful');

    const tables = await sql`
      SELECT tablename FROM pg_tables
      WHERE schemaname = 'public'
    `;
    console.log(`✅ Found ${tables.length} tables`);

    return true;
  } catch (err) {
    console.error('❌ Pre-migration check failed:', err);
    process.exit(1);
  }
}

preMigrationChecks();
```

## Common Migration Errors

### Error: "migration already applied"

**Cause:** Journal shows migration as applied.

**Solution:**
```bash
# Check journal
cat src/db/migrations/meta/_journal.json

# Remove entry if needed (dev only!)
# Or regenerate migrations
rm -rf src/db/migrations/*
npm run drizzle-kit generate
```

### Error: "column already exists"

**Cause:** Schema out of sync with database.

**Solutions:**

**Option 1:** Edit migration to use IF NOT EXISTS:
```sql
ALTER TABLE users
  ADD COLUMN IF NOT EXISTS phone_number VARCHAR(20);
```

**Option 2:** Reset migrations (dev only):
```bash
npm run drizzle-kit drop  # Drops all tables!
npm run drizzle-kit migrate
```

### Error: "violates foreign key constraint"

**Cause:** Trying to drop table referenced by foreign keys.

**Solution:** Drop in reverse dependency order:
```sql
DROP TABLE comments;  -- First (depends on posts)
DROP TABLE posts;     -- Then (depends on users)
DROP TABLE users;     -- Finally
```

Or use CASCADE (data loss!):
```sql
DROP TABLE users CASCADE;
```

### Error: "cannot drop column"

**Cause:** Column referenced by views, functions, or constraints.

**Solution:**
```sql
-- Find dependencies
SELECT * FROM information_schema.view_column_usage
WHERE column_name = 'your_column';

-- Drop views first
DROP VIEW view_name;

-- Then drop column
ALTER TABLE users DROP COLUMN your_column;
```

## Best Practices

### 1. Always Review Generated SQL

Don't blindly apply migrations:
```bash
# Generate
npm run drizzle-kit generate

# Review
cat src/db/migrations/0001_*.sql

# Apply only after review
npm run drizzle-kit migrate
```

### 2. Test Migrations in Development

**Before production:**
```bash
# On dev database
export DATABASE_URL=$DEV_DATABASE_URL
npm run db:migrate

# Test application
npm run test

# Only then deploy to production
```

### 3. Back Up Before Major Migrations

```bash
pg_dump $DATABASE_URL > backup_$(date +%Y%m%d).sql
```

### 4. Use Transactions (when possible)

Wrap multiple operations:
```sql
BEGIN;

ALTER TABLE users ADD COLUMN phone_number VARCHAR(20);
UPDATE users SET phone_number = '000-000-0000' WHERE phone_number IS NULL;
ALTER TABLE users ALTER COLUMN phone_number SET NOT NULL;

COMMIT;
```

### 5. Document Breaking Changes

Add comments in migration files:
```sql
-- Breaking change: Removing deprecated 'username' column
-- Applications must use 'email' instead
-- Migration date: 2024-01-15
ALTER TABLE users DROP COLUMN username;
```

### 6. Keep Migrations Small

One logical change per migration:
- ✅ Good: "Add phone number column"
- ❌ Bad: "Add phone number, refactor users table, update indexes"

## Related Resources

- `guides/troubleshooting.md` - Migration error solutions
- `guides/schema-only.md` - Schema change patterns
- `references/adapters.md` - Connection configuration
- Scripts: `scripts/run-migration.ts`


============================================================
END FILE: .fleet/skills/neon-db/neon-drizzle/references/migrations.md
============================================================

============================================================
FILE: .fleet/skills/neon-db/neon-drizzle/references/query-patterns.md
============================================================

# Query Patterns Reference Guide

Complete reference for querying with Drizzle ORM.

## Table of Contents

- [Basic CRUD Operations](#basic-crud-operations)
- [Advanced Filtering](#advanced-filtering)
- [Joins and Relations](#joins-and-relations)
- [Aggregations](#aggregations)
- [Subqueries](#subqueries)
- [Transactions](#transactions)
- [Batch Operations](#batch-operations)
- [Raw SQL](#raw-sql)
- [Performance Optimization](#performance-optimization)
- [Type Safety](#type-safety)
- [Common Patterns](#common-patterns)
- [Related Resources](#related-resources)

---

## Basic CRUD Operations

### Create (Insert)

**Single record:**
```typescript
import { db } from './db';
import { users } from './db/schema';

const newUser = await db.insert(users)
  .values({
    email: 'user@example.com',
    name: 'John Doe',
  })
  .returning();

console.log(newUser[0]); // { id: 1, email: '...', name: '...' }
```

**Multiple records:**
```typescript
const newUsers = await db.insert(users)
  .values([
    { email: 'user1@example.com', name: 'User 1' },
    { email: 'user2@example.com', name: 'User 2' },
    { email: 'user3@example.com', name: 'User 3' },
  ])
  .returning();
```

**With onConflictDoNothing:**
```typescript
await db.insert(users)
  .values({ email: 'user@example.com', name: 'John' })
  .onConflictDoNothing();
```

**With onConflictDoUpdate (upsert):**
```typescript
await db.insert(users)
  .values({ email: 'user@example.com', name: 'John' })
  .onConflictDoUpdate({
    target: users.email,
    set: { name: 'John Updated' },
  });
```

### Read (Select)

**All records:**
```typescript
const allUsers = await db.select().from(users);
```

**Specific columns:**
```typescript
const userEmails = await db.select({
  id: users.id,
  email: users.email,
}).from(users);
```

**With WHERE clause:**
```typescript
import { eq, gt, lt, like, and, or } from 'drizzle-orm';

const user = await db.select()
  .from(users)
  .where(eq(users.email, 'user@example.com'));

const activeUsers = await db.select()
  .from(users)
  .where(eq(users.isActive, true));
```

**Multiple conditions:**
```typescript
const filteredUsers = await db.select()
  .from(users)
  .where(
    and(
      eq(users.isActive, true),
      gt(users.createdAt, new Date('2024-01-01'))
    )
  );
```

**With LIMIT and OFFSET:**
```typescript
const paginatedUsers = await db.select()
  .from(users)
  .limit(10)
  .offset(20); // Page 3
```

**With ORDER BY:**
```typescript
const sortedUsers = await db.select()
  .from(users)
  .orderBy(users.createdAt); // ASC by default

import { desc } from 'drizzle-orm';
const recentUsers = await db.select()
  .from(users)
  .orderBy(desc(users.createdAt));
```

### Update

**Single record:**
```typescript
await db.update(users)
  .set({ name: 'Jane Doe' })
  .where(eq(users.id, 1));
```

**Multiple records:**
```typescript
await db.update(users)
  .set({ isActive: false })
  .where(eq(users.deletedAt, null));
```

**With returning:**
```typescript
const updated = await db.update(users)
  .set({ name: 'Updated Name' })
  .where(eq(users.id, 1))
  .returning();
```

**Partial updates:**
```typescript
const updates: Partial<typeof users.$inferSelect> = {
  name: 'New Name',
};

await db.update(users)
  .set(updates)
  .where(eq(users.id, 1));
```

### Delete

**Single record:**
```typescript
await db.delete(users)
  .where(eq(users.id, 1));
```

**Multiple records:**
```typescript
await db.delete(users)
  .where(eq(users.isActive, false));
```

**With returning:**
```typescript
const deleted = await db.delete(users)
  .where(eq(users.id, 1))
  .returning();
```

**Soft delete (recommended):**
```typescript
await db.update(users)
  .set({ deletedAt: new Date() })
  .where(eq(users.id, 1));
```

## Advanced Filtering

### Comparison Operators

```typescript
import { eq, ne, gt, gte, lt, lte } from 'drizzle-orm';

const adults = await db.select()
  .from(users)
  .where(gte(users.age, 18));

const recentPosts = await db.select()
  .from(posts)
  .where(gt(posts.createdAt, new Date('2024-01-01')));

const excludeAdmin = await db.select()
  .from(users)
  .where(ne(users.role, 'admin'));
```

### Pattern Matching

```typescript
import { like, ilike } from 'drizzle-orm';

const gmailUsers = await db.select()
  .from(users)
  .where(like(users.email, '%@gmail.com'));

const searchByName = await db.select()
  .from(users)
  .where(ilike(users.name, '%john%')); // Case-insensitive
```

### NULL Checks

```typescript
import { isNull, isNotNull } from 'drizzle-orm';

const usersWithPhone = await db.select()
  .from(users)
  .where(isNotNull(users.phoneNumber));

const unverifiedUsers = await db.select()
  .from(users)
  .where(isNull(users.emailVerifiedAt));
```

### IN Operator

```typescript
import { inArray } from 'drizzle-orm';

const specificUsers = await db.select()
  .from(users)
  .where(inArray(users.id, [1, 2, 3, 4, 5]));
```

### BETWEEN

```typescript
import { between } from 'drizzle-orm';

const postsThisMonth = await db.select()
  .from(posts)
  .where(
    between(
      posts.createdAt,
      new Date('2024-01-01'),
      new Date('2024-01-31')
    )
  );
```

### Complex Conditions

```typescript
import { and, or, not } from 'drizzle-orm';

const complexQuery = await db.select()
  .from(users)
  .where(
    or(
      and(
        eq(users.isActive, true),
        gte(users.age, 18)
      ),
      eq(users.role, 'admin')
    )
  );
```

## Joins and Relations

### Manual Joins

**Inner join:**
```typescript
const postsWithAuthors = await db.select({
  postId: posts.id,
  postTitle: posts.title,
  authorName: users.name,
  authorEmail: users.email,
})
.from(posts)
.innerJoin(users, eq(posts.authorId, users.id));
```

**Left join:**
```typescript
const allPostsWithOptionalAuthors = await db.select()
  .from(posts)
  .leftJoin(users, eq(posts.authorId, users.id));
```

### Relational Queries (Recommended)

**Define relations first:**
```typescript
import { relations } from 'drizzle-orm';

export const usersRelations = relations(users, ({ many }) => ({
  posts: many(posts),
}));

export const postsRelations = relations(posts, ({ one }) => ({
  author: one(users, {
    fields: [posts.authorId],
    references: [users.id],
  }),
}));
```

**Query with relations:**
```typescript
const usersWithPosts = await db.query.users.findMany({
  with: {
    posts: true,
  },
});

console.log(usersWithPosts[0].posts); // Array of posts
```

**Nested relations:**
```typescript
const postsWithAuthorsAndComments = await db.query.posts.findMany({
  with: {
    author: true,
    comments: {
      with: {
        author: true,
      },
    },
  },
});
```

**Filtered relations:**
```typescript
const usersWithRecentPosts = await db.query.users.findMany({
  with: {
    posts: {
      where: gt(posts.createdAt, new Date('2024-01-01')),
      orderBy: desc(posts.createdAt),
      limit: 5,
    },
  },
});
```

**Partial selection:**
```typescript
const usersWithPostTitles = await db.query.users.findMany({
  columns: {
    id: true,
    name: true,
  },
  with: {
    posts: {
      columns: {
        id: true,
        title: true,
      },
    },
  },
});
```

## Aggregations

### Count

```typescript
import { count } from 'drizzle-orm';

const userCount = await db.select({
  count: count(),
}).from(users);

console.log(userCount[0].count); // Total users
```

**Count with grouping:**
```typescript
const postsByAuthor = await db.select({
  authorId: posts.authorId,
  postCount: count(),
})
.from(posts)
.groupBy(posts.authorId);
```

### Sum, Avg, Min, Max

```typescript
import { sum, avg, min, max } from 'drizzle-orm';

const stats = await db.select({
  totalViews: sum(posts.views),
  avgViews: avg(posts.views),
  minViews: min(posts.views),
  maxViews: max(posts.views),
}).from(posts);
```

### Having

```typescript
const activeAuthors = await db.select({
  authorId: posts.authorId,
  postCount: count(),
})
.from(posts)
.groupBy(posts.authorId)
.having(gt(count(), 5)); // Authors with > 5 posts
```

## Subqueries

### In WHERE clause

```typescript
const activeUserIds = db.select({ id: users.id })
  .from(users)
  .where(eq(users.isActive, true));

const postsFromActiveUsers = await db.select()
  .from(posts)
  .where(inArray(posts.authorId, activeUserIds));
```

### As derived table

```typescript
const recentPosts = db.select()
  .from(posts)
  .where(gt(posts.createdAt, new Date('2024-01-01')))
  .as('recentPosts');

const authorsOfRecentPosts = await db.select()
  .from(users)
  .innerJoin(recentPosts, eq(users.id, recentPosts.authorId));
```

## Transactions

**Only available with WebSocket adapter!**

```typescript
await db.transaction(async (tx) => {
  const user = await tx.insert(users)
    .values({ email: 'user@example.com', name: 'John' })
    .returning();

  await tx.insert(posts)
    .values({
      authorId: user[0].id,
      title: 'First post',
      content: 'Hello world',
    });
});
```

**With error handling:**
```typescript
try {
  await db.transaction(async (tx) => {
    await tx.insert(users).values({ email: 'user@example.com' });
    await tx.insert(posts).values({ title: 'Post' });

    throw new Error('Rollback!'); // Transaction rolls back
  });
} catch (err) {
  console.error('Transaction failed:', err);
}
```

**Nested transactions:**
```typescript
await db.transaction(async (tx) => {
  await tx.insert(users).values({ email: 'user1@example.com' });

  await tx.transaction(async (tx2) => {
    await tx2.insert(posts).values({ title: 'Post 1' });
  });
});
```

## Batch Operations

**HTTP adapter alternative to transactions:**
```typescript
await db.batch([
  db.insert(users).values({ email: 'user1@example.com' }),
  db.insert(users).values({ email: 'user2@example.com' }),
  db.insert(posts).values({ title: 'Post 1' }),
]);
```

**Note:** Not atomic! Use transactions if you need rollback capability.

## Raw SQL

### Execute raw query

```typescript
import { sql } from 'drizzle-orm';

const result = await db.execute(sql`
  SELECT * FROM users
  WHERE email LIKE ${'%@gmail.com'}
`);
```

### SQL in WHERE clause

```typescript
const users = await db.select()
  .from(users)
  .where(sql`${users.email} LIKE '%@gmail.com'`);
```

### SQL expressions

```typescript
const posts = await db.select({
  id: posts.id,
  title: posts.title,
  excerpt: sql<string>`LEFT(${posts.content}, 100)`,
}).from(posts);
```

### Custom functions

```typescript
const searchResults = await db.select()
  .from(posts)
  .where(
    sql`to_tsvector('english', ${posts.content}) @@ to_tsquery('english', ${'search query'})`
  );
```

## Performance Optimization

### Select only needed columns

❌ **Bad:**
```typescript
const users = await db.select().from(users); // All columns
```

✅ **Good:**
```typescript
const users = await db.select({
  id: users.id,
  email: users.email,
}).from(users);
```

### Use indexes

**Ensure indexed columns in WHERE:**
```typescript
// Assuming index on users.email
const user = await db.select()
  .from(users)
  .where(eq(users.email, 'user@example.com')); // Fast
```

### Avoid N+1 queries

❌ **Bad:**
```typescript
const posts = await db.select().from(posts);

for (const post of posts) {
  const author = await db.select()
    .from(users)
    .where(eq(users.id, post.authorId)); // N queries!
}
```

✅ **Good:**
```typescript
const posts = await db.query.posts.findMany({
  with: {
    author: true, // Single query with join
  },
});
```

### Use pagination

```typescript
async function getPaginatedUsers(page: number, pageSize: number = 10) {
  return db.select()
    .from(users)
    .limit(pageSize)
    .offset((page - 1) * pageSize);
}
```

### Batch inserts

❌ **Bad:**
```typescript
for (const user of users) {
  await db.insert(users).values(user); // N queries
}
```

✅ **Good:**
```typescript
await db.insert(users).values(users); // Single query
```

## Type Safety

### Infer types from schema

```typescript
type User = typeof users.$inferSelect;
type NewUser = typeof users.$inferInsert;

const user: User = {
  id: 1,
  email: 'user@example.com',
  name: 'John',
  createdAt: new Date(),
};

const newUser: NewUser = {
  email: 'user@example.com',
  name: 'John',
};
```

### Type-safe WHERE conditions

```typescript
function getUsersByStatus(status: User['status']) {
  return db.select()
    .from(users)
    .where(eq(users.status, status));
}
```

### Type-safe updates

```typescript
function updateUser(id: number, data: Partial<NewUser>) {
  return db.update(users)
    .set(data)
    .where(eq(users.id, id))
    .returning();
}
```

## Common Patterns

### Soft deletes

**Schema:**
```typescript
export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  title: text('title').notNull(),
  deletedAt: timestamp('deleted_at'),
});
```

**Queries:**
```typescript
const activePosts = await db.select()
  .from(posts)
  .where(isNull(posts.deletedAt));

const deletedPosts = await db.select()
  .from(posts)
  .where(isNotNull(posts.deletedAt));
```

### Timestamps

**Auto-update:**
```typescript
async function updatePost(id: number, data: Partial<NewPost>) {
  return db.update(posts)
    .set({
      ...data,
      updatedAt: new Date(),
    })
    .where(eq(posts.id, id))
    .returning();
}
```

### Search

**Simple search:**
```typescript
const searchUsers = await db.select()
  .from(users)
  .where(
    or(
      ilike(users.name, `%${query}%`),
      ilike(users.email, `%${query}%`)
    )
  );
```

**Full-text search:**
```typescript
const searchPosts = await db.select()
  .from(posts)
  .where(
    sql`to_tsvector('english', ${posts.title} || ' ' || ${posts.content}) @@ plainto_tsquery('english', ${query})`
  );
```

### Unique constraints

**Handle duplicates:**
```typescript
try {
  await db.insert(users).values({ email: 'user@example.com' });
} catch (err) {
  if (err.code === '23505') { // Unique violation
    console.error('Email already exists');
  }