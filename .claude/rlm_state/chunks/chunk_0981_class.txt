<!-- Chunk 981: bytes 3432703-3437563, type=class -->
class SkillFleetClient:
    """Async HTTP client for Skill Fleet API.

    Attributes:
        base_url: The base URL of the API server.
        client: The httpx async client.
        timeout: Request timeout in seconds.
    """

    def __init__(self, base_url: str = "http://localhost:8000", timeout: float = 30.0):
        """Initialize the client.

        Args:
            base_url: The base URL of the API server.
            timeout: Request timeout in seconds.
        """
        self.base_url = base_url.rstrip("/")
        self.timeout = timeout
        self.client = httpx.AsyncClient(base_url=self.base_url, timeout=timeout)

    async def close(self):
        """Close the HTTP client."""
        await self.client.aclose()

    async def create_skill(self, task: str, user_id: str = "default") -> dict[str, Any]:
        """Call the skill creation endpoint.

        Args:
            task: Task description for skill creation.
            user_id: User ID for context.

        Returns:
            Response JSON with job_id.
        """
        response = await self.client.post(
            "/api/v2/skills/create", json={"task_description": task, "user_id": user_id}
        )
        response.raise_for_status()
        return response.json()

    async def get_hitl_prompt(self, job_id: str) -> dict[str, Any]:
        """Poll for a pending HITL prompt.

        Args:
            job_id: The job ID to poll.

        Returns:
            Response JSON with prompt data.
        """
        response = await self.client.get(f"/api/v2/hitl/{job_id}/prompt")
        response.raise_for_status()
        return response.json()

    async def post_hitl_response(self, job_id: str, response_data: dict[str, Any]) -> dict[str, Any]:
        """Send a response to a HITL prompt.

        Args:
            job_id: The job ID.
            response_data: The response data to send.

        Returns:
            Response JSON.
        """
        response = await self.client.post(f"/api/v2/hitl/{job_id}/response", json=response_data)
        response.raise_for_status()
        return response.json()

    async def list_skills(self) -> list[dict[str, Any]]:
        """List all skills from the taxonomy.

        Returns:
            List of skill dictionaries.
        """
        response = await self.client.get("/api/v2/taxonomy/")
        response.raise_for_status()
        return response.json().get("skills", [])

    async def start_chat_session(self) -> dict[str, Any]:
        """Initialize a new chat session.

        Returns:
            Response JSON with session_id.
        """
        response = await self.client.post("/api/v2/chat/session")
        response.raise_for_status()
        return response.json()

    async def send_chat_message(self, message: str, session_id: str) -> dict[str, Any]:
        """Send a message to the chat agent.

        Args:
            message: The message to send.
            session_id: The chat session ID.

        Returns:
            Response JSON.
        """
        response = await self.client.post(
            "/api/v2/chat/message", json={"message": message, "session_id": session_id}
        )
        response.raise_for_status()
        return response.json()
```

**Step 5: Run tests to verify they pass**

```bash
uv run pytest tests/cli/test_app.py -v
```

Expected: PASS

**Step 6: Commit**

```bash
git add src/skill_fleet/cli/app.py src/skill_fleet/cli/client.py tests/cli/test_app.py
git commit -m "feat(cli): add security validation to app.py

- Add validate_api_url callback for --api-url
- Add sanitize_user_id for --user option
- Add validate_timeout for --timeout option
- Update CLIConfig to validate all inputs
- Update SkillFleetClient to support configurable timeout
- Use singleton console from utils

Fixes security issues from cli-security-review.md"
```

---

## Task 6: Update create.py with Error Handling and Console

**Files:**
- Modify: `src/skill_fleet/cli/commands/create.py`
- Create: `tests/cli/test_create_command.py`

**Step 1: Write the failing test for create command**

Create `tests/cli/test_create_command.py`:

```python
"""Tests for create command."""

import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from typer.testing import CliRunner

from skill_fleet.cli.app import app

runner = CliRunner()


@pytest.mark.asyncio
async def test_create_command_basic():
    """Test create command with basic task."""
    with patch('skill_fleet.cli.commands.create.config') as mock_config:
        mock_config.client.create_skill = AsyncMock(return_value={"job_id": "test-123"})
        mock_config.client.get_hitl_prompt = AsyncMock(return_value={"status": "completed"})
        mock_config.user_id = "test-user"

        # This test would require running the async command
        # For now, we'll test the structure exists


