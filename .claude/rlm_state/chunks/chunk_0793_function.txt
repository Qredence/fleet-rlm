<!-- Chunk 793: bytes 2660000-2663302, type=function -->
def phase_deep_understanding(self, job, session):
    """Gather deep understanding through user interaction."""
    from skill_fleet.db.models import hitl_type_enum

    # Check if we already have understanding
    state = get_deep_understanding_state(job.job_id, session)
    if state and state.complete:
        return  # Skip if already done

    # Ask clarifying questions
    hitl = create_hitl_interaction(
        job_id=job.job_id,
        interaction_type=hitl_type_enum.deep_understanding,
        prompt_data={
            "questions": [
                "What problem are you trying to solve?",
                "What are your success criteria?",
                "Are there any constraints or preferences?"
            ]
        }
    )

    # Update job status to wait for user
    repo.update_status(job.job_id, job_status_enum.pending_hitl)

    # Worker will be notified when user responds
    # Then continue with job...
```

### Polling Endpoint for Frontend

```python
from fastapi import APIRouter

router = APIRouter()

@router.get("/jobs/{job_id}/status")
async def get_job_status(job_id: str):
    """Poll endpoint for job status."""
    with get_db() as db:
        repo = JobRepository(db)
        job = repo.get(job_id)

        if not job:
            raise HTTPException(404, "Job not found")

        return {
            "job_id": str(job.job_id),
            "status": job.status.value,
            "current_phase": job.current_phase,
            "progress_percent": job.progress_percent,
            "progress_message": job.progress_message,
            "result": job.result,
            "error": job.error,
            "created_at": job.created_at.isoformat(),
            "completed_at": job.completed_at.isoformat() if job.completed_at else None,
        }

@router.get("/jobs/pending")
async def get_pending_hitl_jobs(user_id: str):
    """Get jobs waiting for human input."""
    with get_db() as db:
        repo = JobRepository(db)
        jobs = repo.get_pending_hitl_jobs(user_id)

        return [{
            "job_id": str(j.job_id),
            "task_description": j.task_description,
            "current_phase": j.current_phase,
        } for j in jobs]
```

## Frontend Integration

### WebSocket for Real-time Updates

```python
from fastapi import WebSocket

@router.websocket("/ws/jobs/{job_id}")
async def job_updates(websocket: WebSocket, job_id: str):
    """WebSocket endpoint for real-time job updates."""
    await websocket.accept()

    try:
        while True:
            with get_db() as db:
                repo = JobRepository(db)
                job = repo.get(job_id)

                await websocket.send_json({
                    "status": job.status.value,
                    "phase": job.current_phase,
                    "progress": job.progress_percent,
                    "message": job.progress_message,
                })

                if job.status in [job_status_enum.completed, job_status_enum.failed]:
                    break

            await asyncio.sleep(1)

    except WebSocketDisconnect:
        pass
```

## Deployment

### Option 1: Celery (Recommended for Production)

```python
# tasks.py
from celery import Celery

celery_app = Celery('skills_fleet', broker='redis://localhost:6379/0')

@celery_app.task
