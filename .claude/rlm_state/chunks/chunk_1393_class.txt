<!-- Chunk 1393: bytes 5121306-5123926, type=class -->
class UserUpdate(BaseModel):
    """Update model with all optional fields"""
    name: Optional[str] = None
    email: Optional[EmailStr] = None
    age: Optional[int] = None
```

### Endpoint Implementation

```python
from fastapi import FastAPI, HTTPException

app = FastAPI()

# Simulated database
fake_db = {1: User(id=1, name="John", email="john@example.com", age=30)}

@app.patch("/users/{user_id}")
async def update_user(user_id: int, user_update: UserUpdate):
    # Check if user exists
    if user_id not in fake_db:
        raise HTTPException(status_code=404, detail="User not found")

    # Get existing user
    existing_user = fake_db[user_id]

    # Get only provided fields
    update_data = user_update.model_dump(exclude_unset=True)

    # Return unchanged if no fields provided
    if not update_data:
        return existing_user

    # Apply partial updates
    updated_user = existing_user.model_copy(update=update_data)

    # Save
    fake_db[user_id] = updated_user
    return updated_user
```

## Testing

Run the test file to see all scenarios in action:

```bash
python test_patch_endpoint.py
```

This will demonstrate:
- Partial updates (single field)
- Partial updates (multiple fields)
- Empty updates
- Full updates
- How `exclude_unset=True` works
- How `model_copy(update=...)` works

## Why This Approach is Better

### Compared to PUT:
- **PUT**: Requires ALL fields, replaces entire resource
- **PATCH**: Updates only provided fields, preserves others

### Example:
To change only the user's name:

**PUT (requires all fields):**
```json
PUT /users/1
{
  "name": "New Name",
  "email": "john@example.com",  // Must include even if not changing
  "age": 30                       // Must include even if not changing
}
```

**PATCH (only changed fields):**
```json
PATCH /users/1
{
  "name": "New Name"
}
```

## Key Takeaways

1. **Use `Optional` fields** in update models to allow partial updates
2. **Use `exclude_unset=True`** to get only provided fields (not all fields with None)
3. **Use `model_copy(update=...)`** to apply updates while preserving existing values
4. **Handle empty updates** by checking if the update dict is empty
5. **Return early** if no fields need updating (avoid unnecessary database writes)

## Common Mistakes to Avoid

### Mistake 1: Using `model_dump()` without `exclude_unset`
```python
# WRONG - includes all fields as None
update_data = user_update.model_dump()
# Result: {"name": None, "email": None, "age": None}
# This would overwrite all fields with None!
```

### Mistake 2: Not using Optional fields
```python
# WRONG - all fields required
