<!-- Chunk 1013: bytes 3558975-3560568, type=function -->
def load_program(program_path: str):
    data = load_json(program_path)
    signature_version = data.get("signature_version", "1.0")
    
    if signature_version < CURRENT_SIGNATURE_VERSION:
        # Auto-migrate
        manager = SignatureVersionManager()
        data = manager.migrate(
            data, 
            from_version=signature_version,
            to_version=CURRENT_SIGNATURE_VERSION
        )
    
    return deserialize_program(data)
```

**CLI Command**:
```bash
uv run skill-fleet signatures check --migration
# Validates all programs compatible with current signatures
# Shows migration warnings

uv run skill-fleet signatures migrate-all
# Auto-migrates all programs to latest signature versions
```

**Files to Create**:
1. `src/skill_fleet/core/dspy/signatures/versioning.py` (~250 lines)
2. Update all signature files with version decorators
3. Add migration logic to signature definitions
4. Update `src/skill_fleet/core/creator.py` with migration on load
5. Update `src/skill_fleet/cli/commands/signatures.py` (new command)

**Timeline**: 2-3 days | **Impact**: Safe schema evolution, multi-version support

---

#### **3C: Phase Conditional Branching** ðŸ”€

**Problem**: All skills go through all 3 phases; some need only subset. Simple skills waste time.

**Solution**: Detect skill complexity, conditionally skip phases.

**Implementation**:
- New signature in Phase 1: `EvaluateComplexity` 
  - Output: `is_simple: bool`, `complexity_score: 0-1`
- Conditional logic in `skill_creator.py`
- Configuration: `phase_rules.yaml`

**Complexity Detection**:
```python
