<!-- Chunk 1375: bytes 5097067-5099043, type=function -->
def sanitize_filename(filename: str) -> str:
    # Remove path separators
    filename = os.path.basename(filename)

    # Remove dangerous characters
    filename = "".join(c for c in filename if c.isalnum() or c in "._-")

    # Limit length
    return filename[:255]
```

## Performance Tips

| Optimization | Impact |
|--------------|--------|
| Stream in 1MB chunks | Reduces memory usage 90% |
| Use async I/O | Improves throughput 3x |
| Process in background | Non-blocking for users |
| Compress uploads | Reduces bandwidth |

## See Also
- [Background Tasks](background-tasks.md)
- [Async Conversion](async-conversion.md)


============================================================
END FILE: skills/python/fastapi-production/capabilities/file-upload-handling.md
============================================================

============================================================
FILE: skills/python/fastapi-production/capabilities/pydantic-partial-updates.md
============================================================

# Pydantic Partial Updates

## Overview
Implementing PATCH endpoints that correctly update only provided fields, avoiding data corruption from `None` overwrites.

## Problem Statement
**The partial update trap:**
- Naive implementations overwrite all fields, even unprovided ones become `None`
- Data silently corrupted when optional fields are missing from requests
- Frontend cannot send partial updates without destroying data

## Pattern

### ❌ Broken (None Overwrites)
```python
@app.patch("/users/{user_id}")
async def update_user(user_id: int, update: UserUpdate, db: AsyncSession = Depends(get_db)):
    user = await db.get(User, user_id)
    # ❌ This sets unprovided fields to None!
    user.name = update.name  # None if not provided
    user.email = update.email  # None if not provided
    await db.commit()
    return user
```

### ✅ Production Pattern
```python
from pydantic import BaseModel
from typing import Optional

