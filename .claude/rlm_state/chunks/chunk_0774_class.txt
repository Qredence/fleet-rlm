<!-- Chunk 774: bytes 2638640-2644178, type=class -->
class TaxonomyNotFoundError(SkillFleetError):
    """Raised when a taxonomy path doesn't exist."""
    pass

@app.exception_handler(TaxonomyNotFoundError)
async def taxonomy_not_found_handler(request: Request, exc: TaxonomyNotFoundError):
    return JSONResponse(
        status_code=404,
        content={"detail": f"Taxonomy path not found: {exc.args[0]}"}
    )
```

---

## Logging Middleware

### Request Logging

```python
from fastapi import Request
import time

@app.middleware("http")
async def log_requests(request: Request, call_next):
    """Log all requests with timing."""
    start_time = time.time()

    response = await call_next(request)

    duration = time.time() - start_time
    logger.info(
        f"{request.method} {request.url.path} "
        f"{response.status_code} {duration:.3f}s"
    )

    return response
```

### Structured Logging

```python
import structlog

logger = structlog.get_logger()

@app.post("/skills/create")
async def create_skill(request: CreateSkillRequest):
    logger.info("Creating skill",
        task_description=request.task_description,
        user_id=request.user_id,
    )
    ...
```

---

## Authentication Middleware (Future)

### API Key Authentication

```python
from fastapi import Security, HTTPException
from fastapi.security import APIKeyHeader

API_KEY_HEADER = APIKeyHeader(name="X-API-Key")

async def verify_api_key(api_key: str = Security(API_KEY_HEADER)):
    """Verify API key from request header."""
    correct_key = os.environ.get("SKILL_FLEET_API_KEY")
    if api_key != correct_key:
        raise HTTPException(status_code=403, detail="Invalid API key")
    return api_key

@app.post("/skills/create", dependencies=[Depends(verify_api_key)])
async def create_skill(...):
    ...
```

### JWT Authentication

```python
from fastapi import Depends
from fastapi.security import OAuth2PasswordBearer

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

async def verify_token(token: str = Depends(oauth2_scheme)):
    """Verify JWT token."""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expired")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Invalid token")

@app.get("/protected", dependencies=[Depends(verify_token)])
async def protected_route():
    ...
```

---

## Rate Limiting Middleware

### Using slowapi

```python
from slowapi import Limiter
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter

@app.exception_handler(RateLimitExceeded)
async def rate_limit_handler(request: Request, exc: RateLimitExceeded):
    return JSONResponse(
        status_code=429,
        content={"detail": "Rate limit exceeded"},
    )

@app.post("/skills/create")
@limiter.limit("10/minute")
async def create_skill(...):
    ...
```

---

## Request ID Middleware

Add unique request IDs for tracing:

```python
import uuid

from fastapi import Request

@app.middleware("http")
async def add_request_id(request: Request, call_next):
    """Add unique request ID to all requests."""
    request_id = str(uuid.uuid4())
    request.state.request_id = request_id

    response = await call_next(request)
    response.headers["X-Request-ID"] = request_id
    return response
```

---

## Compression Middleware

Enable response compression:

```python
from fastapi.middleware.gzip import GZipMiddleware

app.add_middleware(GZipMiddleware, minimum_size=1000)
```

---

## Trusted Host Middleware

Protect against host header attacks:

```python
from fastapi.middleware.trustedhost import TrustedHostMiddleware

app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=["localhost", "example.com", "*.example.com"]
)
```

---

## Middleware Execution Order

Middleware runs in the order it's added (reverse for response):

```python
app.add_middleware(TrustedHostMiddleware, ...)
app.add_middleware(GZipMiddleware, ...)
app.add_middleware(CORSMiddleware, ...)

# Request flow:
# TrustedHost → GZip → CORS → Route Handler
# Response flow:
# Route Handler → CORS → GZip → TrustedHost
```

---

## See Also

- **[API Overview](index.md)** - Architecture and setup
- **[Endpoints Documentation](endpoints.md)** - Endpoint reference
- **[Jobs Documentation](jobs.md)** - Background job system


============================================================
END FILE: docs/api/middleware.md
============================================================

============================================================
FILE: docs/api/schemas.md
============================================================

# API Schemas Reference

**Last Updated**: 2026-01-12
**Location**: `src/skill_fleet/api/schemas/`

## Overview

The API uses Pydantic models for request/response validation, ensuring type safety and providing automatic OpenAPI documentation. This document describes the key schemas used throughout the API.

`★ Insight ─────────────────────────────────────`
Schemas serve as the contract between clients and the API. By using Pydantic models, we get automatic validation, serialization, and OpenAPI schema generation. This makes the API self-documenting and type-safe.
`─────────────────────────────────────────────────`

## Request Schemas

### CreateSkillRequest

Request schema for creating a new skill.

```python
from pydantic import BaseModel, Field

