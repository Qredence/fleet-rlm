<!-- Chunk 921: bytes 3345945-3348470, type=class -->
class UserUpdate(BaseModel):
    name: Optional[str] = None
    email: Optional[str] = None
    age: Optional[int] = None

@app.patch("/users/{user_id}")
async def update_user(
    user_id: int,
    update: UserUpdate,
    db: AsyncSession = Depends(get_db)
):
    user = await db.get(User, user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    # CRITICAL: Only update provided fields
    update_data = update.dict(exclude_unset=True)
    for field, value in update_data.items():
        setattr(user, field, value)

    await db.commit()
    await db.refresh(user)
    return user
```

**Key insight:** `exclude_unset=True` only includes fields that were actually provided in the request, preventing `None` overwrites.

### 4. Async Testing

**The Problem:** Tests pass in isolation but fail in parallel, fixtures don't work with async, database transactions don't roll back properly.

**Pattern:**

```python
import pytest
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine

@pytest.fixture
async def async_client():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac

@pytest.fixture
async def db_session():
    # Create fresh DB for each test
    engine = create_async_engine(TEST_DATABASE_URL)
    async with AsyncSession(engine) as session:
        yield session
        # Cleanup after test
        await session.rollback()

@pytest.mark.asyncio
async def test_create_user(async_client: AsyncClient):
    response = await async_client.post("/users", json={
        "name": "Alice",
        "email": "alice@example.com"
    })
    assert response.status_code == 200
    assert response.json()["name"] == "Alice"

@pytest.mark.asyncio
async def test_parallel_requests(async_client: AsyncClient):
    # Test that handles concurrent requests
    tasks = [async_client.get("/users/1") for _ in range(10)]
    responses = await asyncio.gather(*tasks)
    assert all(r.status_code == 200 for r in responses)
```

### 5. Converting Python Functions to Endpoints

**The Problem:** You have working Python code - utilities, data processing functions, business logic. Now you need to expose it as an API. Common mistakes:
- Blocking operations that kill async performance
- Missing validation (Pydantic models not used)
- No error handling (500 errors for bad input)
- Wrong return types (dicts instead of response models)

**Before - Naive conversion (broken):**
```python
# utils.py - existing code
