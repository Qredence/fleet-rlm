<!-- Chunk 1362: bytes 5054491-5061703, type=function -->
def long_running_task(task_id: str):
    result = process_heavy_computation()
    mark_task_complete(task_id, result)

@app.post("/process")
async def start_process(background_tasks: BackgroundTasks):
    task_id = generate_task_id()
    background_tasks.add_task(long_running_task, task_id)
    return {"task_id": task_id, "status": "processing"}

# For production: Use Celery for retries and distributed execution
```

### 9. FastAPI CLI (New in 0.128.0)

**The problem:** Running FastAPI apps required manual uvicorn commands. Developers had to remember different commands for development vs production.

**❌ Old approach (still works but not recommended):**
```bash
# Development with auto-reload
uvicorn main:app --reload

# Production
uvicorn main:app --host 0.0.0.0 --port 8000
```

**✅ Modern approach with FastAPI CLI:**
```bash
# Installation (includes CLI + all standard dependencies)
uv add "fastapi[standard]"

# Development with auto-reload
fastapi dev main.py

# Production
fastapi run main.py --workers 4
```

**CLI Command Reference:**

| Command                           | Purpose            | Auto-reload |
|-----------------------------------|--------------------|-------------|
| `fastapi dev main.py`             | Development server | ✅ Yes       |
| `fastapi run main.py`             | Production server  | ❌ No        |
| `fastapi dev main.py --port 8080` | Custom port        | ✅ Yes       |
| `fastapi run main.py --workers 4` | Multiple workers   | ❌ No        |

**Key benefits:**
- Unified CLI for development and production
- Auto-reload by default in dev mode
- Includes all standard dependencies (uvicorn, httpx, jinja2, python-multipart)
- Better error messages and output formatting

> **For comprehensive CLI documentation**, see the [FastAPI CLI capability](capabilities/fastapi-cli.md)

**Installation with all standard dependencies:**
```bash
uv add "fastapi[standard]"
```

This installs:
- `fastapi` - Core framework
- `uvicorn[standard]` - ASGI server with high-performance dependencies
- `fastapi-cli[standard]` - CLI tool (includes deployment tools)
- `httpx` - For testing
- `jinja2` - For templates
- `python-multipart` - For form data

**Optional: FastAPI Cloud deployment:**
```bash
fastapi login
fastapi deploy
```

> **Note:** FastAPI Cloud is optional. You can deploy to any cloud provider (AWS, GCP, Azure, Railway, etc.) using traditional deployment methods.

## Common Mistakes

| Mistake                             | Why It's Wrong                                    | Fix                                            |
|-------------------------------------|---------------------------------------------------|------------------------------------------------|
| Creating DB engine at import time   | Connections never close, workers leak connections | Create in `lifespan`, dispose in shutdown      |
| Using `requests` in async endpoints | Blocks entire event loop                          | Use `httpx.AsyncClient`                        |
| Forgetting `exclude_unset=True`     | Optional fields become `None` and overwrite data  | Use `exclude_unset=True` for PATCH             |
| Sync fixtures with async tests      | Tests hang or fail mysteriously                   | Use `@pytest.mark.asyncio` with async fixtures |
| Global state for dependencies       | Can't test, hard to manage lifecycle              | Use `Depends()` with yield                     |
| Not setting `pool_recycle`          | Database closes idle connections, causing errors  | Set `pool_recycle=3600` or similar             |
| Using `run_in_executor` as band-aid | Still blocks threads, doesn't scale               | Proper async conversion                        |
| Missing `max_overflow` parameter    | Pool can't burst under load, requests queue       | Set `max_overflow=20` or similar               |

## Real-World Impact

- **Connection pool exhaustion** fixed with proper lifecycle management → 50 concurrent requests without errors
- **Test execution time** reduced 80% with proper async fixtures
- **API response validation** caught 15% of frontend bugs before deployment
- **Memory usage** reduced 60% by streaming file uploads instead of loading into memory
- **"Too many connections" DB errors** eliminated with proper shutdown handling

## Red Flags - STOP and Reconsider

- Code that "works locally" but you haven't load tested
- Creating database connections at module level
- Using `@app.on_event("startup")` (deprecated)
- Missing shutdown handlers
- No pool parameters on engine creation
- Using `requests` library in async functions
- Tests that only pass when run individually
- `run_in_executor` as primary async strategy

**All of these mean: Revisit your architecture. Production will break.**


============================================================
END FILE: skills/python/fastapi-production/SKILL.md
============================================================

============================================================
FILE: skills/python/fastapi-production/best_practices.md
============================================================

## Best Practices

- Always use Pydantic models for request bodies and response models to ensure data integrity.
- Prefer `async def` for route handlers unless performing heavy blocking CPU-bound tasks.
- Use `APIRouter` to split your application into multiple files for maintainability.
- Implement global exception handlers to standardize error responses across the API.
- Keep logic out of the route handlers; delegate to 'services' or 'crud' modules.
- Utilize `dependencies` for reusable logic like authentication and database connectivity.

============================================================
END FILE: skills/python/fastapi-production/best_practices.md
============================================================

============================================================
FILE: skills/python/fastapi-production/capabilities/async-conversion.md
============================================================

# Async Conversion (Sync → Async)

## Overview
Converting synchronous Python code to async, replacing blocking operations with async equivalents for production FastAPI applications.

## Problem Statement
**The async conversion challenge:**
- Simply adding `async/await` keywords doesn't make code async
- Blocking operations (requests, time.sleep, sync DB) kill event loop performance
- `run_in_executor` is a band-aid, not a solution

## Library Mapping

| Sync Library   | Async Replacement           | Notes               |
|----------------|-----------------------------|---------------------|
| `requests`     | `httpx.AsyncClient`         | HTTP calls          |
| `sqlalchemy`   | `sqlalchemy.ext.asyncio`    | Database operations |
| `time.sleep()` | `asyncio.sleep()`           | Delays              |
| `open()`       | `aiofiles`                  | File I/O            |
| `subprocess`   | `asyncio.create_subprocess` | Process spawning    |
| `redis`        | `aioredis`                  | Redis operations    |
| `motor`        | `pymongo`                   | MongoDB async       |

## Pattern: Sync → Async

### Before (Blocking)
```python
# Old sync utility
