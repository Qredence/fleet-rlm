<!-- Chunk 1711: bytes 7281486-7287784, type=class -->
class FleetConfig(BaseModel):
    """
    Complete fleet configuration.

    This is the main entry point for configuration validation. It validates
    the entire config.yaml structure and provides type-safe access to all
    configuration values.

    Usage:
        config = FleetConfig.from_yaml("config/config.yaml")
        lm_config = config.get_model_config("skill_understand")
    """

    models: ModelsConfig
    roles: RolesConfig = Field(default_factory=RolesConfig)
    tasks: TasksConfig = Field(default_factory=TasksConfig)
    legacy_aliases: dict[str, str] = Field(
        default_factory=dict, serialization_alias="legacy_aliases"
    )

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> FleetConfig:
        """
        Create a FleetConfig from a dictionary.

        Args:
            data: Dictionary representation of the config

        Returns:
            Validated FleetConfig instance

        Raises:
            ConfigurationError: If configuration is invalid

        """
        from skill_fleet.common import ConfigurationError

        try:
            return cls(**data)
        except Exception as e:
            raise ConfigurationError(f"Invalid configuration: {e}") from e

    @classmethod
    def from_yaml(cls, config_path: str | Path) -> FleetConfig:
        """
        Load and validate a fleet config from a YAML file.

        Args:
            config_path: Path to the config.yaml file

        Returns:
            Validated FleetConfig instance

        Raises:
            ConfigurationError: If file cannot be read or config is invalid

        """
        from skill_fleet.common import ConfigurationError

        path = Path(config_path)
        if not path.exists():
            raise ConfigurationError(
                f"Configuration file not found: {config_path}", config_key="config_path"
            )

        try:
            raw = yaml.safe_load(path.read_text(encoding="utf-8"))
        except Exception as e:
            raise ConfigurationError(
                f"Failed to read configuration file: {e}", config_key="config_path"
            ) from e

        if not isinstance(raw, dict):
            raise ConfigurationError(
                "Invalid config format: expected mapping at root", config_key="config_path"
            )

        return cls.from_dict(raw)

    def get_model_config(self, task_name: str) -> tuple[str, ModelConfig, ModelParameters]:
        """
        Get the resolved model configuration for a task.

        This implements the model resolution hierarchy:
        1. Environment variable: FLEET_MODEL_{TASK_NAME}
        2. Task model
        3. Role model (if task specifies a role)
        4. Environment variable: FLEET_MODEL_DEFAULT
        5. Default model from config

        Args:
            task_name: Name of the task (e.g., "skill_understand")

        Returns:
            Tuple of (model_key, model_config, merged_parameters)

        Raises:
            ConfigurationError: If model cannot be resolved

        """
        from skill_fleet.common import ConfigurationError

        task = self.tasks.get_task(task_name)
        if task is None:
            task = TaskConfig()  # Use defaults

        # Check environment variables
        env_task_model = os.environ.get(f"FLEET_MODEL_{task_name.upper()}")
        env_role_model = (
            os.environ.get(f"FLEET_MODEL_{str(task.role).upper()}") if task.role else None
        )
        env_default_model = os.environ.get("FLEET_MODEL_DEFAULT")

        # Get role model if role exists and role config is found
        role_model = None
        if task.role:
            role_config = self.roles.get_role(task.role)
            if role_config:
                role_model = role_config.model

        model_key = (
            env_task_model
            or task.model
            or role_model
            or env_role_model
            or env_default_model
            or self.models.default
        )

        if model_key is None:
            raise ConfigurationError(
                f"Unable to resolve model for task: {task_name}",
                config_key=f"tasks.{task_name}.model",
            )

        # Get model config from registry
        model_config = self.models.registry.get(model_key)
        if model_config is None:
            raise ConfigurationError(
                f"Model '{model_key}' not found in registry. "
                f"Available models: {list(self.models.registry.keys())}",
                config_key=f"models.registry.{model_key}",
            )

        # Merge parameters: model defaults -> role overrides -> task parameters -> env overrides
        merged_params = model_config.parameters.model_copy()

        if task.role:
            role_config = self.roles.get_role(task.role)
            if role_config:
                # Merge role parameter overrides
                role_params = role_config.parameter_overrides.model_dump(exclude_unset=True)
                for key, value in role_params.items():
                    if value is not None:
                        setattr(merged_params, key, value)

        # Merge task parameters
        task_params = task.parameters.model_dump(exclude_unset=True)
        for key, value in task_params.items():
            if value is not None:
                setattr(merged_params, key, value)

        # Apply environment variable override for temperature
        if "DSPY_TEMPERATURE" in os.environ:
            try:
                merged_params.temperature = float(os.environ["DSPY_TEMPERATURE"])
            except ValueError as exc:
                raise ConfigurationError(
                    "DSPY_TEMPERATURE must be a valid float",
                    config_key="env.DSPY_TEMPERATURE",
                ) from exc

        return model_key, model_config, merged_params

    def to_dict(self) -> dict[str, Any]:
        """
        Convert the config back to a dictionary.

        Returns:
            Dictionary representation of the config

        """
        return self.model_dump(mode="json", exclude_none=True)


# =============================================================================
# Convenience Functions
# =============================================================================


