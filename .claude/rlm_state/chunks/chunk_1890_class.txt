<!-- Chunk 1890: bytes 7686706-7693648, type=class -->
class SkillRepository(BaseRepository[Skill]):
    """Repository for Skill entity."""

    def __init__(self, db: Session):
        """
        Initialize the skill repository.

        Args:
            db: The database session.

        """
        super().__init__(Skill, db)

    def get_by_path(self, skill_path: str) -> Skill | None:
        """Get a skill by its path."""
        return self.db.query(Skill).filter(Skill.skill_path == skill_path).first()

    def get_by_path_with_relations(
        self,
        skill_path: str,
        load_capabilities: bool = True,
        load_dependencies: bool = True,
        load_keywords: bool = True,
        load_tags: bool = True,
    ) -> Skill | None:
        """Get a skill by path with specified relations loaded."""
        query = self.db.query(Skill).filter(Skill.skill_path == skill_path)

        if load_capabilities:
            query = query.options(joinedload(Skill.capabilities))
        if load_dependencies:
            query = query.options(
                joinedload(Skill.dependencies_as_dependent).joinedload(
                    SkillDependency.dependency_skill
                )
            )
        if load_keywords:
            query = query.options(joinedload(Skill.keywords))
        if load_tags:
            query = query.options(joinedload(Skill.tags))

        return query.first()

    def search(
        self,
        *,
        query: str,
        status: str | None = SkillStatusEnum.ACTIVE,
        skill_type: str | None = None,
        weight: str | None = None,
        limit: int = 20,
    ) -> list[Skill]:
        """
        Full-text search for skills.

        Uses PostgreSQL full-text search on the search_vector column.
        """
        from sqlalchemy import func

        # Build search query
        search_query = self.db.query(Skill)

        # Apply status filter
        if status:
            search_query = search_query.filter(Skill.status == status)

        # Apply type filter
        if skill_type:
            search_query = search_query.filter(Skill.type == skill_type)

        # Apply weight filter
        if weight:
            search_query = search_query.filter(Skill.weight == weight)

        # Apply full-text search
        if query:
            # Use PostgreSQL's tsvector for full-text search
            search_query = search_query.filter(
                Skill.search_vector.op("@@")(func.plainto_tsquery("english", query))
            )

        # Order by relevance and limit
        return (
            search_query.order_by(
                func.ts_rank(Skill.search_vector, func.plainto_tsquery("english", query)).desc()
            )
            .limit(limit)
            .all()
        )

    def get_active_skills(
        self,
        *,
        skip: int = 0,
        limit: int = 100,
        type: str | None = None,
    ) -> list[Skill]:
        """Get all active (published) skills."""
        query = self.db.query(Skill).filter(Skill.status == SkillStatusEnum.ACTIVE)

        if type:
            query = query.filter(Skill.type == type)

        return query.order_by(Skill.name).offset(skip).limit(limit).all()

    def get_dependent_skills(self, skill_id: int) -> list[Skill]:
        """Get all skills that depend on this skill."""
        return (
            self.db.query(Skill)
            .join(SkillDependency, Skill.skill_id == SkillDependency.dependent_id)
            .filter(SkillDependency.dependency_skill_id == skill_id)
            .all()
        )

    def get_dependency_tree(self, skill_id: int) -> dict:
        """
        Get the full dependency tree for a skill.

        Returns a dict with 'dependencies' (what this skill needs)
        and 'dependents' (what needs this skill).
        """
        # First get the skill to find its path
        skill = self.get(skill_id)
        if not skill:
            return {"dependencies": [], "dependents": []}

        # Now get with relations using the path
        skill = self.get_by_path_with_relations(skill.skill_path, load_dependencies=True)
        if not skill:
            return {"dependencies": [], "dependents": []}

        dependencies = []
        for dep in skill.dependencies_as_dependent:
            dependencies.append(
                {
                    "skill_path": dep.dependency_skill.skill_path,
                    "name": dep.dependency_skill.name,
                    "type": dep.dependency_type,
                    "justification": dep.justification,
                }
            )

        dependents = []
        for dep in self.get_dependent_skills(skill_id):
            dependents.append(
                {
                    "skill_path": dep.skill_path,
                    "name": dep.name,
                }
            )

        return {"dependencies": dependencies, "dependents": dependents}

    def create_with_relations(
        self,
        *,
        skill_data: dict,
        capabilities: list[dict] | None = None,
        dependencies: list[dict] | None = None,
        keywords: list[str] | None = None,
        tags: list[str] | None = None,
        allowed_tools: list[str] | None = None,
    ) -> Skill:
        """Create a skill with its relations in a single transaction."""
        # Create skill
        skill = self.create(obj_in=skill_data)

        # Add capabilities
        if capabilities:
            for cap_data in capabilities:
                cap_data["skill_id"] = skill.skill_id
                self.db.add(Capability(**cap_data))

        # Add dependencies
        if dependencies:
            for dep_data in dependencies:
                dep_data["dependent_id"] = skill.skill_id
                self.db.add(SkillDependency(**dep_data))

        # Add keywords
        if keywords:
            for keyword in keywords:
                self.db.add(SkillKeyword(skill_id=skill.skill_id, keyword=keyword))

        # Add tags
        if tags:
            for tag in tags:
                self.db.add(SkillTag(skill_id=skill.skill_id, tag=tag))

        # Add allowed tools
        if allowed_tools:
            for tool in allowed_tools:
                self.db.add(SkillAllowedTool(skill_id=skill.skill_id, tool_name=tool))

        self.db.commit()
        self.db.refresh(skill)
        return skill

    def publish(self, skill_id: int) -> Skill | None:
        """Publish a skill (change status to active)."""
        skill = self.get(skill_id)
        if skill:
            skill.status = SkillStatusEnum.ACTIVE
            skill.published_at = datetime.now(UTC)
            self.db.commit()
            self.db.refresh(skill)
        return skill

    def deprecate(self, skill_id: int) -> Skill | None:
        """Deprecate a skill."""
        skill = self.get(skill_id)
        if skill:
            skill.status = SkillStatusEnum.DEPRECATED
            self.db.commit()
            self.db.refresh(skill)
        return skill


