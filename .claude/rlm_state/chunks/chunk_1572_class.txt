<!-- Chunk 1572: bytes 6491141-6499904, type=class -->
class UpdateSkillRequest(BaseModel):
    """Request body for updating a skill."""

    content: str | None = None
    metadata: dict | None = None


@router.put("/{skill_id}", response_model=dict[str, str])
async def update_skill(
    skill_id: str,
    request: UpdateSkillRequest,
    skill_service: Annotated[SkillService, Depends(get_skill_service)],
) -> dict[str, str]:
    """
    Update an existing skill.

    Args:
        skill_id: Unique skill identifier
        request: Update request with content and/or metadata
        skill_service: Injected SkillService for data access

    Returns:
        Dictionary with skill_id and status

    Raises:
        HTTPException: If skill not found (404)

    """
    try:
        # Verify skill exists
        skill_service.get_skill_by_path(skill_id)

        # Resolve the actual filesystem path
        relative_path = skill_service.taxonomy_manager.resolve_skill_location(skill_id)
        skill_path = skill_service.skills_root / relative_path

        # Update skill if content provided
        if request.content:
            skill_md_path = skill_path / "SKILL.md"
            if skill_md_path.exists():
                skill_md_path.write_text(request.content, encoding="utf-8")

        # Update metadata if provided
        if request.metadata:
            metadata_path = skill_path / "metadata.json"
            if metadata_path.exists():
                # Read existing metadata
                current = json.loads(metadata_path.read_text(encoding="utf-8"))
                # Merge updates
                current.update(request.metadata)
                # Write back
                metadata_path.write_text(json.dumps(current, indent=2), encoding="utf-8")

        return {"skill_id": skill_id, "status": "updated"}
    except FileNotFoundError as err:
        raise NotFoundException("Skill", skill_id) from err
    except Exception as err:
        from fastapi import status

        from ..exceptions import SkillFleetAPIError

        raise SkillFleetAPIError(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to update skill: {str(err)}",
        ) from err


@router.post("/{skill_id}/validate", response_model=ValidateSkillResponse)
async def validate_skill(
    skill_id: str,
    request: ValidateSkillRequest,
    skill_service: Annotated[SkillService, Depends(get_skill_service)],
) -> ValidateSkillResponse:
    """
    Validate a skill.

    Args:
        skill_id: Unique skill identifier
        request: Validation request
        skill_service: Injected SkillService for data access

    Returns:
        ValidateSkillResponse: Validation results with pass/fail status

    Raises:
        HTTPException: If skill not found (404)

    """
    # Load skill content for validation
    try:
        skill_data = skill_service.get_skill_by_path(skill_id)
        content = skill_data.get("content", "")
        metadata = {
            "skill_id": skill_data.get("skill_id"),
            "name": skill_data.get("name"),
            "type": skill_data.get("type"),
            **skill_data.get("metadata", {}),
        }
    except FileNotFoundError as err:
        raise NotFoundException("Skill", skill_id) from err

    # Initialize workflow and run validation
    workflow = ValidationWorkflow()

    try:
        taxonomy_path = metadata.get("taxonomy_path") or "general"
        result = await workflow.execute(
            skill_content=content,
            plan={"skill_metadata": metadata},
            taxonomy_path=taxonomy_path,
        )

        validation_report = result.get("validation_report", {})
        issues = validation_report.get("issues", [])

        # Build issues list
        formatted_issues = []
        for issue in issues:
            formatted_issues.append(
                {
                    "severity": issue.get("severity", "warning"),
                    "message": issue.get("message", str(issue)),
                }
            )

        return ValidateSkillResponse(
            passed=validation_report.get("passed", False),
            status="passed" if validation_report.get("passed", False) else "failed",
            score=validation_report.get("score", 0.0),
            issues=formatted_issues,
        )

    except Exception as e:
        logger.exception(f"Error in skill validation: {e}")
        raise HTTPException(status_code=500, detail=f"Validation failed: {e}") from e


@router.post("/{skill_id}/refine", response_model=RefineSkillResponse)
async def refine_skill(
    skill_id: str,
    request: RefineSkillRequest,
    skill_service: Annotated[SkillService, Depends(get_skill_service)],
) -> RefineSkillResponse:
    """
    Refine a skill based on user feedback.

    Args:
        skill_id: Unique skill identifier
        request: Refinement request with feedback
        skill_service: Injected SkillService for data access

    Returns:
        RefineSkillResponse: Response with job_id and status

    Raises:
        HTTPException: If skill not found (404)

    Note:
        Currently creates a job but doesn't run async refinement.
        Full implementation would create a background job that
        applies the feedback via the QualityAssuranceOrchestrator.

    """
    # Load skill content for refinement
    try:
        skill_data = skill_service.get_skill_by_path(skill_id)
        content = skill_data.get("content", "")
        metadata = {
            "skill_id": skill_data.get("skill_id"),
            "name": skill_data.get("name"),
            "type": skill_data.get("type"),
            **skill_data.get("metadata", {}),
        }
    except FileNotFoundError as err:
        raise NotFoundException("Skill", skill_id) from err

    # Initialize workflow
    workflow = ValidationWorkflow()

    try:
        # Run validation with feedback (which triggers refinement in the workflow)
        taxonomy_path = metadata.get("taxonomy_path") or "general"
        result = await workflow.execute(
            skill_content=content,
            plan={"skill_metadata": metadata},
            taxonomy_path=taxonomy_path,
        )

        # Check if refinement was successful
        refined_content = result.get("refined_content")
        if refined_content:
            # Save refined content back to skill storage
            try:
                skill_path = skill_service.taxonomy_manager.resolve_skill_location(skill_id)
                skill_md_path = skill_service.skills_root / skill_path / "SKILL.md"
                if skill_md_path.exists():
                    skill_md_path.write_text(refined_content, encoding="utf-8")
                    logger.debug(f"Persisted refined skill to {skill_md_path}")
                else:
                    logger.warning(f"Could not persist refinement: {skill_md_path} not found")
            except Exception as e:
                logger.error(f"Failed to persist refinement: {e}")

            message = "Skill refined successfully based on feedback"
            status = "completed"
        else:
            message = "No refinement needed - feedback already incorporated"
            status = "accepted"

        return RefineSkillResponse(
            job_id=skill_id,
            status=status,
            message=message,
        )

    except Exception as e:
        logger.exception(f"Error in skill refinement: {e}")
        raise HTTPException(status_code=500, detail=f"Refinement failed: {e}") from e


============================================================
END FILE: src/skill_fleet/api/v1/skills.py
============================================================

============================================================
FILE: src/skill_fleet/api/v1/taxonomy.py
============================================================

"""
Taxonomy management routes for v1 API.

This module provides endpoints for taxonomy operations.
These routes use taxonomy service for managing skills taxonomy.

Endpoints:
    GET  /api/v1/taxonomy - Get global taxonomy
    POST /api/v1/taxonomy - Update taxonomy
    GET  /api/v1/taxonomy/user/{user_id} - Get user-specific taxonomy
    POST /api/v1/taxonomy/user/{user_id}/adapt - Adapt taxonomy to user
"""

from __future__ import annotations

import logging
from datetime import datetime
from typing import Any

from fastapi import APIRouter, HTTPException, Path

from skill_fleet.common.security import sanitize_taxonomy_path

from ..dependencies import TaxonomyManagerDep
from ..schemas.taxonomy import (
    AdaptTaxonomyRequest,
    AdaptTaxonomyResponse,
    TaxonomyResponse,
    UpdateTaxonomyRequest,
    UserTaxonomyResponse,
)
from ..services.cached_taxonomy import get_cached_taxonomy_service

logger = logging.getLogger(__name__)


